<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 16 - Is Renfield telling the truth?</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded "><a href="../chapter1/index.html"><strong aria-hidden="true">1.</strong> Chapter 1 - Jonathan Harker travels to Transylvania</a></li><li class="chapter-item expanded "><a href="../chapter2/index.html"><strong aria-hidden="true">2.</strong> Chapter 2 - At the Hotel in Bistritz</a></li><li class="chapter-item expanded "><a href="../chapter3/index.html"><strong aria-hidden="true">3.</strong> Chapter 3 - Jonathan goes to Castle Dracula</a></li><li class="chapter-item expanded "><a href="../chapter4/index.html"><strong aria-hidden="true">4.</strong> Chapter 4 - "What a strange man this Count Dracula is."</a></li><li class="chapter-item expanded "><a href="../chapter5/index.html"><strong aria-hidden="true">5.</strong> Chapter 5 - Jonathan tries to leave the castle</a></li><li class="chapter-item expanded "><a href="../chapter6/index.html"><strong aria-hidden="true">6.</strong> Chapter 6 - Still no escape</a></li><li class="chapter-item expanded "><a href="../chapter7/index.html"><strong aria-hidden="true">7.</strong> Chapter 7 - Jonathan finally "leaves" the castle</a></li><li class="chapter-item expanded "><a href="../chapter8/index.html"><strong aria-hidden="true">8.</strong> Chapter 8 - Dracula takes the boat to England</a></li><li class="chapter-item expanded "><a href="../chapter9/index.html"><strong aria-hidden="true">9.</strong> Chapter 9 - Strange events in England</a></li><li class="chapter-item expanded "><a href="../chapter10/index.html"><strong aria-hidden="true">10.</strong> Chapter 10 - Terrible events in Whitby</a></li><li class="chapter-item expanded "><a href="../chapter11/index.html"><strong aria-hidden="true">11.</strong> Chapter 11 - What's wrong with Lucy?</a></li><li class="chapter-item expanded "><a href="../chapter12/index.html"><strong aria-hidden="true">12.</strong> Chapter 12 - From bad to worse</a></li><li class="chapter-item expanded "><a href="../chapter13/index.html"><strong aria-hidden="true">13.</strong> Chapter 13 - Farewell, Lucy. Meet the new Lucy</a></li><li class="chapter-item expanded "><a href="../chapter14/index.html"><strong aria-hidden="true">14.</strong> Chapter 14 - Jonathan Harker returns</a></li><li class="chapter-item expanded "><a href="../chapter15/index.html"><strong aria-hidden="true">15.</strong> Chapter 15 - Time to start vampire hunting</a></li><li class="chapter-item expanded "><a href="../chapter16/index.html" class="active"><strong aria-hidden="true">16.</strong> Chapter 16 - Is Renfield telling the truth?</a></li><li class="chapter-item expanded "><a href="../chapter17/index.html"><strong aria-hidden="true">17.</strong> Chapter 17 - Poor Renfield. Poor Mina.</a></li><li class="chapter-item expanded "><a href="../chapter18/index.html"><strong aria-hidden="true">18.</strong> Chapter 18 - Using Dracula's own weapon against him</a></li><li class="chapter-item expanded "><a href="../chapter19/index.html"><strong aria-hidden="true">19.</strong> Chapter 19 - Dracula escapes</a></li><li class="chapter-item expanded "><a href="../chapter20/index.html"><strong aria-hidden="true">20.</strong> Chapter 20 - The final battle</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <hr />
<h2 id="tags-indexing-string-functions"><a class="header" href="#tags-indexing-string-functions">tags: Indexing, String Functions</a></h2>
<h1 id="chapter-16---is-renfield-telling-the-truth"><a class="header" href="#chapter-16---is-renfield-telling-the-truth">Chapter 16 - Is Renfield telling the truth?</a></h1>
<blockquote>
<p>Arthur Holmwood's father has died and now Arthur is the head of the house. His new title is Lord Godalming, and he has a lot of money. With this money he helps the team to find the houses where Dracula has hidden his boxes.</p>
<p>Meanwhile, Van Helsing has become curious about Renfield and asks John Seward if he can meet him. They meet, and Van Helsing is surprised to see that Renfield is very educated and well-spoken. Renfield talks about Van Helsing's research, politics, history, and so on - he doesn't seem crazy at all! But the next time Van Helsing sees him Renfield doesn't want to talk and just calls him an idiot. Very confusing. Why does Renfield's mood keep changing?</p>
<p>One night, Renfield becomes very serious and asks the men to let him leave. Renfield says: “Don’t you know that I am sane and earnest...a sane man fighting for his soul? Oh, hear me! hear me! Let me go! let me go! let me go!” The men want to believe Renfield, but can't trust him. Finally Renfield stops and calmly says: “Remember, later on, that I did what I could to convince you tonight.”</p>
</blockquote>
<h2 id="index-on-for-quicker-lookups"><a class="header" href="#index-on-for-quicker-lookups"><code>index on</code> for quicker lookups</a></h2>
<p>We're getting closer to the end of the book and there is a lot of data that we haven't entered yet. There is also a lot of data from the original book that might be useful. Fortunately, the original text of Dracula is organized into letters, diary entries, newspaper reports, etc. that begin with the date and sometimes the time. They tend to start out like this:</p>
<pre><code>Dr. Seward’s Diary.
1 October, 4 a. m.—Just as we were about to leave the house...

Letter, Van Helsing to Mrs. Harker.
“24 September.
“Dear Madam...

Mina Murray’s Journal.
8 August. — Lucy was very restless all night, and I, too, could not sleep...
</code></pre>
<p>Having so many dates in the book is convenient for us. With this we can make a type that holds a date and a string from the book for us to search through later. Let's call it <code>BookExcerpt</code> (an &quot;excerpt&quot; meaning one small part of a larger text). This type has a keyword that we haven't seen before. Can you see where it is?</p>
<pre><code class="language-sdl">type BookExcerpt {
  required date: cal::local_datetime;
  required excerpt: str;
  index on (.date);
  required author: Person;
}
</code></pre>
<p>The {ref}<code> ``index on (.date)`` &lt;docs:ref_datamodel_indexes&gt;</code> part is new, and is a way to make queries that use <code>filter</code>, <code>order by</code>, or <code>group</code> faster. These three operations are faster with <code>index on</code> because now the database doesn't need to scan the whole set of objects in sequence to find objects that match.</p>
<pre><code class="language-{eval-rst}">.. note::
`index` is good in limited quantities, but you don't want to index everything. Here is why:

- It makes the queries faster, but increases the database size.
- This may make `insert`s and `update`s slower if you have too many.

If there were no downside to indexing, EdgeDB would just index everything for you by default. Since there is a downside, indexing only happens when you say so. A good rule of thumb for indexes might be to compare them to an index in a real book:

- Faster search but database size increases: You can find content inside a book yourself, but you could also add an index. An index increases the book size somewhat, but helps you find content faster.
- Inserts take longer: each book you print has that many extra pages to print.
- Updates take longer: If you just update the content in a book, the update itself is the end of the operation. But if you have an index, then you'll have to update that as well to match the changes.
</code></pre>
<p>Indexing on <code>date</code> on the <code>BookExcerpt</code> type seems like a good idea because the <code>BookExcerpt</code> data all comes from a single book, is inserted once, and doesn't need to be updated. For comparison, an index on a property inside <code>PC</code> might make less sense, because <code>PC</code> objects are going to be inserted and updated all the time.</p>
<p>EdgeDB will automatically index in a few cases. You don't need to think about adding <code>index</code> on:</p>
<ul>
<li>links,</li>
<li>exclusive constraints for a property.</li>
</ul>
<p>The automatically generated <code>id</code> property on every item is also always indexed.</p>
<p>So let's do a migration and insert two book excerpts. The strings in these entries are very long (pages long, sometimes) so we will only show the beginning and the end here:</p>
<pre><code class="language-edgeql">insert BookExcerpt {
  date := cal::to_local_datetime(1893, 10, 1, 4, 0, 0),
  author := assert_single((select Person filter .name = 'John Seward')),
  excerpt := 'Dr. Seward\'s Diary.\n 1 October, 4 a.m. -- Just as we were about to leave the house, an urgent message was brought to me from Renfield to know if I would see him at once...&quot;You will, I trust, Dr. Seward, do me the justice to bear in mind, later on, that I did what I could to convince you to-night.&quot;',
};
</code></pre>
<pre><code class="language-edgeql">insert BookExcerpt {
  date := cal::to_local_datetime(1893, 10, 1, 5, 0, 0),
  author := assert_single((select Person filter .name = 'Jonathan Harker')),
  excerpt := '1 October, 5 a.m. -- I went with the party to the search with an easy mind, for I think I never saw Mina so absolutely strong and well...I rest on the sofa, so as not to disturb her.',
};
</code></pre>
<p>Then later on we could do this sort of query to get all the entries in order and displayed as JSON. Perhaps the players in the game can visit a library where they can search for game details, and this requires sending a message in JSON format to the software that displays it on the screen. In any case, here is what such a query would look like:</p>
<pre><code class="language-edgeql">select &lt;json&gt;(
  select BookExcerpt {
    date,
    author: {
      name
    },
    excerpt
  } order by .date
);
</code></pre>
<p>Here's the JSON output (remember to make the output pretty with <code>\set output-format json-pretty</code>) which looks pretty nice:</p>
<pre><code>{
  &quot;date&quot;: &quot;1893-10-01T04:00:00&quot;,
  &quot;author&quot;: {&quot;name&quot;: &quot;John Seward&quot;},
  &quot;excerpt&quot;: &quot;Dr. Seward's Diary.\n 1 October, 4 a.m. -- Just as we were about to leave the house, an urgent message was brought to me from Renfield to know if I would see him at once...\&quot;You will, I trust, Dr. Seward, do me the justice to bear in mind, later on, that I did what I could to convince you to-night.\&quot;&quot;
}
{
  &quot;date&quot;: &quot;1893-10-01T05:00:00&quot;,
  &quot;author&quot;: {&quot;name&quot;: &quot;Jonathan Harker&quot;},
  &quot;excerpt&quot;: &quot;1 October, 5 a.m. -- I went with the party to the search with an easy mind, for I think I never saw Mina so absolutely strong and well...I rest on the sofa, so as not to disturb her.&quot;
}
</code></pre>
<p>After this, we can add a link to our <code>Event</code> type to join it to our new <code>BookExcerpt</code> type. <code>Event</code> now looks like this:</p>
<pre><code class="language-sdl">type Event {
  required description: str;
  required start_time: cal::local_datetime;
  required end_time: cal::local_datetime;
  required multi place: Place;
  required multi people: Person;
  multi excerpt: BookExcerpt; # Only this is new
  location: tuple&lt;float64, float64&gt;;
  east: bool;
  property url := get_url() ++ &lt;str&gt;.location.0 
    ++ '_N_' ++ &lt;str&gt;.location.1 ++ '_' ++ ('E' if .east else 'W');
}
</code></pre>
<p>You can see that <code>description</code> is a short string that we write, while <code>excerpt</code> links to the longer pieces of text that come directly from the book.</p>
<p>With this done, let's get back to the <code>BookExcerpt</code> type and the indexing it uses. We now know that indexing speeds up <code>filter</code>, <code>order</code> and <code>group</code> queries, but by how much? Fortunately EdgeDB has a keyword that can provide some insight into this.</p>
<h2 id="the-analyze-keyword"><a class="header" href="#the-analyze-keyword">The 'analyze' keyword</a></h2>
<p>One particularly nice addition to EdgeDB 3.0 which released in 2023 is the <code>analyze</code> keyword, which just might be EdgeDB's easiest keyword to use. To analyze a query...just put the word <code>analyze</code> in front of it and you're done!</p>
<p>Let's give it a try with perhaps the smallest and simplest query possible: <code>analyze select true;</code>. Here is the output:</p>
<pre><code>───────── Coarse-grained Query Plan ─────────
     │ Time Cost Loops Rows Width │ Relations
root │  0.0 0.01   1.0  1.0     1 │
</code></pre>
<p>That's quite a bit of output even for a query as small as this one. Let's look at one part of the output at a time to make sure we understand it.</p>
<p>Width: This refers to the average size in bytes per row. This is pretty easy to play around with by changing the query: <code>analyze select 9;</code> shows a width of 8 bytes, <code>analyze select &lt;int16&gt;9;</code> a width of 2 bytes. In Chapter 8 we learned that &quot;The <code>__type__</code> link and <code>id</code> property together always make up 32 bytes&quot;, and this can be seen in an <code>analyze</code> query too. Try <code>analyze select Person;</code> and you'll see a width of 32.</p>
<p>Rows: This refers to the number of items returned. Let's take a look at the output of <code>analyze select {8, 9};</code> to show this:</p>
<pre><code>───────── Coarse-grained Query Plan ─────────
     │ Time Cost Loops Rows Width │ Relations
root │  0.0 0.03   1.0  2.0     8 │
</code></pre>
<p>As you can see, there are two items inside this set so the number of rows is 2.</p>
<p>Now let's change this query to a tuple instead and see what happens:</p>
<pre><code class="language-edgeql">analyze select (8, 9);
</code></pre>
<p>This tuple holds two values, but the tuple is a single object so the <code>analyze</code> output shows a single row with a different width.</p>
<pre><code>───────── Coarse-grained Query Plan ─────────
     │ Time Cost Loops Rows Width │ Relations
root │  0.0 0.01   1.0  1.0    32 │
</code></pre>
<p>And if you try an <code>analyze select Person;</code> you should see about 25 rows at this point in the book.</p>
<p>Time: This is the actual time in milliseconds of a query. This is pretty easy to show by giving EdgeDB a massive query that takes more than a few seconds so that we can count along. Remember the chapter on Cartesian multiplication and how an operation on multiple sets with multiple items will return a number of items equal to their product? In other words, <code>select {1, 2} + {1, 2};</code> will return four items instead of two.</p>
<p>So let's do that with a query that returns about 21 million items:</p>
<pre><code class="language-edgeql">analyze select {8, 8, 1} + {8, 1, 8} + {8, 1, 8} + {8, 1, 8} + {9, 0, 10} + {8, 9, 10} + {9, 0, 0} + {0, 0, 0} + {9, 9, 0} + {9, 9, 0} + {9, 9, 0} + {9, 9, 0} + {8, 8, 8, 8} + {8, 8, 8, 8, 8} + {9, 9};
</code></pre>
<p>You can count to four as you watch this query happen. Once it is done, you should see an output like this showing that the query took about four seconds.</p>
<pre><code>──────────────── Coarse-grained Query Plan ────────────────
     │   Time       Cost Loops       Rows Width │ Relations
root │ 4113.0 1009921.25   1.0 21257640.0     8
</code></pre>
<p>Cost: This is an arbitrary number used for comparison, so it doesn't mean dollars or cents or anything of the sort.</p>
<p>Loops: Loops refers to the number of &quot;executions of the node&quot;, which is information that comes from EdgeDB's Postgres backend. You could think of loops as a number representing the complexity of a query.</p>
<p>Relations: This refers to the links involved in a query. So while <code>analyze select NPC {*};</code> will not show any relations except to the type itself:</p>
<pre><code>─────────── Coarse-grained Query Plan ───────────
       │ Time    Cost Loops Rows Width │ Relations
① root │  0.3 1577.23   1.0  9.0    32 │ NPC
</code></pre>
<p>Changing the single-splat operator to the double-splat operator will:</p>
<pre><code>───────────────────────────────── Coarse-grained Query Plan ─────────────────────────────
                      │ Time       Cost  Loops Rows Width │ Relations
① root                │  0.6  313151.13    1.0  9.0    32 │ NPC
├──.lovers            │  0.3      493.9    9.0  1.0    32 │ NPC.lovers, PC, Vampire, Lord,
│                     │                                   │ Sailor, NPC, Crewman,
│                     │                                   │ MinorVampire
╰──.places_visited    │  0.1      93.98    9.0  1.0    32 │ Country, OtherPlace, Castle,
                      │                                   │ NPC.places_visited, City
</code></pre>
<p>The <code>analyze</code> keyword shows us that the splat operators, as fun and educational as they might be to use, have a performance impact. So be sure to use them only when experimenting with your code but not during production when you are paying the cost of every query.</p>
<p>Take this query for example:</p>
<pre><code class="language-edgeql">analyze select Place {*};
</code></pre>
<p>The output is as follows:</p>
<pre><code>────────────────────── Coarse-grained Query Plan ──────────────────────
       │ Time  Cost Loops Rows Width │ Relations
① root │  0.2 135.9   1.0 12.0    32 │ City, Country, Castle, OtherPlace
</code></pre>
<p>But if you didn't need to include <code>modern_name</code> on <code>Place</code> (for example), just removing that from the query improves performance a bit:</p>
<pre><code>db&gt; analyze select Place {name, coffins, id};

────────────────────── Coarse-grained Query Plan ──────────────────────
       │ Time  Cost Loops Rows Width │ Relations
① root │  0.1 108.5   1.0 12.0    32 │ City, Country, Castle, OtherPlace
</code></pre>
<p>So now that we know the basics of how to use <code>analyze</code>, let's learn a bit more about indexes and see what effect another index will have on our cost.</p>
<h2 id="indexes-again"><a class="header" href="#indexes-again">Indexes again</a></h2>
<p>Our <code>Event</code> type has a property called <code>location</code> that might be nice to filter or order by. Let's see how much it costs to use. And while we're at it, let's check the cost for the related <code>url</code> property too:</p>
<pre><code>db&gt; analyze select Event order by .location;

────────── Coarse-grained Query Plan ──────────
       │ Time  Cost Loops Rows Width │ Relations
① root │  0.0 48.49   1.0  2.0    64 │ Event

db&gt; analyze select Event order by .url;

─────────── Coarse-grained Query Plan ───────────
       │ Time   Cost Loops Rows Width │ Relations
① root │  0.0 145.99   1.0  2.0    64 │ Event
</code></pre>
<p>Okay, so these two operations cost 48.49 and 145.99 units. (Remember, this doesn't represent dollars and cents or anything like that)</p>
<p>Next we'll a line to the <code>Event</code> type to index the <code>location</code> property:</p>
<pre><code class="language-sdl">type Event {
  required description: str;
  required start_time: cal::local_datetime;
  required end_time: cal::local_datetime;
  required multi place: Place;
  required multi people: Person;
  location: tuple&lt;float64, float64&gt;;
  index on (.location); # &lt;-------- Right here
  property ns_suffix := '_N_' if .location.0 &gt; 0.0 else '_S_';
  property ew_suffix := '_E' if .location.1 &gt; 0.0 else '_W';
  property url := get_url() 
    ++ &lt;str&gt;(math::abs(.location.0)) ++ .ns_suffix 
    ++ &lt;str&gt;(math::abs(.location.1)) ++ .ew_suffix;
}
</code></pre>
<p>And then do a migration. Let's see what the cost is now! We'll try the same two queries with <code>order</code> that we just did. Here is the result:</p>
<pre><code>db&gt; analyze select Event order by .location;

────────── Coarse-grained Query Plan ──────────
       │ Time Cost Loops Rows Width │ Relations
① root │  0.0 1.03   1.0  2.0    64 │ Event

db&gt; analyze select Event order by .url;

────────── Coarse-grained Query Plan ──────────
       │ Time Cost Loops Rows Width │ Relations
① root │  0.0 1.33   1.0  2.0    64 │ Event
</code></pre>
<p>That's a big difference! The cost for both operations is barely over 1 of these imaginary units, compared to before where we saw 48.49 and 145.99.</p>
<h2 id="two-more-notes-on-index-on"><a class="header" href="#two-more-notes-on-index-on">Two more notes on <code>index on</code></a></h2>
<p>Another nice thing about <code>index on</code> is that it can also be used on expressions that you we make ourselves. For example, if we always need to query a <code>City</code>'s name along with its population, we could index in this way:</p>
<pre><code class="language-sdl">type City extending Place {
  annotation description := 'A place with 50 or more buildings. Anything else is an OtherPlace';
  population: int64;
  index on (.name ++ ': ' ++ &lt;str&gt;.population);
}
</code></pre>
<p>Also don't forget that you can add add an annotation to this as well. <code>(.name ++ ': ' + &lt;str&gt;.population)</code> might be a good case for an annotation if you think readers of the code might not know what it's for:</p>
<pre><code>type City extending Place {
    annotation description := 'A place with 50 or more buildings. Anything else is an OtherPlace';
    population: int64;
    index on (.name ++ ': ' ++ &lt;str&gt;.population) {
      annotation title := 'Lists city name and population for display in Long Library stage';
    }
}
</code></pre>
<p>If you are a Postgres user, you might be familiar with the multiple ways that you can index values. These indexes are available in EdgeDB as of version 3.0 inside a module called <code>pg</code>. Using them is pretty simple: just put the name of the index in between <code>index</code> and <code>on</code>. For example: <code>index pg::gin on (.name)</code> instead of <code>index on (.name)</code>. The Postgres indexes are known as <code>hash</code>, <code>btree</code>, <code>gin</code>, <code>gist</code>, <code>spgist</code>, and <code>brin</code>. You can read more about these indexes <a href="https://www.edgedb.com/docs/datamodel/indexes">here</a>.</p>
<h2 id="more-functions-for-strings"><a class="header" href="#more-functions-for-strings">More functions for strings</a></h2>
<p>The {ref}<code>functions for strings &lt;docs:ref_std_string&gt;</code> can be particularly useful when doing queries on our <code>BookExcerpt</code> type (or <code>BookExcerpt</code> via <code>Event</code>). They are pretty easy to use, so a quick example for each of them should be enough to understand how they work.</p>
<p>One is called {eql:func}<code>docs:std::str_lower</code> and makes strings lowercase:</p>
<pre><code>db&gt; select str_lower('RENFIELD WAS HERE');
{'renfield was here'}
</code></pre>
<p>Here it is in a longer query:</p>
<pre><code class="language-edgeql">select BookExcerpt {
  excerpt,
  length := (&lt;str&gt;(select len(.excerpt)) ++ ' characters'),
  the_date := (select (&lt;str&gt;.date)[0:10]),
} filter contains(str_lower(.excerpt), 'mina');
</code></pre>
<p>It uses <code>len()</code> which is then cast to a string, and <code>str_lower()</code> to compare against <code>.excerpt()</code> by making it lowercase first. It also slices the <code>cal::local_datetime</code> into a string so it can just print indexes 0 to 10. Here is the output:</p>
<pre><code>{
  default::BookExcerpt {
    excerpt: '1 October, 5 a.m. -- I went with the party to the search with an easy mind, for I think I never saw Mina so absolutely strong and well...I rest on the sofa, so as not to disturb her.',
    length: '182 characters',
    the_date: '1893-10-01',
  },
}
</code></pre>
<p>Another way to make this <code>the_date</code> parameter is with the {eql:func}<code>docs:std::to_str</code> method, which (as you can probably guess) will turn it into a <code>str</code>. This function also allows us to change the format of a date depending on how readable we want to make it:</p>
<pre><code class="language-edgeql">select BookExcerpt {
  excerpt,
  length := (&lt;str&gt;(select len(.excerpt)) ++ ' characters'),
  the_date := (select to_str(.date)),
  the_date_pretty := (select to_str(.date, 'YYYY-MM-DD')),
  the_date_time_pretty := (select to_str(.date, 'YYYY-MM-DD HH:MM:SS')),
  the_date_verbose := (select to_str(.date, 'The DD of MM, YYYY'))
} filter contains(str_lower(.excerpt), 'mina');
</code></pre>
<p>Here's the output for that long query:</p>
<pre><code>{
  default::BookExcerpt {
    excerpt: '1 October, 5 a.m. -- I went with the party to the search with an easy mind, for I think I never saw Mina so absolutely strong and well...I rest on the sofa, so as not to disturb her.',
    length: '182 characters',
    the_date: '1893-10-01T05:00:00',
    the_date_pretty: '1893-10-01',
    the_date_time_pretty: '1893-10-01 05:10:00',
    the_date_verbose: 'The 01 of 10, 1893',
  },
}
</code></pre>
<p>Some other functions for strings are:</p>
<ul>
<li><code>find()</code> This gives the index of the first match it finds, and returns <code>-1</code> if it can't find anything. A <code>-1</code> is returned because that's the last character in a string, meaning that the function has reached the end but has found nothing. One example:</li>
</ul>
<pre><code class="language-edgeql">select find(BookExcerpt.excerpt, 'sofa');
</code></pre>
<p>This will return <code>{-1, 151}</code>. That's because first <code>BookExcerpt.excerpt</code> doesn't have the word <code>sofa</code>, while the second has it at index 151.</p>
<ul>
<li><code>str_split()</code> lets you make an array from a string, split however you like. It is most commonly used by using <code>' '</code> to separate words:</li>
</ul>
<pre><code>db&gt; select str_split('Oh, hear me! hear me! Let me go! let me go! let me go!', ' ');
{
  [
    'Oh,',
    'hear',
    'me!',
    'hear',
    'me!',
    'Let',
    'me',
    'go!',
    'let',
    'me',
    'go!',
    'let',
    'me',
    'go!',
  ],
}
</code></pre>
<p>But we can choose a letter to split at too:</p>
<pre><code class="language-edgeql">select MinorVampire {
  names := (select str_split(.name, 'ampire'))
};
</code></pre>
<p>Now the names have been split into arrays at each instance of <code>ampire</code>. Note that <code>Lucy</code> remains unchanged.</p>
<pre><code>{
  default::MinorVampire {names: ['V', ' Woman 1']},
  default::MinorVampire {names: ['V', ' Woman 2']},
  default::MinorVampire {names: ['V', ' Woman 3']},
  default::MinorVampire {names: ['Lucy']},
}
</code></pre>
<p>You can also split by <code>\n</code> to split by new line. You can’t see it as a human but from the point of view of the computer every line has an <code>\n</code> at the end if it is followed by another line. Take this for example:</p>
<pre><code class="language-edgeql">select str_split('Oh, hear me!
hear me!
Let me go!
let me go!
let me go!', '\n');
</code></pre>
<p>The output is an array of the text split by line:</p>
<pre><code>{['Oh, hear me!', 'hear me!', 'Let me go!', 'let me go!', 'let me go!']}
</code></pre>
<ul>
<li>Two functions called <code>re_match()</code> (for the first match) and <code>re_match_all()</code> (for all matches) if you know how to use <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a> (regexes) and want to use those. This could be especially useful for us because the book Dracula was written over 100 years ago and has different spelling sometimes. The word <code>tonight</code> for example is always written with the older <code>to-night</code> spelling in Dracula. We can use these functions to take care of that:</li>
</ul>
<pre><code class="language-edgeql">with text := 'Dracula is an old book,
so the word tonight is written to-night.
Tonight we know how to write both tonight and to-night.',
select re_match_all('[Tt]o-?night', text);
</code></pre>
<p>Here is the output:</p>
<pre><code>{['tonight'], ['to-night'], ['Tonight'], ['tonight'], ['to-night']}
</code></pre>
<p>The function signature is <code>std::re_match_all(pattern: str, string: str) -&gt; set of array&lt;str&gt;</code>, and as you can see the pattern comes first, then the string to match against. The pattern <code>[Tt]o-?night</code> means words that:</p>
<ul>
<li>start with a <code>T</code> or a <code>t</code>,</li>
<li>then have an <code>o</code>,</li>
<li>maybe have an <code>-</code> in between,</li>
<li>and end in <code>night</code>.</li>
</ul>
<p>And to match anything, you can use the wildcard character: <code>.</code></p>
<pre><code>db&gt; select re_match_all('.oo.', 'Noo, Lord Dracula, why did you lock the door?');
{['Noo,'], ['door']}
</code></pre>
<p>The <code>.</code> wildcard operator still determines the length of the slice of the string to match on, so you can use more of them to lengthen the part of the string in which we are looking for a match:</p>
<pre><code>db&gt; select re_match_all('.h...oo..', 'Noo, Lord Dracula, why did you lock the door?');
{['the door?']}
</code></pre>
<h2 id="changing-a-property-to-a-link"><a class="header" href="#changing-a-property-to-a-link">Changing a property to a link</a></h2>
<p>Our <code>Place</code> type has had a property called <code>important_places</code> for quite some time now: almost since the beginning of the book! This property is just an <code>&lt;array&lt;str&gt;&gt;</code>, which is better than nothing but not as good as a link. Let's remind ourselves what <code>important_places</code> are in the database at the moment:</p>
<pre><code class="language-edgeql">select Place {
  name, important_places
  } filter exists .important_places;
</code></pre>
<p>It turns out that we have a total of four <code>important_places</code>, all of which are located inside <code>City</code> objects:</p>
<pre><code>{
  default::City {name: 'Whitby', important_places: ['Whitby Abbey']},
  default::City {name: 'Bistritz', important_places: ['Golden Krone Hotel']},
  default::City {
    name: 'Buda-Pesth',
    important_places: ['Hospital of St. Joseph and Ste. Mary', 'Buda-Pesth University'],
  },
}
</code></pre>
<p>So let's think of a type we could make for these places. Our types that extend <code>Place</code> are all related to whether they have coffins or not, which is important in our game because places with coffins have a higher chance of being terrorized by vampires. These types so far are <code>City</code>, <code>Country</code>, <code>OtherPlace</code>, and <code>Castle</code> (which includes castle towns): all fairly large places that can be explored. But <code>important_places</code> seems more like a list of locations that are so tiny that keeping track of the number of coffins doesn't make any sense. In other words, it doesn't matter if the Golden Krone Hotel has coffins or not: it only matters if Bistritz has coffins in it or not.</p>
<p>So let's create a new type that is independent of the abstract type <code>Place</code>, and just call it <code>Landmark</code>:</p>
<pre><code class="language-sdl">type Landmark {
  required name: str;
  multi context: str;
}
</code></pre>
<p>Inside the <code>context</code> property we can just add parts of the book that reference the <code>Landmark</code>. We could have chosen <code>&lt;array&lt;str&gt;&gt;</code> but we haven't used <code>multi</code> properties much yet, so let's give that a try.</p>
<p>Eventually we will change our <code>Place</code> type so that <code>important places</code> changes from an <code>&lt;array&lt;str&gt;&gt;</code> to a <code>multi</code> link to <code>Landmark</code> that looks like the type below. The code below shows the final form for <code>Place</code>, but don't change it to this yet!</p>
<pre><code class="language-sdl">abstract type Place extending HasCoffins {
  required name: str {
    delegated constraint exclusive;
  }
  modern_name: str;
  multi important_places: Landmark;
}
</code></pre>
<p>We don't want to make this change yet because we will lose our data if we just change the type of <code>important_ places</code> to something else. Instead, we can first change our schema to add the <code>Landmark</code> type as a new <code>multi</code> link on <code>Place</code> we'll call <code>linked_important_places</code>. Let's make those changes and migrate the schema now:</p>
<pre><code class="language-sdl">type Landmark {
  required name: str;
  multi context: str;
}

abstract type Place extending HasCoffins {
  required name: str {
    delegated constraint exclusive;
  }
  modern_name: str;
  important_places: array&lt;str&gt;;
  multi linked_important_places: Landmark;
}
</code></pre>
<p>After doing a migration we now have the type <code>Landmark</code> in the schema, <code>Place</code> has a link to them, our <code>important_places</code> data is untouched, and we can now create some <code>Landmark</code> objects.</p>
<p>We can use the <code>array_unpack()</code> method to grab each <code>str</code> from all the <code>important_places</code> in all the <code>Place</code> objects we have so far, and use that to do the inserts:</p>
<pre><code class="language-edgeql">for place_name in select (array_unpack(Place.important_places))
union (insert Landmark {
  name := place_name
});
</code></pre>
<p>And now we can update our <code>Place</code> objects to have the link called <code>linked_important_places</code> to the <code>Landmark</code> objects that we have just inserted.</p>
<pre><code class="language-edgeql">update Place filter exists .important_places set {
  linked_important_places := (
    select Landmark filter .name in array_unpack(Place.important_places))
  };
</code></pre>
<p>This has returned three objects, so looks like it worked! Let's do a query to make sure:</p>
<pre><code class="language-edgeql">select Place {
  name,
  important_places,
  linked_important_places: { name }
  } filter exists .linked_important_places;
</code></pre>
<p>The output shows us that it worked! We can compare the existing data inside <code>important_places</code> and see that we now have <code>Landmark</code> objects with the same name as before.</p>
<pre><code>{
  default::City {
    name: 'Whitby',
    important_places: ['Whitby Abbey'],
    linked_important_places: {default::Landmark {name: 'Whitby Abbey'}},
  },
  default::City {
    name: 'Bistritz',
    important_places: ['Golden Krone Hotel'],
    linked_important_places: {default::Landmark {name: 'Golden Krone Hotel'}},
  },
  default::City {
    name: 'Buda-Pesth',
    important_places: ['Hospital of St. Joseph and Ste. Mary', 'Buda-Pesth University'],
    linked_important_places: {
      default::Landmark {name: 'Hospital of St. Joseph and Ste. Mary'},
      default::Landmark {name: 'Buda-Pesth University'},
    },
  },
}
</code></pre>
<p>And now that our data is safe, we can now do two more migrations. First we will remove <code>important_places</code> and migrate.</p>
<pre><code class="language-sdl">abstract type Place extending HasCoffins {
  required name: str {
    delegated constraint exclusive;
  }
  modern_name: str;
  multi linked_important_places: Landmark;
}
</code></pre>
<p>The CLI will ask us if we wanted to <code>drop property 'important_places' of object type 'default::Place'?</code>, to which the answer is yes.</p>
<p>And then we change the link name from <code>linked_important_places</code> to <code>important_places</code>, and do a migration again.</p>
<pre><code class="language-sdl">abstract type Place extending HasCoffins {
  required name: str {
    delegated constraint exclusive;
  }
  modern_name: str;
  multi important_places: Landmark;
}
</code></pre>
<p>This time the CLI asks us if we renamed <code>link 'linked_important_places' of object type 'default::Place' to 'important_places'?</code>, to which the answer once again is yes.</p>
<p>Let's do a final check to make sure that the data is there:</p>
<pre><code class="language-edgeql">select Place {
  name,
  important_places: { name }
} filter exists .important_places;
</code></pre>
<p>And the data is all there! Beautiful.</p>
<pre><code>{
  default::City {name: 'Whitby', important_places: {default::Landmark {name: 'Whitby Abbey'}}},
  default::City {
    name: 'Bistritz',
    important_places: {default::Landmark {name: 'Golden Krone Hotel'}},
  },
  default::City {
    name: 'Buda-Pesth',
    important_places: {
      default::Landmark {name: 'Hospital of St. Joseph and Ste. Mary'},
      default::Landmark {name: 'Buda-Pesth University'},
    },
  },
}
</code></pre>
<p>As always, the code at the end of the chapter will feature the inserts we would have made if we had had the current schema to begin with. So the insert for Buda-Pesth for example will now look like this, with the <code>Landmark</code> inserts at the same time.</p>
<pre><code class="language-edgeql">insert City {
  name := 'Buda-Pesth',
  modern_name := 'Budapest',
  important_places := {
    (insert Landmark {name := 'Hospital of St. Joseph and Ste. Mary'}),
    (insert Landmark {name := 'Buda-Pesth University'})
  }
};
</code></pre>
<p><a href="code.html">Here is all our code so far up to Chapter 16.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice"><a class="header" href="#time-to-practice">Time to practice</a></h2>
<ol>
<li>
<p>How would you write a query to show all the <code>Person</code> names split into an array of two strings if they have two names and ignored if they don't have exactly two names?</p>
</li>
<li>
<p>How would you display all the <code>Person</code> names and where the string 'ma' is in their name?</p>
<p>Hint: this uses the function <code>find()</code>.</p>
</li>
<li>
<p>How would you index on the <code>pen_name</code> property for type Person?</p>
<p>Hint: try using <code>describe type Person as SDL</code> to take a look at it the <code>pen_name</code> property again.</p>
</li>
<li>
<p>How would you display the name of every <code>Person</code> in uppercase followed by a space and then the same name in lowercase?</p>
<p>Hint: the {eql:func}<code>docs:std::str_upper</code> function could help (though you will also need another function)</p>
</li>
<li>
<p>How would you use <code>re_match_all()</code> to display all the <code>Person.name</code>s with <code>Crewman</code> in the name? e.g. Crewman 1, Crewman 2, etc.</p>
<p>Hint: <a href="https://en.wikipedia.org/w/index.php?title=Regular_expression&amp;oldid=988356211#Basic_concepts">Here are some basic concepts</a> if you want a quick read on regular expressions.</p>
</li>
</ol>
<p><a href="answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>The truth about Renfield.</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter15/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter17/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter15/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter17/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
