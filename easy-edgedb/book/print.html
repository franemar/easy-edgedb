<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="chapter1/index.html"><strong aria-hidden="true">1.</strong> Chapter 1 - Jonathan Harker travels to Transylvania</a></li><li class="chapter-item expanded "><a href="chapter2/index.html"><strong aria-hidden="true">2.</strong> Chapter 2 - At the Hotel in Bistritz</a></li><li class="chapter-item expanded "><a href="chapter3/index.html"><strong aria-hidden="true">3.</strong> Chapter 3 - Jonathan goes to Castle Dracula</a></li><li class="chapter-item expanded "><a href="chapter4/index.html"><strong aria-hidden="true">4.</strong> Chapter 4 - "What a strange man this Count Dracula is."</a></li><li class="chapter-item expanded "><a href="chapter5/index.html"><strong aria-hidden="true">5.</strong> Chapter 5 - Jonathan tries to leave the castle</a></li><li class="chapter-item expanded "><a href="chapter6/index.html"><strong aria-hidden="true">6.</strong> Chapter 6 - Still no escape</a></li><li class="chapter-item expanded "><a href="chapter7/index.html"><strong aria-hidden="true">7.</strong> Chapter 7 - Jonathan finally "leaves" the castle</a></li><li class="chapter-item expanded "><a href="chapter8/index.html"><strong aria-hidden="true">8.</strong> Chapter 8 - Dracula takes the boat to England</a></li><li class="chapter-item expanded "><a href="chapter9/index.html"><strong aria-hidden="true">9.</strong> Chapter 9 - Strange events in England</a></li><li class="chapter-item expanded "><a href="chapter10/index.html"><strong aria-hidden="true">10.</strong> Chapter 10 - Terrible events in Whitby</a></li><li class="chapter-item expanded "><a href="chapter11/index.html"><strong aria-hidden="true">11.</strong> Chapter 11 - What's wrong with Lucy?</a></li><li class="chapter-item expanded "><a href="chapter12/index.html"><strong aria-hidden="true">12.</strong> Chapter 12 - From bad to worse</a></li><li class="chapter-item expanded "><a href="chapter13/index.html"><strong aria-hidden="true">13.</strong> Chapter 13 - Farewell, Lucy. Meet the new Lucy</a></li><li class="chapter-item expanded "><a href="chapter14/index.html"><strong aria-hidden="true">14.</strong> Chapter 14 - Jonathan Harker returns</a></li><li class="chapter-item expanded "><a href="chapter15/index.html"><strong aria-hidden="true">15.</strong> Chapter 15 - Time to start vampire hunting</a></li><li class="chapter-item expanded "><a href="chapter16/index.html"><strong aria-hidden="true">16.</strong> Chapter 16 - Is Renfield telling the truth?</a></li><li class="chapter-item expanded "><a href="chapter17/index.html"><strong aria-hidden="true">17.</strong> Chapter 17 - Poor Renfield. Poor Mina.</a></li><li class="chapter-item expanded "><a href="chapter18/index.html"><strong aria-hidden="true">18.</strong> Chapter 18 - Using Dracula's own weapon against him</a></li><li class="chapter-item expanded "><a href="chapter19/index.html"><strong aria-hidden="true">19.</strong> Chapter 19 - Dracula escapes</a></li><li class="chapter-item expanded "><a href="chapter20/index.html"><strong aria-hidden="true">20.</strong> Chapter 20 - The final battle</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="easy-edgedb"><a class="header" href="#easy-edgedb">Easy EdgeDB</a></h1>
<p>Welcome to Easy EdgeDB! It's an interactive, illustrated textbook designed as a one-stop shop for learning EdgeDB.</p>
<p>We started writing this book shortly after the first alpha release of EdgeDB in Spring 2019. For the first time we had a functional version of the thing we'd been thinking about for so long: an open-source database powered by PostgreSQL that combined the strictness of relational databases, the declarative schema of ORMs, and the painless deep querying of GraphQL, without sacrificing power, consistency, or performance. </p>
<p>While plenty of learning material can be found in the <a href="https://www.edgedb.com/docs/">documentation</a>, <a href="https://edgedb.com/tutorial">interactive tutorial</a>, and <a href="https://www.edgedb.com/blog/we-can-do-better-than-sql">blog posts</a>, we wanted to put together a more immersive experience - a full book. The result is Easy EdgeDB: a book that's sufficiently comprehensive (and fun!) to shepherd an interested beginner through the full set of basic and intermediate EdgeDB concepts.</p>
<p>Easy EdgeDB is a bit of a unique book. Here's how it differs from what you might expect from a typical e-book:</p>
<h2 id="a-story-to-follow"><a class="header" href="#a-story-to-follow">A story to follow</a></h2>
<p>The book is divided into 20 chapters in which we imagine that we are creating a database for a game. The setting for our imaginary game is the scenes and locations from the book Dracula by Bram Stoker, published in 1897. Our job is to think a little about how to represent items like characters, events, locations, and dates in the book in a database used by a role-playing game built separately. In other words, something like <a href="https://www.edgedb.com/docs/clients/00_python/index/">Python</a>/<a href="https://www.edgedb.com/docs/clients/01_js/index/">JavaScript</a>/<a href="https://github.com/edgedb/edgedb-go">Go</a> on the frontend, and EdgeDB as the game's database. (Why Python, JavaScript and Go? Because EdgeDB has drivers for all three of those languages.)</p>
<p>Bram Stoker's Dracula was the perfect choice for this textbook for a few reasons:</p>
<ul>
<li>It's a fun read. We're excited to see you give EdgeDB a try and hope to make the introduction as painless and immersive as possible. We think that anyone who has spent an hour or so with EdgeDB will walk away excited about its possibilities, but for that to happen it's our job to make the experience a pleasant one. Bram Stoker's novel has really helped out here.</li>
<li>It's a so-called <em>epistolary novel</em>: a novel written through the letters, diaries, and communications written by the main characters. That means that each entry has a date and an author, which makes it a great fit for a database.</li>
<li>It's copyright free. Our book only scratches the surface of what a real database for a game based on this book would be like, but who knows? Maybe some readers will like it enough to take the concept a bit farther and make it into the real thing. And if that's the case, then an open source database software based on a book completely free of copyright is the best way to start.</li>
</ul>
<h2 id="plain-english"><a class="header" href="#plain-english">Plain English</a></h2>
<p>We want to give as many people as possible the opportunity to sit down and give EdgeDB a try, and so we've opted for a style of writing that's simple and straightforward. Not baby talk, just plain English. We have three types of people in mind here:</p>
<ul>
<li>People unfamiliar with how to build a database but ready to understand how they work if the concepts are explained in a straightforward way, </li>
<li>People who <em>are</em> familiar with databases but maybe aren't in the mood to wade through dense verbiage for a product they've never seen before, </li>
<li>People with English as a second (or third, fourth...) language who would much prefer reading a book in plain English for the same reason.</li>
</ul>
<h2 id="interactivity-and-experimentation"><a class="header" href="#interactivity-and-experimentation">Interactivity and experimentation</a></h2>
<p>Because the book uses the events in the book for the background, we need a database to tie everything together. It will need to show the connections between the characters, locations, dates, and more. It starts with a simple schema (structure) and builds up from there, changing it as we go. The idea is to simulate the mental process for someone new to EdgeDB that has been given the task of putting this all together. That includes sometimes modifying the schema, creating new types, deleting ones that aren't used, and all the tinkering you'd see in real life.</p>
<p>Going through the book, we will learn how to use queries that are more and more complex. Each chapter contains the schema and inserted data that we've built up so far, and a REPL for you to experiment with. On top of that, each chapter has a number of questions for you to solve if you feel like a small challenge.</p>
<h2 id="beauty"><a class="header" href="#beauty">Beauty</a></h2>
<p>We looked far and wide, and didn't see any rule that a text on database software has to be dry and image free. To give a feel for the beauty of the original work (with a steampunk-ish vibe added for good measure) we teamed up with Damian Dide≈Ñko (<a href="https://www.instagram.com/didiusz/">didiusz on Instagram</a>), an illustrator of 10 years from Katowice, Poland, to put together some beautiful sketches that combine the atmosphere of the book Dracula with the most important schema and query concepts per chapter. You'll soon become familiar with his illustrations but here is how he describes them and what inspires him:</p>
<blockquote>
<p>I try to take inspiration from everything that I have contact with. In my works, I like to build slightly surreal, understated/untold stories that leave the viewer room for their own interpretation. The works themselves are a loose stream of thoughts that make sense while creating, sometimes at the very end and sometimes not at all - because not everything has to make sense. My works often start with a small idea that grows into a much larger composition. I like to create works that are rich in detail, in which I sometimes hide what inspires me. They are a bit like little easter eggs for the watchful observer.</p>
</blockquote>
<p>We're pleased to have teamed up with Damian to put the final touch on a book that blends the old and the new in a form that we hope will keep you turning the page as you familiarize yourself with EdgeDB and discover what it has to offer you.</p>
<p><strong><a href="chapter1/index.html">So let's get started - on to Chapter 1!</a></strong> Or see the full chapter list below:</p>
<h1 id="full-chapter-list"><a class="header" href="#full-chapter-list">Full chapter list</a></h1>
<ul>
<li><a href="chapter1/index.html">Chapter 1 - Jonathan Harker travels to Transylvania</a></li>
<li><a href="chapter2/index.html">Chapter 2 - At the Hotel in Bistritz</a></li>
<li><a href="chapter3/index.html">Chapter 3 - Jonathan goes to Castle Dracula</a></li>
<li><a href="chapter4/index.html">Chapter 4 - &quot;What a strange man this Count Dracula is.&quot;</a></li>
<li><a href="chapter5/index.html">Chapter 5 - Jonathan tries to leave the castle</a></li>
<li><a href="chapter6/index.html">Chapter 6 - Still no escape</a></li>
<li><a href="chapter7/index.html">Chapter 7 - Jonathan finally &quot;leaves&quot; the castle</a></li>
<li><a href="chapter8/index.html">Chapter 8 - Dracula takes the boat to England</a></li>
<li><a href="chapter9/index.html">Chapter 9 - Strange events in England</a></li>
<li><a href="chapter10/index.html">Chapter 10 - Terrible events in Whitby</a></li>
<li><a href="chapter11/index.html">Chapter 11 - What's wrong with Lucy?</a></li>
<li><a href="chapter12/index.html">Chapter 12 - From bad to worse</a></li>
<li><a href="chapter13/index.html">Chapter 13 - Farewell, Lucy. Meet the new Lucy</a></li>
<li><a href="chapter14/index.html">Chapter 14 - Jonathan Harker returns</a></li>
<li><a href="chapter15/index.html">Chapter 15 - Time to start vampire hunting</a></li>
<li><a href="chapter16/index.html">Chapter 16 - Is Renfield telling the truth?</a></li>
<li><a href="chapter17/index.html">Chapter 17 - Poor Renfield. Poor Mina.</a></li>
<li><a href="chapter18/index.html">Chapter 18 - Using Dracula's own weapon against him</a></li>
<li><a href="chapter19/index.html">Chapter 19 - Dracula escapes</a></li>
<li><a href="chapter20/index.html">Chapter 20 - The final battle</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><code>Object Types</code></th><th style="text-align: center"><code>Select</code></th><th style="text-align: center"><code>Insert</code></th></tr></thead><tbody>
</tbody></table>
</div>
<p><img src="chapter1/illustration_01.jpg" alt="leadImage" /></p>
<h1 id="chapter-1---jonathan-harker-travels-to-transylvania"><a class="header" href="#chapter-1---jonathan-harker-travels-to-transylvania">Chapter 1 - Jonathan Harker travels to Transylvania</a></h1>
<p>In the beginning of the book we see the main character Jonathan Harker, a young lawyer who is going to meet a client. The client is a rich man named Count Dracula who lives somewhere in Eastern Europe. Jonathan is enjoying the trip to a new part of Europe, completely unaware that Count Dracula is actually a vampire. The book begins with Jonathan writing in his journal as he travels. The parts in his journal to note when thinking about a database are in <strong>bold</strong>:</p>
<blockquote>
<p><strong>3 May</strong>. <strong>Bistritz</strong>.‚ÄîLeft <strong>Munich</strong> at <strong>8:35 P.M.</strong>, on <strong>1st May</strong>, arriving at <strong>Vienna</strong> early next morning; should have arrived at 6:46, but train was an hour late. <strong>Buda-Pesth</strong> seems a wonderful place, from the glimpse which I got of it from the train...</p>
</blockquote>
<h2 id="schema-object-types"><a class="header" href="#schema-object-types">Schema, object types</a></h2>
<p>The language used for EdgeDB is called EdgeQL, and is used to define, mutate, and query data. The schema in your database uses {ref}<code>SDL (schema definition language)&lt;docs:ref_eql_sdl&gt;</code> that makes migration easy, and which we will learn in this book. The quote from Jonathan Harker's journal can help us start to think about our database. We'll start with our schema, which needs the following:</p>
<ul>
<li>Some kind of <code>City</code> or <code>Location</code> type. These types that we can create are called {ref}<code>object types &lt;docs:ref_datamodel_object_types&gt;</code>, made out of properties and links to other objects. What properties should a <code>City</code> type have? Perhaps a name and a location, and sometimes a different name or spelling. Bistritz for example is in Romania and is now written Bistri»õa (note the »õ - it's Bistri»õa, not Bistrita), while Buda-Pesth is now written Budapest. But other cities like Munich are written in the same way in the 19th century as they are written today.</li>
<li>Some kind of <code>NPC</code> type to represent the people in the book. This type could have a name, and also a way to track the places that the person visited.</li>
</ul>
<p>To make a type inside a schema, just use the keyword <code>type</code> followed by the type name. Our <code>NPC</code> type will start out like this:</p>
<pre><code class="language-sdl">type NPC;
</code></pre>
<p>That's all you need to create a type!</p>
<p>Now an <code>NPC</code> type that doesn't hold any properties isn't very useful, so we'll remove the <code>;</code> and replace them with <code>{}</code> curly brackets instead. The <code>NPC</code> type still doesn't have any properties but with the <code>{}</code> it is ready to hold them:</p>
<pre><code class="language-sdl">type NPC {

}
</code></pre>
<p>But hold on, where is our schema and how do you put a schema together? The easiest way to create a schema is to start an EdgeDB project. Here's how to get started:</p>
<ul>
<li>First make sure you have <a href="https://www.edgedb.com/install">EdgeDB installed on your computer</a>. You will now have the EdgeDB CLI installed which allows you to make new projects, apply migrations, and do many other things.</li>
<li>Once you have the EdgeDB CLI installed, make an empty directory where you want to hold your project. Now open up a command line (also known as a Terminal). If you are on Windows and haven't opened a command line before, type the Windows key and <code>cmd</code>, then click on Command Prompt. Then type <code>cd c:/easy-edgedb</code> or whatever the name of your directory is. Or you can right click on a folder inside Windows File Explorer and select <code>Open in Terminal</code>.</li>
<li>Type <code>edgedb project init</code>. The EdgeDB CLI will now ask you a few questions. The output should look something like this:</li>
</ul>
<pre><code>No `edgedb.toml` found in `\\?\C:\easy-edgedb` or above
Do you want to initialize a new project? [Y/n]
&gt; Y
Specify the name of EdgeDB instance to use with this project [default: easy_edgedb]:
&gt; easy_edgedb
Checking EdgeDB versions...
Specify the version of EdgeDB to use with this project [default: 3.0]:
&gt; 3.0
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Project directory   ‚îÇ \\?\C:\easy-edgedb                  ‚îÇ
‚îÇ Project config      ‚îÇ \\?\C:\easy-edgedb\edgedb.toml      ‚îÇ
‚îÇ Schema dir (empty)  ‚îÇ \\?\C:\easy-edgedb\dbschema         ‚îÇ
‚îÇ Installation method ‚îÇ WSL                                 ‚îÇ
‚îÇ Version             ‚îÇ 3.0-rc.2+02561bd                    ‚îÇ
‚îÇ Instance name       ‚îÇ easy_edgedb                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Version 3.0-rc.2+02561bd is already downloaded
Initializing EdgeDB instance...
Applying migrations...
Everything is up to date. Revision initial
Project initialized.
To connect to easy_edgedb, run `edgedb`
</code></pre>
<p>That was easy! Now try typing <code>edgedb</code>, which will take you into the EdgeDB REPL. (You can leave the REPL whenever you like by typing <code>\q</code>.) You can also type <code>edgedb ui</code> if you prefer to use the EdgeDB UI, which includes its own REPL and a lot of other nice tools like a data explorer and a query editor to help you put queries together. See <a href="https://www.youtube.com/watch?v=iwnP_6tkKgc">this short video</a> for an introduction to the EdgeDB UI.</p>
<p>Now type <code>select 'Jonathan Harker';</code> and hit enter. You should see some output that looks like this, with your folder name instead of <code>db&gt;</code> in the sample below:</p>
<pre><code>db&gt; select &quot;Jonathan Harker&quot;;
{'Jonathan Harker'}
db&gt;
</code></pre>
<p>You just made your first query in EdgeDB!</p>
<p>So now let's take a look at the schema so we can create our <code>NPC</code> type. The CLI has already let us know that the schema is inside the <code>\edgedb\dbschema</code> directory, so go inside there and look for a file called <code>default.esdl</code>. This is your schema. At the moment, all it holds is a module called <code>default</code>:</p>
<pre><code class="language-sdl">module default {

}
</code></pre>
<p>A module is a space containing the types for our database, including our <code>NPC</code> type. Let's give it a try! Add the <code>NPC</code> type that we made above, as follows:</p>
<pre><code class="language-sdl">module default {
  type NPC {
  }
}
</code></pre>
<p>Make sure the file is saved, and then create a migration. You can do this by typing <code>edgedb migration create</code> if you are on the command line, or (even easier) by typing <code>\migration create</code> inside the REPL. Commands that start with <code>edgedb</code> on the command line are done in the same way in the REPL except that you replace <code>edgedb</code> with a backslash.</p>
<p>You should see some output that looks like the following:</p>
<pre><code>Created c:\easy-edgedb\dbschema\migrations\00001.edgeql, id: m14c35zu7lzg46r2337nwehaihkv6d4xwcatu6ulogd5kqafjtrnra
</code></pre>
<p>Now type <code>edgedb migrate</code> (or <code>\migrate</code> inside the REPL). The CLI will apply the migration with the following output:</p>
<pre><code>Applied m14c35zu7lzg46r2337nwehaihkv6d4xwcatu6ulogd5kqafjtrnra (00001.edgeql)
</code></pre>
<p>And you are done!</p>
<p>To sum up, an EdgeDB migration simply consists of the following:</p>
<ul>
<li>Changing your schema,</li>
<li>Typing <code>edgedb migration create</code> (or <code>\migration create</code>),</li>
<li>Typing <code>edgedb migrate</code> (or <code>\migrate</code>).</li>
</ul>
<p>We will be doing a lot of that in this book! Even by the second chapter you will be very used to this process.</p>
<pre><code class="language-{eval-rst}">.. note::
  The CLI creates a new file upon each migration to generate the commands to change the schema to the one we want. The first file will be called 00001.edgeql, the second will be 00002.edgeql, and so on. These files are quite readable so feel free to take a look at if you are curious. But note that they use a syntax called DDL (Data Definition Language) that gives commands to EdgeDB one at a time, and you do not need to learn it. The language that we are using in the schema is called SDL (Schema Definition Language), which simply declares what a schema will look like. The CLI then automatically creates DDL commands to make it happen.
</code></pre>
<p>Now that we know how to do a schema migration, let's add some properties to our <code>NPC</code> type. Use the keyword <code>required</code> if the type needs it, and just the property name if it is optional. Let's give the <code>NPC</code> type a name and an array (a collection) of places visited:</p>
<pre><code class="language-sdl">type NPC {
  required name: str;
  places_visited: array&lt;str&gt;;
}
</code></pre>
<p>With <code>required name</code> our <code>NPC</code> objects are always guaranteed to have a name - you can't make an <code>NPC</code> object without it. Give it a try with this query:</p>
<pre><code class="language-edgedb">insert NPC;
</code></pre>
<p>You should see this error message:</p>
<pre><code>error: MissingRequiredError: missing value for required property 'name' of object type 'default::NPC'
  ‚îå‚îÄ &lt;query&gt;:1:1
  ‚îÇ
1 ‚îÇ insert NPC;
  ‚îÇ ^^^^^^^^^^ error
</code></pre>
<p>The keyword <code>str</code> stands for string, which contains text. A <code>str</code> goes inside either single quotes: <code>select 'Jonathan Harker';</code> or double quotes: <code>select &quot;Jonathan Harker&quot;;</code>.</p>
<p>If you have a single or double quote inside a string, you can use the <code>\</code> escape character to make EdgeDB treat it like just another letter inside the string. Give the <code>\</code> escape character a try to fix the query below that doesn't work because EdgeDB thinks that the single quote after <code>Harker</code> is the end of the string:</p>
<pre><code class="language-edgeql">select 'Jonathan Harker's journal';
</code></pre>
<p>The next property is an <code>array</code>. An <code>array</code> is a collection of the same type, and our array here is an array of <code>str</code>s. We want it to look like this inside our first <code>NPC</code> object:</p>
<pre><code>[&quot;Bistritz&quot;, &quot;Munich&quot;, &quot;Buda-Pesth&quot;]
</code></pre>
<p>The idea is to easily search later and see which character has visited where.</p>
<p>Unlike <code>name</code>, <code>places_visited</code> is not a <code>required</code> property because we might later add minor characters that don't go anywhere. Maybe one person will be the &quot;innkeeper_in_bistritz&quot; or something, and we won't know or care about <code>places_visited</code> for him.</p>
<p>The next type to add to our schema is a <code>City</code>. It look like this:</p>
<pre><code class="language-sdl">type City {
  required name: str;
  modern_name: str;
}
</code></pre>
<p>This type is pretty easy too, and just holds two properties with strings. The <code>modern_name</code> property is because the book Dracula was published in 1897 when spelling for cities was sometimes different. All cities have a name in the book (that's why it's <code>required</code>), and some will need a different modern name. But some don't: Munich in the book is still spelled Munich, for example. With this we could link the city names to their modern names so we can easily place them on a map.</p>
<h2 id="migration"><a class="header" href="#migration">Migration</a></h2>
<p>We've now added our first two types, but EdgeDB hasn't processed our changes yet. To make the changes happen we can do our first migration with <code>edgedb migration create</code>. After using this command, you will see a number of questions similar to the one below:</p>
<pre><code>Did you create object type 'default::City'? [y,n,l,c,b,s,q,?]
&gt;
</code></pre>
<p>The CLI does this to make sure that it is applying the right changes to the schema, and to give us the opportunity to make changes if it has misunderstood anything. Most of the time the CLI guesses correctly and you will just end up clicking <code>y</code> (to mean yes) over and over again for each change. But there are other possible answers we can give. Type <code>?</code> if you want to see what the letters for the other possible answers mean.</p>
<p>One of those is <code>l</code>, which means:</p>
<pre><code>l or list - list the DDL statements associated with prompt
</code></pre>
<p>Sure, let's be curious and try typing <code>l</code> to see what commands will be generated to create our <code>City</code> type. If we type <code>l</code> we will see the following:</p>
<pre><code>Did you create object type 'default::City'? [y,n,l,c,b,s,q,?]
&gt; l
The following DDL statements will be applied:
  CREATE TYPE default::City {
      CREATE PROPERTY modern_name: std::str;
      CREATE REQUIRED PROPERTY name: std::str;
  };
</code></pre>
<p>Looks good! It's a type called <code>City</code> inside the module <code>default</code>, it has a required property called <code>name</code> and a property called <code>modern_name</code>.</p>
<p>So why didn't we need to write <code>property</code> inside the <code>City</code> type? Let's look at it again:</p>
<pre><code class="language-sdl">type City {
  required name: str;
  modern_name: str;
}
</code></pre>
<p>There's no <code>property</code> keyword in there.</p>
<p>In the past you did have to write the <code>property</code> keyword for properties, and EdgeDB used a <code>-&gt;</code> (an arrow) instead of a <code>:</code> (a colon) after properties and links. Since the release of EdgeDB 3.0 in 2023 this is no longer required. So if you see any syntax that looks like the following, just keep in mind that it is pre-3.0 syntax:</p>
<pre><code class="language-sdl">type City {
  # required name: str;            &lt;-- Current syntax
  required property name -&gt; str; # &lt;-- Old syntax
  # modern name: str;              &lt;-- Current syntax
  property modern_name -&gt; str;   # &lt;-- Old syntax
}
</code></pre>
<p>Now back to the schema. Let's now just type <code>y</code> for every question that the CLI gives us to see what it does. After typing <code>y</code> two times, the CLI asks us a sudden question:</p>
<pre><code>Did you create object type 'default::City'? [y,n,l,c,b,s,q,?]
&gt; y
Did you alter object type 'default::NPC'? [y,n,l,c,b,s,q,?]
&gt; y
Please specify an expression to populate existing objects in order to make
property 'name' of object type 'default::NPC' required:
fill_expr&gt;
</code></pre>
<p>The CLI is essentially saying: &quot;There might be <code>NPC</code> objects in the database already. But now they all need to have a property called <code>name</code>, which wasn't required before. How should I decide what <code>name</code> to give them?&quot;</p>
<p>Fortunately, the expression here is pretty simple: let's just give them all an empty string. Type <code>''</code> and hit enter, and the CLI will now be happy with the migration. Don't forget to complete the migration with <code>edgedb migration</code>, and we are done!</p>
<p>If you are curious, take a look inside the migration file that EdgeDB generated. You can see how it created a command to change the <code>NPC</code> type, including a default value for <code>name</code> for any objects in the database:</p>
<pre><code>  ALTER TYPE default::NPC {
      CREATE REQUIRED PROPERTY name: std::str {
          SET REQUIRED USING (&lt;std::str&gt;{''});
      };
      CREATE PROPERTY places_visited: array&lt;std::str&gt;;
  };
</code></pre>
<p>There are a lot of other commands beyond the commands for migration, though we won't need them for this book. You could bookmark these four pages for later use, however:</p>
<ul>
<li>{ref}<code>Admin commands &lt;docs:ref_cheatsheet_admin&gt;</code>: Creating user roles, setting passwords, configuring ports, etc.</li>
<li>{ref}<code>CLI commands &lt;docs:ref_cheatsheet_cli&gt;</code>: Creating databases, roles, setting passwords for roles, connecting to databases, etc.</li>
<li>{ref}<code>REPL commands &lt;docs:ref_cheatsheet_repl&gt;</code>: Mostly shortcuts for a lot of the commands we'll be using in this book.</li>
<li>{ref}<code>Various commands &lt;docs:ref_eql_statements_rollback_tx&gt;</code> about rolling back transactions, declaring savepoints, and so on.</li>
</ul>
<p>There are also a few places to download packages to highlight your syntax if you like. EdgeDB has these packages available for <a href="https://atom.io/packages/edgedb">Atom</a>, <a href="https://marketplace.visualstudio.com/itemdetails?itemName=magicstack.edgedb">Visual Studio Code</a>, <a href="https://packagecontrol.io/packages/EdgeDB">Sublime Text</a>, and <a href="https://github.com/edgedb/edgedb-vim">Vim</a>.</p>
<p>And last but not least, here is the command if to use if you want to destroy your project and start again.</p>
<pre><code>edgedb instance destroy -I instance_name --force
</code></pre>
<p>Destroying an instance won't delete any files, so your schema and migration files won't be lost. If you want a completely clean slate, then first delete your instance, then delete the files inside the <code>migrations</code> folder, and then turn your schema back to <code>module default {}</code>.</p>
<p>Now let's start playing with some data!</p>
<h2 id="selecting"><a class="header" href="#selecting">Selecting</a></h2>
<p>The <code>select</code> keyword is the main query command in EdgeDB, and you use it to see results based on the input that comes after it. Keywords in EdgeDB are case insensitive, so <code>select</code>, <code>SELECT</code> and <code>SeLeCT</code> are all the same.</p>
<p>Let's give a <code>select</code> on a string a deeper look this time. Type <code>edgedb</code> to log into the REPL and give this a try:</p>
<pre><code class="language-edgeql">select 'Jonathan Harker begins his journey.';
</code></pre>
<p>This returns <code>{'Jonathan Harker begins his journey.'}</code>, no surprise there. But did you notice that it is inside a <code>{}</code>? This <code>{}</code> is actually quite important: <code>{}</code> means that it's a set, and in fact {ref}<code>everything in EdgeDB is a set &lt;docs:ref_eql_everything_is_a_set&gt;</code> (make sure to remember that). Thanks to the &quot;everything is a set&quot; philosophy, EdgeDB doesn't have null. Where you would have null in other databases like SQL, EdgeDB just gives you an empty set: <code>{}</code>. The advantage here is that sets always behave the same way even when they are empty, instead of <a href="https://www.edgedb.com/blog/we-can-do-better-than-sql#null-a-bag-of-surprises">all the unwelcome surprises</a> that come with using null.</p>
<p>For the next <code>select</code> queries, we will use some more operators that use the <code>=</code> sign:</p>
<ul>
<li><code>:=</code> is used to declare / assign (to give a value to something),</li>
<li><code>=</code> is used to check equality (not <code>==</code>),</li>
<li><code>!=</code> is the opposite of <code>=</code>.</li>
</ul>
<p>Let's use <code>:=</code> to assign a variable:</p>
<pre><code class="language-edgeql">select jonathans_name := 'Jonathan Harker';
</code></pre>
<p>This just returns what we gave it: <code>{'Jonathan Harker'}</code>. But this time it's a string that we assigned called <code>jonathans_name</code> that is being returned.</p>
<p>Now let's do something with this variable. We can use the keyword <code>select</code> to use this variable and then compare it to <code>'Count Dracula'</code>:</p>
<pre><code class="language-edgeql">select jonathans_name := 'Jonathan Harker' != 'Count Dracula';
</code></pre>
<p>You can read this as &quot;Is the variable called jonathans_name, which is a string with the value 'Jonathan Harker', different from the string 'Count Dracula'?&quot;</p>
<p>They are indeed different strings, so the output is <code>{true}</code>. Of course, you can just write <code>select 'Jonathan Harker' != 'Count Dracula';</code> for the same result. But knowing how to assign in this way with <code>:=</code> will allow us to do more complex operations later on.</p>
<h2 id="inserting-objects"><a class="header" href="#inserting-objects">Inserting objects</a></h2>
<p>Our database doesn't have any data in it yet! Time to change that.</p>
<p>Let's start inserting some <code>City</code> objects with the simple schema we already have by using the <code>insert</code> keyword, followed by the type name and some properties. The property <code>name</code> is required, while <code>modern_name</code> is not required.</p>
<p>Don't forget to separate each property by a comma, and finish the <code>insert</code> with a semicolon. Indentation isn't relevant in EdgeQL like it is in languages such as Python and F#, but EdgeDB prefers two spaces for indentation. Our first three cities look like this:</p>
<pre><code class="language-edgeql">insert City { name := 'Munich' };

insert City {
  name := 'Buda-Pesth',
  modern_name := 'Budapest'
};

insert City {
  name := 'Bistritz',
  modern_name := 'Bistri»õa'
};
</code></pre>
<p>Note that a comma after the last parameter (a so-called &quot;trailing comma&quot;) is optional - you can put it in or leave it out. In our three <code>City</code> inserts you can see that one insert has a trailing comma, while the others don't have it.</p>
<p>Finally, our <code>NPC</code> insert for Jonathan Harker would look like this, but don't insert it yet.</p>
<pre><code class="language-edgeql">insert NPC {
  name := 'Jonathan Harker',
  places_visited := [&quot;Bistritz&quot;, &quot;Munich&quot;, &quot;Buda-Pesth&quot;],
};
</code></pre>
<p>Because hold on a second...that insert won't link our <code>NPC</code> object for Jonathan Harker to any of the <code>City</code> inserts that we already did! The <code>places_visited</code> parameter is just an array of strings. Is there a way to connect Jonathan Harker to our <code>City</code> objects instead?</p>
<p>Here's where our schema needs some improvement. To sum up:</p>
<ul>
<li>We have an <code>NPC</code> type and a <code>City</code> type,</li>
<li>The <code>NPC</code> type has the property <code>places_visited</code> with the names of the cities, but they are just strings in an array. It would be better to link this property to the <code>City</code> type somehow.</li>
</ul>
<p>So let's not do that <code>NPC</code> insert. We'll fix the <code>NPC</code> type soon by changing <code>array&lt;str&gt;</code> to a <code>multi City</code>, which will create a link to one or more <code>City</code> objects. After this change, <code>NPC</code> and <code>City</code> objects will actually be joined together.</p>
<p>But first let's look a bit closer at what happens when we use <code>insert</code>.</p>
<p>We saw when inserting our first three <code>City</code> objects that strings (<code>str</code>) are fine with unicode letters like »õ. In fact, even emojis and special characters are just fine, so you could even create a <code>City</code> called <code>'ü§†'</code> or <code>'(‚ïØ¬∞‚ñ°¬∞)‚ïØÔ∏µ ‚îª‚îÅ‚îª'</code> if you wanted to. (Go ahead and insert a <code>City</code> called <code>'(‚ïØ¬∞‚ñ°¬∞)‚ïØÔ∏µ ‚îª‚îÅ‚îª'</code> or anything else if you want - you won't break anything!)</p>
<p>EdgeDB has a somewhat similar type to <code>str</code> called a byte literal, which gives you the bytes of a string. This is mainly for raw data that humans don't need to view when saving to files. They must be characters that are 1 byte long.</p>
<p>You create byte literals by adding a <code>b</code> in front of the string:</p>
<pre><code>db&gt; select b'Bistritz';
{b'Bistritz'}
</code></pre>
<p>And because the characters must be 1 byte, only ASCII works for this type. So the name in <code>modern_name</code> as a byte literal will generate an error because of the <code>»õ</code>:</p>
<pre><code>db&gt; select b'Bistri»õa';
error: EdgeQLSyntaxError: invalid bytes literal: character '»õ' is unexpected,
only ascii chars are allowed in bytes literals
  ‚îå‚îÄ &lt;query&gt;:1:8
  ‚îÇ
1 ‚îÇ select b'Bistri»õa';
  ‚îÇ        ^ error
</code></pre>
<p>Now let's get to the output we saw from our three <code>City</code> object inserts. Did you notice that the database returned something every time we made an insert? In fact, EdgeDB gives you some information on the objects we work on every time we do an operation on them (such as <code>insert</code>), and the default output is the object's type with its <code>id</code> property, which is a <code>uuid</code>. UUID stands for <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">Universally Unique IDentifier</a>, and is used widely to make identifiers that won't be used anywhere else.</p>
<p>The output from each <code>City</code> insert looked like this:</p>
<pre><code>{default::City {id: 462b29ea-ff3d-11eb-aeb7-b3cf3ba28fb9}}
</code></pre>
<p>This output is also what shows up when you use <code>select</code> to select a type. Just typing <code>select</code> with a type name will show you all the <code>uuid</code>s for the type that are in our database. Let's look at all the cities we have so far with the following <code>select</code> query:</p>
<pre><code class="language-edgeql">select City;
</code></pre>
<p>This gives us three items:</p>
<pre><code>{
  default::City {id: 4ba1074e-ff3f-11eb-aeb7-cf15feb714ef},
  default::City {id: 4bab8188-ff3f-11eb-aeb7-f7b506bd047e},
  default::City {id: 4bacf860-ff3f-11eb-aeb7-97025b4d95af},
}
</code></pre>
<p>So far so good, but this only tells us that there are three objects of type <code>City</code> and we can't see their names. To see inside them, we need to add property or link names to the query. This is called describing the {ref}<code>shape &lt;docs:ref_eql_shapes&gt;</code> of the data we want. For the next query we will select all <code>City</code> types again, but this time we will display their <code>modern_name</code>:</p>
<pre><code class="language-edgeql">select City {
  modern_name,
};
</code></pre>
<p>Do you remember seeing that Munich doesn't have the property <code>modern_name</code>? But <code>modern_name</code> still shows up as an &quot;empty set&quot;, because every value in EdgeDB is a set of elements, even if there's nothing inside. Here is the result:</p>
<pre><code>{
  default::City {modern_name: {}},
  default::City {modern_name: 'Budapest'},
  default::City {modern_name: 'Bistri»õa'},
}
</code></pre>
<p>We know that the <code>City</code> object with <code>{}</code> for <code>modern_name</code> is Munich because we only have three objects so far, but to make the query clearer we should add <code>name</code> to the shape so that we can see that it's the city of Munich:</p>
<pre><code class="language-edgeql">select City {
  name,
  modern_name
};
</code></pre>
<p>This gives the following output:</p>
<pre><code>{
  default::City {name: 'Munich', modern_name: {}},
  default::City {name: 'Buda-Pesth', modern_name: 'Budapest'},
  default::City {name: 'Bistritz', modern_name: 'Bistri»õa'},
}
</code></pre>
<p>A <code>select</code> query doesn't have to return a full object though. If you just want to return a single property or link of an object, you can use <code>.</code> after the type name. For example, <code>select City.modern_name;</code> will return a set of strings for all of the <code>City</code> objects in the database so far. Note in the output that there is no <code>default::City</code> to be seen anywhere, because the query just returns a set of strings collected from the <code>modern_name</code> properties of every <code>City</code> object in the database.</p>
<pre><code>{'Budapest', 'Bistri»õa'}
</code></pre>
<p>This type of expression is called a <em>path expression</em> or a <em>path</em>, because it is the direct path to the values inside. And each <code>.</code> moves on to the next path, if there is another one to follow.</p>
<p>You can also change property names like <code>modern_name</code> to any other name if you want by using <code>:=</code> after the name you want. Those names you choose become the variable names that are displayed. For example:</p>
<pre><code class="language-edgeql">select City {
  name_in_dracula := .name,
  name_today := .modern_name,
};
</code></pre>
<p>This prints:</p>
<pre><code>{
  default::City {name_in_dracula: 'Munich', name_today: {}},
  default::City {name_in_dracula: 'Buda-Pesth', name_today: 'Budapest'},
  default::City {name_in_dracula: 'Bistritz', name_today: 'Bistri»õa'},
}
</code></pre>
<p>This will not change anything inside the schema - it's just a quick variable name to use in a query.</p>
<p>By the way, <code>.name</code> is short for <code>City.name</code>. You can also write <code>City.name</code> each time (that's called the <em>fully qualified name</em>), but it's not required.</p>
<p>So if you can make a quick <code>name_in_dracula</code> property from <code>.name</code>, can we make other things too? Indeed we can. For the moment we'll just keep it simple but here is one example:</p>
<pre><code class="language-edgeql">select City {
  name_in_dracula := .name,
  name_today := .modern_name,
  oh_and_by_the_way := 'A city in the book Dracula'
};
</code></pre>
<p>And here is the output:</p>
<pre><code>{
  default::City {
    name_in_dracula: 'Munich',
    name_today: {},
    oh_and_by_the_way: 'A city in the book Dracula',
  },
  default::City {
    name_in_dracula: 'Buda-Pesth',
    name_today: 'Budapest',
    oh_and_by_the_way: 'A city in the book Dracula',
  },
  default::City {
    name_in_dracula: 'Bistritz',
    name_today: 'Bistri»õa',
    oh_and_by_the_way: 'A city in the book Dracula',
  },
}
</code></pre>
<p>If you need to give a parameter the same name as a keyword (like <code>insert</code>, <code>select</code>, and so on) you can enclose it in backticks. For example, if you wanted to call a parameter <code>select</code>, you would type `select`:</p>
<pre><code class="language-edgeql">select City {
  name,
  `select` := &quot;I like the word `select`&quot;
};
</code></pre>
<p>The output is nice and clear, showing the word <code>select</code> without any backticks:</p>
<pre><code>{
  default::City {name: 'Munich', select: 'I like the word `select`'},
  default::City {name: 'Buda-Pesth', select: 'I like the word `select`'},
  default::City {name: 'Bistritz', select: 'I like the word `select`'}
}
</code></pre>
<p>This brings up an interesting discussion about type safety. EdgeDB is strongly typed, meaning that everything needs a type and EdgeDB will not try to mix different types together. So this query will not work: </p>
<pre><code class="language-edgeql">db&gt; select City {
  name_in_dracula := .name,
  name_today := .modern_name,
  oh_and_by_the_way := 'A city in the book Dracula written in the year' + 1897
 };
</code></pre>
<p>EdgeDB refuses with the following message:</p>
<pre><code>operator '+' cannot be applied to operands of type 'std::str' and 'std::int64'
</code></pre>
<p>But we didn't declare a type for <code>oh_and_by_the_way</code>, so how did EdgeDB know that it was a <code>str</code>?</p>
<p>EdgeDB uses what is known as &quot;type inference&quot; to guess the type, meaning that it can usually figure out the type itself. That is what happens here: EdgeDB knows that we are creating a <code>str</code> because we enclosed it in quotes. In other words, the type is still a concrete <code>str</code> even if we didn't specify that it was.</p>
<p>In fact, we can prove that these types are concrete right away: let's just ask EdgeDB.</p>
<pre><code class="language-edgeql">select 'Jonathan Harker' is str;
</code></pre>
<p>This returns <code>{true}</code>. Let's try another:</p>
<pre><code class="language-edgeql">select 8 is int64;
</code></pre>
<p>This returns <code>{true}</code>. Let's try one more!</p>
<pre><code class="language-edgeql">select 8 is int32;
</code></pre>
<p>This time it returns <code>{false}</code>. As you can see, EdgeDB is selecting a concrete type every time even if we don't specify a type.</p>
<p>In the next chapter we will learn how to change one type to another, but it's well past time for us to change our <code>NPC</code> type to link to <code>City</code>. Let's do that now.</p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<p>It's finally time to change our property in <code>NPC</code> called <code>places_visited</code> to a link. Right now, <code>places_visited</code> gives us the names we want, but it makes more sense to link <code>NPC</code> and <code>City</code> together. After all, the <code>City</code> type has <code>.name</code> inside it which is a <code>str</code>. If we link <code>NPC</code> to <code>City</code> then we can get the <code>City</code> objects themselves but also access their names! We'll change <code>NPC</code> to look like this:</p>
<pre><code class="language-sdl">type NPC {
  required name: str;
  multi places_visited: City;
}
</code></pre>
<p>We wrote <code>multi</code> in front of <code>places_visited</code> because one <code>NPC</code> should be able to link to more than one <code>City</code>. The opposite of <code>multi</code> is <code>single</code>, which only allows one object to link to it. But <code>single</code> is the default, so if you just write <code>places_visited: City</code> then EdgeDB will treat it as <code>single</code> link.</p>
<p>And now do a migration with <code>edgedb migration create</code> and <code>edgedb migrate</code>. The CLI questions this time are pretty easy:</p>
<pre><code>c:\easy-edgedb&gt;edgedb migration create
Connecting to an EdgeDB instance at localhost:10716...
Did you drop property 'places_visited' of object type 'default::NPC'?
[y,n,l,c,b,s,q,?]
&gt; y
Did you create link 'places_visited' of object type 'default::NPC'?
[y,n,l,c,b,s,q,?]
&gt; y
</code></pre>
<p>When we drop a property it also drops all the data for the property, so the CLI doesn't need to ask us for an expression. And adding a <code>multi</code> link just means that an <code>NPC</code> <em>can</em> link to one or more <code>City</code> types, but they don't have to.</p>
<p>It's finally time to insert our <code>NPC</code> Jonathan Harker, and this time he can be connected to one or more <code>City</code> objects. Don't forget that <code>places_visited</code> is not <code>required</code>, so we could do an <code>insert</code> with just his name to create him. It would look like this:</p>
<pre><code class="language-edgeql">insert NPC {
  name := 'Jonathan Harker',
};
</code></pre>
<p>If we were to do that, it would only create an <code>NPC</code> type connected to the <code>City</code> type but with nothing in it. And if we did a query on the <code>NPC</code> type as follows:</p>
<pre><code class="language-edgeql">select NPC {
  name,
  places_visited
};
</code></pre>
<p>Then the output wouldn't show any links to any <code>City</code> objects:</p>
<pre><code>{default::NPC {name: 'Jonathan Harker', places_visited: {}}}
</code></pre>
<p>But we want to have Jonathan be connected to the cities he has traveled to. So instead of just giving him a <code>name</code>, we'll also give him a <code>places_visited</code> multi link when we <code>insert</code> by writing <code>places_visited := City</code>:</p>
<pre><code class="language-edgeql">insert NPC {
  name := 'Jonathan Harker',
  places_visited := City,
};
</code></pre>
<p>Now let's see the places that Jonathan has visited. The query below is almost but not quite what we need:</p>
<pre><code class="language-edgeql">select NPC {
  name,
  places_visited
};
</code></pre>
<p>Here is the output:</p>
<pre><code>{
  default::NPC {
    name: 'Jonathan Harker',
    places_visited: {
      default::City {id: 4ba1074e-ff3f-11eb-aeb7-cf15feb714ef},
      default::City {id: 4bab8188-ff3f-11eb-aeb7-f7b506bd047e},
      default::City {id: 4bacf860-ff3f-11eb-aeb7-97025b4d95af},
    },
  },
}
</code></pre>
<p>Close! But we didn't mention any properties inside <code>City</code> so we just got the object id numbers. Now we just need to let EdgeDB know that we want to see the <code>name</code> property of the <code>City</code> type as well. To do that, add a colon and then put <code>name</code> inside curly brackets.</p>
<pre><code class="language-edgeql">select NPC {
  name,
  places_visited: {
    name
  }
};
</code></pre>
<p>Success! Now we get the output we wanted:</p>
<pre><code>{
  default::NPC {
    name: 'Jonathan Harker',
    places_visited: {
      default::City {name: 'Munich'},
      default::City {name: 'Buda-Pesth'},
      default::City {name: 'Bistritz'},
    },
  },
}
</code></pre>
<p>Interestingly, Jonathan Harker has been inserted with a link to every city in the database. In other words, <code>places_visited := City</code> means <code>places_visited := every City type in the database</code>. Right now we only have three <code>City</code> objects and one <code>NPC</code> object, and Jonathan Harker has visited them all. No problem so far. But later on we will have more cities and won't be able to just write <code>places_visited := City</code> for all the other characters. For that we will need the <code>filter</code> keyword, which we will learn to use in the next chapter.</p>
<p>Note that if you inserted &quot;Jonathan Harker&quot; multiple times (or any other <code>NPC</code> objects with the same name), you will now have multiple <code>NPC</code> objects with that name. The database doesn't give an error for this, because we haven't instructed it to keep an eye out for duplicates. In <a href="chapter1/../chapter7/index.html">Chapter 7</a> we will learn how to make sure the database doesn't allow multiple copies of <code>NPC</code> with the same name.</p>
<p>Remember how we saw that &quot;each <code>.</code> in a path expression moves on to the next path, if there is another one to follow&quot;? We can demonstrate that now that <code>NPC</code> links to <code>City</code>. The query below uses <code>.</code> two times. What do you think it will return?</p>
<pre><code class="language-edgeql">select NPC.places_visited.modern_name;
</code></pre>
<p>Exactly, it will return a set of strings:</p>
<pre><code>{'Budapest', 'Bistri»õa'}
</code></pre>
<p>In other words, it is a query that first follows the <code>places_visited</code> link inside <code>NPC</code>, which takes us to the three <code>City</code> objects, and then proceeds to their <code>modern_name</code> property which is a <code>str</code>. Two out of the three have a <code>modern_name</code> so the result is a set of two strings. You can use <code>.</code> as many times as you like as long as there is still a path to follow!</p>
<p><a href="chapter1/code.html">Here is all our code so far up to Chapter 1.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice"><a class="header" href="#time-to-practice">Time to practice</a></h2>
<ol>
<li>
<p>Entering the code below returns an error. Try adding one character to make it return <code>{true}</code>.</p>
<pre><code class="language-edgeql">with my_name = 'Timothy',
select my_name != 'Benjamin';
</code></pre>
</li>
<li>
<p>Try inserting a <code>City</code> called Constantinople, but now known as ƒ∞stanbul.</p>
</li>
<li>
<p>Try displaying all the names of the cities in the database. (Hint: you can do it in a single line of code and won't need <code>{}</code> to do it)</p>
</li>
<li>
<p>Try selecting all the <code>City</code> types along with their <code>name</code> and <code>modern_name</code> properties, but change <code>.name</code> to say <code>old_name</code> and change <code>modern_name</code> to say <code>name_now</code>.</p>
</li>
<li>
<p>Will typing <code>SelecT City;</code> produce an error?</p>
</li>
</ol>
<p><a href="chapter1/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>Jonathan Harker arrives in Romania.</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>tags: Scalar Types, Abstract Types, Filtering, Slicing
leadImage: illustration_02.jpg</h2>
<h1 id="chapter-2---at-the-hotel-in-bistritz"><a class="header" href="#chapter-2---at-the-hotel-in-bistritz">Chapter 2 - At the Hotel in Bistritz</a></h1>
<p>We continue to read the story as we think about the database we need to store the information. The important information is in bold:</p>
<blockquote>
<p>Jonathan Harker has found a hotel in <strong>Bistritz</strong>, called the <strong>Golden Krone Hotel</strong>. He gets a welcome letter there from Dracula, who is waiting in his <strong>castle</strong>. Jonathan Harker will have to take a horse-driven carriage to get there tomorrow. Jonathan Harker is originally from <strong>London</strong>. The innkeeper at the Golden Krone Hotel seems very afraid of Dracula. He doesn't want Jonathan to leave and says it will be dangerous, but Jonathan doesn't listen. An old lady gives Jonathan a golden crucifix and says that it will protect him. Jonathan is embarrassed, and takes it to be polite. Jonathan has no idea how much it will help him later.</p>
</blockquote>
<p>Now we are starting to see some detail about the city of Bistritz: it contains a hotel. To represent this, we could add another property to <code>City</code>, and call it <code>important_places</code>. That's where places like the <strong>Golden Krone Hotel</strong> could go. We're not sure if places will be their own object types yet, so we'll just make it an array of strings for now: <code>important_places: array&lt;str&gt;;</code> We can put the names of important places in there for the time being and develop it into a link later. It will now look like this:</p>
<pre><code class="language-sdl">type City {
  required name: str;
  modern_name: str;
  important_places: array&lt;str&gt;;
}
</code></pre>
<p>After doing a migration, let's insert Bistritz with the <code>important_places</code> property:</p>
<pre><code class="language-edgeql">insert City {
  name := 'Bistritz',
  modern_name := 'Bistri»õa',
  important_places := ['Golden Krone Hotel'],
};
</code></pre>
<p>After this insert, our database will have two cities called Bistritz. It would be nice to delete one of them but first we will need to learn the <code>filter</code> and <code>delete</code> keywords to do so. We will learn <code>filter</code> in this chapter, and <code>delete</code> in the next, and then we will delete our duplicate Bistritz.</p>
<h2 id="enums-scalar-types-and-extending"><a class="header" href="#enums-scalar-types-and-extending">Enums, scalar types, and extending</a></h2>
<p>Our game is going to need to have player characters in it, which means that users of the game are going to have to choose what type of character they want to be. The book is <a href="https://vampvault.jimdofree.com/tidbits/timeframe/">probably based in 1893</a>, and our game will let the characters use classes that make sense for this time period. That means that we will need some sort of type that allows us to select from a number of options. EdgeDB has a type called an <code>enum</code> that will let us do this.</p>
<p>Simple types like <code>int64</code> are what are known as <code>scalar types</code>, which means that they only hold a single value at a time. An enum allows us to select from multiple options, but it is a scalar type too because you can only pick one. The other types (<code>City</code>, <code>NPC</code>) are <code>object types</code> because they can hold multiple values at the same time.</p>
<p>The other keyword we will see for the first time is <code>extending</code>, which means to take a type as a base and extend it. This keyword gives you all the power of the type that you are extending, and lets you add more on top. Enums in EdgeDB are created by <code>extending</code> a base enum type with the list of values (choices) we want to choose from. The syntax looks like this:</p>
<pre><code class="language-sdl">scalar type Class extending enum&lt;Rogue, Mystic, Merchant&gt;;
</code></pre>
<p>Feel free to add more classes if you want! But in our schema we will just have three classes for simplicity.</p>
<p>Did you notice that <code>scalar type</code> ends with a semicolon and the other types don't? That's because the object types have a <code>{}</code> to make a full expression. But here on a single line we don't have <code>{}</code> so we need the semicolon to show that the expression ends here.</p>
<p>To choose between the values in an enum, you just use a <code>.</code> (a dot). For our enum, that means we can choose <code>Class.Rogue</code>, <code>Class.Mystic</code>, or <code>Class.Merchant</code>.</p>
<p>This <code>Class</code> type is going to be for player characters in our game, not the <code>NPC</code> objects from the book (their stories, choices and statistics are already decided). That means that we will need both an <code>PC</code> type and an <code>NPC</code> type. These two types need to be different, but they are pretty similar to each other! They both have a <code>name</code>, <code>places_visited</code>, and probably some other properties that we will add later. This is a good case for a base type. Inside this base type we can put all the properties that are common to <code>PC</code> and <code>NPC</code>, which will use the <code>extending</code> keyword to gain the properties that <code>Person</code> has.</p>
<p>This part of the schema will look like this...except for one change we will make.</p>
<pre><code class="language-sdl">type Person {
  required name: str;
  multi places_visited: City;
}

type PC extending Person {
  required class: Class;
}

type NPC extending Person;
</code></pre>
<p>So what change should we make? Well, the <code>Person</code> type at the moment is a concrete type, which means that we would be able to insert <code>Person</code> objects, <code>PC</code> objects, and <code>NPC</code> objects. But we only want to use <code>Person</code> as a base for other types to extend from, not a concrete type that we can insert. So in this case we will change <code>type Person</code> to <code>abstract type Person</code>.</p>
<p>With that change done, the schema now looks like this. Let's do a migration now.</p>
<pre><code class="language-sdl">abstract type Person {
  required name: str;
  multi places_visited: City;
}

type PC extending Person {
  required class: Class;
}

type NPC extending Person;
</code></pre>
<p>Because <code>Person</code> is an abstract type, we can't insert it directly. Let's try it though and see what the error is! Give this query a try:</p>
<pre><code class="language-edleql">insert Person {name := 'Mr. HasAName'};
</code></pre>
<p>As expected, we can't insert this <code>Person</code> type because it is abstract.</p>
<pre><code>error: QueryError: cannot insert into abstract object type 'default::Person'
  ‚îå‚îÄ &lt;query&gt;:1:8
  ‚îÇ
1 ‚îÇ insert Person {name := 'Mr. HasAName'};
  ‚îÇ        ^^^^^^ error
</code></pre>
<p>However, <code>select</code> on an abstract type is just fine. A <code>select</code> on a <code>Person</code> type will select all of the objects of all the types that extend <code>Person</code>. So let's add a <code>PC</code> object now so that the result of a <code>select Person</code> query will be more interesting.</p>
<p>We'll make a <code>PC</code> called Emil Sinclair who is a mystic. He hasn't visited anywhere yet so he won't have any <code>places_visited</code> to link to.</p>
<pre><code class="language-edgeql">insert PC {
  name := 'Emil Sinclair',
  class := Class.Mystic,
};
</code></pre>
<p>Note that we didn't just write <code>Mystic</code>, because we have to choose the enum <code>Class</code> and then make a choice of one of the values. Just typing <code>Mystic</code> would make EdgeDB think that we were trying to link to objects of a type called <code>Mystic</code>.</p>
<p>However, EdgeDB also allows you to choose an enum just by writing a string that matches the value. So this insert would have worked too:</p>
<pre><code class="language-edgeql">insert PC {
  name := 'Emil Sinclair',
  class := 'Mystic',
};
</code></pre>
<p>But if you were to type something like <code>class := 'Wrestler'</code> it wouldn't work, because <code>Wrestler</code> is not one of the values inside the <code>Class</code> enum.</p>
<pre><code>edgedb error: InvalidValueError: invalid input value for enum 
'default::Class': &quot;Wrestler&quot;
</code></pre>
<p>Now let's do a select on the abstract type <code>Person</code> to see the objects inside, plus the properties common to both: <code>name</code> and <code>places_visited</code>.</p>
<pre><code class="language-edgeql">select Person {
  name,
  places_visited: {
    name
  }
};
</code></pre>
<p>This gives us an output showing objects of both the <code>PC</code> and <code>NPC</code> type.</p>
<pre><code>{
  default::NPC {
    name: 'Jonathan Harker',
    places_visited: {
      default::City {name: 'Munich'},
      default::City {name: 'Buda-Pesth'},
      default::City {name: 'Bistritz'},
    },
  },
  default::PC {name: 'Emil Sinclair', places_visited: {}},
}
</code></pre>
<h2 id="casting"><a class="header" href="#casting">Casting</a></h2>
<p>Casting means to quickly change one type into another. Casting is used a lot in EdgeDB because it is strict about types, and will refuse to do operations on two types that are different. A lot of casting is done automatically out of convenience, such as with numbers. Take this query for example:</p>
<pre><code class="language-edgeql">select 9 + 9.9;
</code></pre>
<p>The 9 in the query is an <code>int64</code>, while 9.9 is a <code>float64</code>. And though 9 and 9.9 are different types, EdgeDB will not generate an error here and will just give the output of <code>18.9</code>, returning a <code>float64</code>. You can confirm that here:</p>
<pre><code class="language-edgeql">select (9 + 9.9) is float64;
</code></pre>
<p>This will give <code>true</code>, while <code>select (9 + 9.9) is float32;</code> gives <code>false</code>.</p>
<p>When a cast is done without you needing to type anything extra, it is known as an <em>implicit cast</em>.</p>
<p>When you need to do the cast yourself, it is called an <em>explicit cast</em>. In this case you can indicate the type using <code>&lt;&gt;</code> angle brackets. For example, this will generate an error:</p>
<pre><code class="language-edgeql">select '9' + 9;
</code></pre>
<p>EdgeDB tells us the exact problem here:</p>
<pre><code>error: InvalidTypeError: operator '+' cannot be applied to operands of type
'std::str' and 'std::int64'
  ‚îå‚îÄ &lt;query&gt;:1:8
  ‚îÇ
1 ‚îÇ select '9' + 9;
  ‚îÇ        ^^^^^^^ Consider using an explicit type cast or a conversion function.
</code></pre>
<p>And to fix it, just use the angle brackets:</p>
<pre><code class="language-edgeql">select &lt;int64&gt;'9' + 9;
</code></pre>
<p>And you will get <code>18</code>, a 64-bit integer.</p>
<p>But don't worry, a cast won't work if the input is invalid. You can't just cast a bunch of letters into an <code>&lt;int64&gt;</code> for example:</p>
<pre><code>db&gt; select &lt;int64&gt;&quot;Hi I'm a number please add me to&quot; + 9;
edgedb error: InvalidValueError: invalid input syntax for type std::int64:
&quot;Hi I'm a number please add me to&quot;
</code></pre>
<p>You can cast more than once at a time if you need to. This example isn't something you will need to do but shows how you can cast over and over again if you want:</p>
<pre><code class="language-edgeql">select &lt;str&gt;&lt;int64&gt;&lt;str&gt;&lt;int32&gt;50 is str;
</code></pre>
<p>Did you notice that the output for this query is <code>{true}</code>? That's because casting works from right to left, with the final cast on the far left. You can follow the casts by reading from right to left using the word &quot;into&quot;:</p>
<ul>
<li>&quot;The number 50 into an int32 into a string into an int64 into a string&quot;.</li>
</ul>
<p>Or you can read it from left to right using the word &quot;from&quot;:</p>
<ul>
<li>&quot;A string from an int64 from a string from an int32 from the number 50&quot;.</li>
</ul>
<p>Also note that casting is almost always only for scalar types: user-created object types like <code>City</code> and <code>Person</code> are too complex to simply cast into.</p>
<p>There is one exception to this as of EdgeDB 3.0: a <code>uuid</code> can be cast into an object type. This makes sense because each object in EdgeDB has a unique id, and why not be able to cast from this <code>uuid</code> into the object it belongs to?</p>
<p>Let's give this a try by first picking any <code>id</code> from our <code>Person</code> type with <code>select Person.id;</code>. Found one? Good, now paste that into the REPL, surround it with quotes to make it a <code>str</code>, and then use <code>&lt;uuid&gt;</code> to cast it. Like this:</p>
<pre><code>select &lt;uuid&gt;'82348556-1928-11ee-ab8c-efed3acb0f00';
</code></pre>
<p>Good! And now let's see if we can cast from a <code>uuid</code> into a <code>City</code>. Use <code>select City.id;</code>, pick an id from the list, and then try casting it into a <code>City</code>. Let's also display its <code>name</code> and <code>important_places</code> property while we are at it.</p>
<p>The query below almost works, but will generate an error. Can you guess why?</p>
<pre><code class="language-edgedb">select &lt;City&gt;&lt;uuid&gt;'6b62fbc6-1975-11ee-9693-cff543bb8205' {
  name, 
  important_places 
  };
</code></pre>
<p>Ah yes, there it is:</p>
<pre><code>error: QueryError: shapes cannot be applied to scalar type 'std::str'
  ‚îå‚îÄ &lt;query&gt;:1:20
  ‚îÇ
1 ‚îÇ   select &lt;City&gt;&lt;uuid&gt;'6b62fbc6-1975-11ee-9693-cff543bb8205' {
  ‚îÇ ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ^
2 ‚îÇ ‚îÇ   name,
3 ‚îÇ ‚îÇ   important_places
4 ‚îÇ ‚îÇ };
  ‚îÇ ‚ï∞‚îÄ^ error
</code></pre>
<p>We told EdgeDB to give a shape to <code>str</code> which obviously doesn't have properties like <code>name</code> and <code>important_places</code>. No problem: just wrap everything in parentheses first.</p>
<pre><code class="language-edgedb">select (&lt;City&gt;&lt;uuid&gt;'6b62fbc6-1975-11ee-9693-cff543bb8205') {
  name, 
  important_places 
  };
</code></pre>
<p>With the parentheses, the query can be seen as this: &quot;Take a string, try to cast it into a uuid, and try to cast it into a City. Take this result and display its <code>name</code> and <code>important_places</code> properties. The query will now work, and display one of the cities we added. It should look something like this.</p>
<pre><code>{default::City {name: 'Munich', important_places: {}}}
</code></pre>
<h2 id="filtering-like-and-ilike-and-indexing"><a class="header" href="#filtering-like-and-ilike-and-indexing">Filtering, like and ilike, and indexing</a></h2>
<p>To finish up the second chapter, let's learn how to <code>filter</code>. You can use <code>filter</code> after the curly brackets in <code>select</code> to only show certain objects instead of showing every object for a type. Let's <code>filter</code> to only show <code>Person</code> types that have the property <code>name</code> that equals 'Emil Sinclair':</p>
<pre><code class="language-edgeql">select Person {
  name,
  places_visited: {name},
} filter .name = 'Emil Sinclair';
</code></pre>
<p><code>filter .name</code> is short for <code>filter Person.name</code>. You can write <code>filter Person.name</code> too if you want - it's the same thing.</p>
<p>The output now only shows a single <code>PC</code> object with a name that matches our filter:</p>
<pre><code>{default::PC {name: 'Emil Sinclair', places_visited: {}}}
</code></pre>
<p>Let's filter the cities now. EdgeDB has two keywords called <code>like</code> or <code>ilike</code> which allow us to to match on parts of a string instead of just a whole string. They are slightly different:</p>
<ul>
<li><code>like</code> is case sensitive, so &quot;Bistritz&quot; matches &quot;Bistritz&quot; but &quot;bistritz&quot; does not match &quot;Bistritz&quot;.</li>
<li><code>ilike</code> is not case sensitive (the i in ilike means <strong>insensitive</strong>), so &quot;Bistritz&quot; matches both &quot;BiStRitz&quot; and &quot;bisTRITz&quot;.</li>
</ul>
<p>You can also add <code>%</code> on the left and/or right which means match anything before or after. Here are some examples with the matched part <strong>in bold</strong>:</p>
<ul>
<li><code>like Bistr%</code> matches &quot;<strong>Bistr</strong>itz&quot;, but not &quot;bistritz&quot;.</li>
<li><code>ilike '%IsTRiT%'</code> matches &quot;B<strong>istrit</strong>z&quot;.</li>
<li><code>like %athan Harker</code> matches &quot;Jon<strong>athan Harker</strong>&quot;.</li>
<li><code>ilike %n h%</code> matches &quot;Jonatha<strong>n H</strong>arker&quot;.</li>
</ul>
<p>Let's <code>filter</code> to get all the cities that start with a capital B. That means we'll need <code>like</code> because it needs to be case sensitive:</p>
<pre><code class="language-edgeql">select City {
  name,
  modern_name,
} filter .name like 'B%';
</code></pre>
<p>Here is the result:</p>
<pre><code>{
  default::City {name: 'Buda-Pesth', modern_name: 'Budapest'},
  default::City {name: 'Bistritz', modern_name: 'Bistri»õa'},
}
</code></pre>
<p>You can also index a string with <code>[]</code> square brackets, starting at 0. For example, the indexes in the string 'Jonathan' look like this:</p>
<pre><code>J o n a t h a n
0 1 2 3 4 5 6 7
</code></pre>
<p>So <code>'Jonathan'[0]</code> is 'J' and <code>'Jonathan'[4]</code> is 't'.</p>
<p>We can then use this method to filter too. In the next query we are checking to see if the first character is a 'B' or not:</p>
<pre><code class="language-edgeql">select City {
  name,
  modern_name,
} filter .name[0] = 'B'; # First character must be 'B'
</code></pre>
<p>That gives the same result. Careful though: if you set the number too high then it will try to search outside of the string, which is an error. If we change 0 to 18 (<code>filter .name[18] = 'B';</code>), we'll get this error:</p>
<pre><code>edgedb error: InvalidValueError: string index 18 is out of bounds
(on line 4, column 16)
</code></pre>
<p>Plus, if you have any <code>City</code> types with a name of <code>''</code>, even a search for index 0 will cause an error.</p>
<p>Let's try to make that error happen.</p>
<p>First we will insert a <code>City</code> object with '' for a name:</p>
<pre><code>db&gt; insert City {
 name := ''
 };
{default::City {id: 5d01e634-f2c7-11ed-87af-d7dfced50628}}
</code></pre>
<p>And now our former query doesn't work, because EdgeDB will come across a <code>City</code> object with a <code>name</code> property that it can't index into.</p>
<pre><code>db&gt; select City {
  name,
  modern_name,
 } filter .name[0] = 'B';
edgedb error: InvalidValueError: string index 0 is out of bounds
(on line 4, column 16)
</code></pre>
<p>So a good rule of thumb is to not use raw indexes when filtering unless you are sure that there will be a value, and that the value will be long enough. In the next chapter we will learn how to use <em>constraints</em> to ensure that your data matches certain expectations you have, such as minimum length.</p>
<p>So what if you want to make sure that you won't get an error with an index number that might be too high? Here you can use <code>like</code> or <code>ilike</code> instead. If you replace the <code>.name[0]</code> part in the query above with <code>.name ilike 'B%'</code> we don't get an error, and the query still checks to see if there is a 'B' at index 0.</p>
<pre><code class="language-edgeql">db&gt; select City {
  name,
  modern_name,
 } filter .name ilike 'B%';
</code></pre>
<p>The result is now all <code>City</code> objects that start with 'B', and the <code>City</code> object with a <code>name</code> of <code>''</code> is no longer getting in the way.</p>
<pre><code> {
  default::City {name: 'Buda-Pesth', modern_name: 'Budapest'},
  default::City {name: 'Bistritz', modern_name: 'Bistri»õa'},
}
</code></pre>
<h2 id="slicing"><a class="header" href="#slicing">Slicing</a></h2>
<p>You can also slice a string to get a piece of it. Let's look at the index values for 'Jonathan' again and think about how we could slice it.</p>
<pre><code>J o n a t h a n
0 1 2 3 4 5 6 7
</code></pre>
<p>Slices represent a part of a string that starts at one index and ends <em>before</em> another one. In other words, if you take a &quot;slice&quot; of it between indexes 2 and 5, you get 'nat' (<code>'Jonathan'[2:5]</code> = 'nat'), because it starts at 2 and goes <em>up to</em> 5 - but not including index 5. It's sort of like when you phone your friends to tell them that you're 'at their house': you're not telling them that you're inside it. So <code>[2:5]</code> represents a slice that starts at index 2 and is &quot;at&quot; (in front of) index 5.</p>
<p>In the same way, selecting a slice of 'Jonathan' up to index 7 will show up to and including index 6:</p>
<pre><code>db&gt; select 'Jonathan'[0:7];
{'Jonatha'}
</code></pre>
<p>In this case, you could search up to index 8. You could even search up to index 1000, as slicing doesn't involve trying to directly access an index so it won't generate an error if there is no value at that index. Or you can use <code>[0:]</code> for an open-ended slice that starts at 0 and ends when the string ends. So all three of these queries will work without generating an error:</p>
<pre><code>db&gt; select 'Jonathan'[0:8];
{'Jonathan'}
db&gt; select 'Jonathan'[0:1000];
{'Jonathan'}
db&gt; select 'Jonathan'[0:];
{'Jonathan'}
</code></pre>
<p>This also means that you can use slicing to safely search for values at a certain index even if the value might be an empty string. We still have that <code>City</code> object in the database with a <code>name</code> of <code>''</code>, so <code>select City.name[0]</code> generates an error:</p>
<pre><code>db&gt; select City.name[0];
edgedb error: InvalidValueError: string index 0 is out of bounds
(on line 1, column 18)
</code></pre>
<p>However, if we change the query to <code>db&gt; select City.name[0:1];</code> then it will look for a slice instead of an exact character index, and the query will work:</p>
<pre><code>db&gt; select City.name[0:1];
{'M', 'B', 'B', ''}
</code></pre>
<p>You can also use negative numbers to slice from the other end of a string. Negative index values are counted from the end of 'Jonathan', which is 8, so -1 corresponds to <code>8 - 1</code>: index number 7. Let's prove this with a query:</p>
<pre><code>db&gt; select 'Jonathan'[7] = 'Jonathan'[-1];
{true}
</code></pre>
<p>And this query will show all the characters in the string 'Jonathan' starting from index 1 and going up to the second last index:</p>
<pre><code>db&gt; select 'Jonathan'[1:-1];
{'onatha'}
</code></pre>
<p>Let's end the chapter with a quick note. Did you notice one of the queries used <code>#</code> to add a comment? Comments in EdgeDB are simple: anything to the right of <code>#</code> on a line gets ignored.</p>
<p>So this:</p>
<pre><code class="language-edgeql">select 1893#0503 is the first day of the book Dracula when...
;
</code></pre>
<p>returns <code>{1893}</code>.</p>
<p><a href="chapter2/code.html">Here is all our code so far up to Chapter 2.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice-1"><a class="header" href="#time-to-practice-1">Time to practice</a></h2>
<ol>
<li>
<p>Change the following <code>select</code> to display <code>{100}</code> by casting: <code>select '99' + '1'</code>;</p>
</li>
<li>
<p>Select all the <code>City</code> types that start with 'Mu' (case sensitive).</p>
</li>
<li>
<p>Select the third letter (i.e. index number 2) of the name of every <code>NPC</code>.</p>
</li>
<li>
<p>If some <code>NPC</code> objects might have a name of <code>''</code>, how would you find the third letter of the name of every <code>NPC</code>?</p>
</li>
<li>
<p>Imagine an abstract type called <code>HasAString</code>:</p>
<pre><code class="language-sdl">abstract type HasAString {
  string: str
};
</code></pre>
<p>How would you change the <code>Person</code> type to extend <code>HasAString</code>?</p>
</li>
<li>
<p>This query only shows the id numbers of the places visited. How do you show their name?</p>
<pre><code class="language-edgeql">select Person {
  places_visited
};
</code></pre>
</li>
</ol>
<p><a href="chapter2/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>Jonathan gets into the carriage and travels into the cold mountains.</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>tags: Constraints, Deleting
leadImage: illustration_03.jpg</h2>
<h1 id="chapter-3---jonathan-goes-to-castle-dracula"><a class="header" href="#chapter-3---jonathan-goes-to-castle-dracula">Chapter 3 - Jonathan goes to Castle Dracula</a></h1>
<p>In this chapter we encounter a vampire for the first time - or rather, <em>the</em> vampire. As you can see, Dracula seems human but is actually quite different:</p>
<blockquote>
<p>Jonathan Harker has just arrived at Castle Dracula after a ride in the carriage through the mountains. The ride was terrible. There was snow, strange blue fires, and wolves everywhere. It was <strong>night</strong> when he arrived. He meets with Count Dracula. Dracula picks up all of Jonathan's luggage <strong>with one hand</strong>, they go inside, and they talk all night. Dracula always leaves <strong>just before the sun rises</strong> though. Curious! Days go by, and Jonathan still doesn't know that Dracula is a vampire. But he does notice something strange: the castle seems completely empty. If Dracula is so rich, where are his servants? Why is he so strong? Who is making his meals that he finds on the table? But Jonathan finds Dracula's stories of history very interesting, and so far is enjoying his trip.</p>
</blockquote>
<p>Now we are completely inside Dracula's castle, so this is a good time to create a <code>Vampire</code> type. We can extend it from <code>abstract type Person</code> because that type has <code>name</code> and <code>places_visited</code>, which are good for <code>Vampire</code> too.</p>
<p>One possibility is adding <code>age</code> to <code>Person</code> so that all the other types can use it too. Then `Person' would look like this:</p>
<pre><code class="language-sdl">abstract type Person {
  required name: str;
  multi places_visited: City;
  age: int16;
}
</code></pre>
<p><code>int16</code> means a 16 bit (2 byte) integer, which has enough space for -32768 to +32767. That's enough for age, so we don't need the bigger <code>int32</code> or <code>int64</code> types which are much larger. We also don't want it to be a <code>required</code> property, because we don't care about everybody's age.</p>
<p>But we don't want <code>PC</code>s and <code>NPC</code>s to live up to 32767 years, so let's remove <code>age</code> from the abstract <code>Person</code> type and give it only to <code>Vampire</code> for now. We will think about the other types later. We'll make <code>Vampire</code> a type that extends <code>Person</code>, and adds age:</p>
<pre><code class="language-sdl">type Vampire extending Person {
  age: int16;
}
</code></pre>
<p>Now we can create Count Dracula. We know that he lives in Romania, but Romania isn't a city. This is a good time to change the <code>City</code> type. We'll change the name to <code>Place</code> and make it an <code>abstract type</code>, and then <code>City</code> can extend from it. We'll also add a <code>Country</code> type that does the same thing. Now they look like this:</p>
<pre><code class="language-sdl">abstract type Place {
  required name: str;
  modern_name: str;
  important_places: array&lt;str&gt;;
}

type City extending Place;

type Country extending Place;
</code></pre>
<p>We will also need to change <code>places_visited</code> in <code>Person</code> from <code>City</code> to <code>Place</code> so that it can include many things: the <code>City</code> types London and Bistritz, the <code>Country</code> type Hungary, and any other types we decide to add later that will extend <code>Place</code>.</p>
<pre><code class="language-sdl">abstract type Person {
  required name: str;
  multi places_visited: Place;
}
</code></pre>
<p>With these changes done, let's do a migration!</p>
<p>It's easy to make a <code>Country</code>, because its only required property is <code>name</code>. We'll quickly insert two <code>Country</code> objects for Hungary and Romania:</p>
<pre><code class="language-edgeql">insert Country { name := 'Hungary' };
insert Country { name := 'Romania' };
</code></pre>
<h2 id="capturing-a-select-expression"><a class="header" href="#capturing-a-select-expression">Capturing a select expression</a></h2>
<p>With these countries added, we are now ready to insert Dracula.</p>
<p>We only know that Dracula has been in Romania, so his <code>places_visited</code> will be pretty easy: just select all the <code>Place</code> types and filter on <code>.name = 'Romania'</code>. When doing this, we put the <code>select</code> inside <code>()</code> brackets (parentheses). The parentheses are used to capture the result of the <code>select</code> query. In other words, the parentheses delimit (set the boundaries for) the <code>select</code> query which is then assigned to <code>places_visited</code>.</p>
<pre><code class="language-edgeql">insert Vampire {
  name := 'Count Dracula',
  places_visited := (select Place filter .name = 'Romania'),
  # .places_visited is the result of this select query.
};
</code></pre>
<p>The insert works, with a result that looks something like this: <code>{default::Vampire {id: 7f5b25ac-ff43-11eb-af59-3f8e155c6686}}</code>.</p>
<p>Let's check if <code>places_visited</code> worked. We only have one <code>Vampire</code> object now, so let's <code>select</code> it:</p>
<pre><code class="language-edgeql">select Vampire {
  places_visited: {
    name
  }
};
</code></pre>
<p>This query gives us the following:</p>
<pre><code>{default::Vampire {places_visited: {default::Country {name: 'Romania'}}}}
</code></pre>
<p>Perfect!</p>
<h2 id="adding-constraints"><a class="header" href="#adding-constraints">Adding constraints</a></h2>
<p>Now let's think about <code>age</code> again. It was easy to add <code>age</code> to the <code>Vampire</code> type, because they can live forever. But now we want to give <code>age</code> to <code>PC</code> and <code>NPC</code> too, who are humans who don't live forever (we don't want them living up to 32767 years). For this we can add a &quot;constraint&quot; (a limit). Instead of <code>age</code>, we'll give them a new scalar type called <code>HumanAge</code>. Then we can write <code>constraint</code> on it and use {ref}<code>one of the functions &lt;docs:ref_datamodel_constraints&gt;</code> that it can take. We will use the one called  <code>max_value()</code>.</p>
<p>Here's the signature for <code>max_value()</code>:</p>
<p><code>std::max_value(max: anytype)</code></p>
<p>The <code>anytype</code> part of the signature is interesting, because that means that the constraint can work on other types like strings too. With a constraint <code>max_value('B')</code> for example you couldn't use 'C', 'D', etc.</p>
<p>Now let's go back to our constraint for <code>HumanAge</code>, which is 120. The <code>HumanAge</code> type looks like this:</p>
<pre><code class="language-sdl">scalar type HumanAge extending int16 {
  constraint max_value(120);
}
</code></pre>
<p>Remember, it's a scalar type because it can only have one value. Then we'll add it to the <code>NPC</code> type.</p>
<pre><code class="language-sdl">type NPC extending Person {
  age: HumanAge;
}
</code></pre>
<p>This <code>HumanAge</code> scalar is our own type with its own name, but underneath it's an <code>int16</code> that can't be greater than 120. So let's do a migration now and try to add an <code>NPC</code> that is 130 years old. This <code>insert</code> should not work:</p>
<pre><code class="language-edgeql">insert NPC {
  name := 'The innkeeper',
  age := 130
};
</code></pre>
<p>As expected, we are not allowed and an error shows up. Perfect.</p>
<pre><code>edgedb error: ConstraintViolationError: Maximum allowed value for HumanAge is 120.
 Detail: Maximum allowed value for value of scalar type 'default::HumanAge' is 120.
</code></pre>
<p>Now let's insert the same innkeeper but give him an <code>age</code> of 30. This will now work: <code>{default::NPC {id: e7c4dd96-f2d4-11ed-a0c7-17fe2be02578}}</code>. Our <code>NPC</code> objects are now guaranteed to be no more than 120 years old.</p>
<h2 id="deleting-objects"><a class="header" href="#deleting-objects">Deleting objects</a></h2>
<p>Deleting in EdgeDB is very easy: just use the <code>delete</code> keyword. The <code>delete</code> keyword is similar to <code>select</code> in that it will apply to all types unless you <code>filter</code> them. This similarity to <code>select</code> might make you nervous, because if you type something like <code>select City;</code> then it will select all of them. Using <code>delete</code> is the same: <code>delete City;</code> deletes every object for the <code>City</code> type. That's why you should think carefully before deleting anything.</p>
<p>However, sometimes you may be prevented from deleting an object. Remember our two <code>Country</code> objects for Hungary and Romania? Let's try deleting them all. Interestingly, it won't work:</p>
<pre><code class="language-edgeql">delete Country;
</code></pre>
<p>We got an error telling us that deleting a <code>Country</code> is not possible because it is still referenced by <code>places_visited</code> of a <code>Person</code>.</p>
<pre><code>edgedb error: ConstraintViolationError: deletion of default::Country
(e9e8acda-f2d2-11ed-86e2-4bed5b30457e) is prohibited by link target policy
Detail: Object is still referenced in link places_visited of 
default::Person (ce8146ea-f2d3-11ed-92a8-237b79022c26).
</code></pre>
<p>That's Count Dracula who visited Romania getting in the way. Let's delete him first then:</p>
<pre><code class="language-edgeql">delete Vampire;
</code></pre>
<p>Just like <code>insert</code>, using <code>delete</code> gives us the id numbers of the objects that are now deleted: <code>{default::Vampire {id: 7f5b25ac-ff43-11eb-af59-3f8e155c6686}}</code>.</p>
<p>Now we can try deleting all of the <code>Country</code> objects. Count Dracula is no longer in our way so the query will work:</p>
<pre><code class="language-edgeql">delete Country;
</code></pre>
<p>We got confirmation that two <code>Country</code> objects have been deleted:</p>
<pre><code>{
  default::Country {id: e988e476-f2d2-11ed-86e2-e34ef4a919b9},
  default::Country {id: e9e8acda-f2d2-11ed-86e2-4bed5b30457e},
}
</code></pre>
<p>Okay, let's insert both countries again so that we can delete them once more. This time we will try deleting them with a filter. First let's try deleting every <code>Country</code> object that has a name with &quot;States&quot; somewhere inside it. <code>ilike</code> will let us do that:</p>
<pre><code class="language-edgeql">delete Country filter .name ilike '%States%';
</code></pre>
<p>Nothing matches, so the output is just an empty set of <code>{}</code> - we deleted nothing. Let's try again, deleting any <code>Country</code> object that has &quot;ania&quot; in its name:</p>
<pre><code class="language-edgeql">delete Country filter .name ilike '%ania%';
</code></pre>
<p>We got a <code>{default::Country {id: 7f3c611c-ff43-11eb-af59-dfe5a152a5cb}}</code>, which is certainly Romania. Only Hungary is left. What if we want to see what we deleted? No problem - just put the <code>delete</code> inside parentheses and <code>select</code> it. Since EdgeDB just returns the objects that have been worked on, we can give them a shape to view them even as we are deleting them! So the query will look like this:</p>
<pre><code class="language-edgeql">select (delete Country) {
  name
};
</code></pre>
<p>These queries are easier to read if you think about what expressions inside parentheses evaluate into. What does <code>delete Country</code> evaluate into? A set of <code>Country</code> objects. So the query is essentially just saying &quot;select the country objects (that we are deleting) and display their name&quot;.</p>
<p>The output is <code>{default::Country {name: 'Hungary'}}</code>, showing us that we deleted Hungary. And now if we do <code>select Country</code> we get a <code>{}</code>, which confirms that we did delete them all.</p>
<p>Fun fact: <code>delete</code> statements in EdgeDB are actually {ref}<code>syntactic sugar &lt;docs:ref_eql_statements_delete&gt;</code> for <code>delete (select ...)</code>. You'll be learning something called <code>limit</code> in the next chapter with <code>select</code> and as you do so, keep in mind that you can apply the same to <code>delete</code> too.</p>
<p>We should probably delete that <code>City</code> object with <code>''</code> as its name that we inserted in the last chapter as we practiced indexing. That's easy:</p>
<pre><code class="language-edgeql">delete City filter .name = '';
</code></pre>
<p>Finally, let's insert Hungary and Romania again to finish the section on deleting. Plus Count Dracula! With those three objects inserted again, we'll now leave them alone.</p>
<h2 id="the-splat-operator"><a class="header" href="#the-splat-operator">The splat operator</a></h2>
<p>Sometimes a query can take some time to type. Let's say we want to look up all of our <code>PC</code> objects and their properties, plus check whether their name has changed since Bram Stoker's book Dracula was published. Such a query would look like this:</p>
<pre><code class="language-edgeql">select City {
  name,
  modern_name,
  important_places,
  id,
  name_has_changed := exists .modern_name
};
</code></pre>
<p>This gives us the following output:</p>
<pre><code>{
  default::City {
    name: 'Munich',
    modern_name: {},
    important_places: {},
    id: 8a6d06bc-0b04-11ee-bd1f-67f7c83004cb,
    name_has_changed: false,
  },
  default::City {
    name: 'Buda-Pesth',
    modern_name: 'Budapest',
    important_places: {},
    id: 8a9e9222-0b04-11ee-bd1f-cfa57ad4cff6,
    name_has_changed: true,
  },
  default::City {
    name: 'Bistritz',
    modern_name: 'Bistri»õa',
    important_places: ['Golden Krone Hotel'],
    id: 8ac23b46-0b04-11ee-bd1f-cf07e2483e97,
    name_has_changed: true,
  },
}
</code></pre>
<p>Not bad! But we had to type quite a bit to select every property inside <code>City</code>. Wouldn't it be nice if EdgeDB had an operator that could do that for us?</p>
<p>It just so happens that EdgeDB since 2023 does have such an operator! The operator is called the splat operator because it uses a <code>*</code> which...looks like a splat. In other languages you sometimes see this called the 'global operator' which also has to do with importing or using everything in a namespace, so the <code>*</code> operator was well chosen. In SQL this is callect &quot;select star&quot;, and the splat operator in EdgeDB is a better and more powerful version of that.</p>
<p>Let's try using the splat operator with <code>City</code> now.</p>
<pre><code class="language-edgeql">select City {*};
</code></pre>
<p>And that's all there is to it! Here's the output:</p>
<pre><code>{
  default::City {
    name: 'Munich',
    modern_name: {},
    important_places: {},
    id: 8a6d06bc-0b04-11ee-bd1f-67f7c83004cb,
  },
  default::City {
    name: 'Buda-Pesth',
    modern_name: 'Budapest',
    important_places: {},
    id: 8a9e9222-0b04-11ee-bd1f-cfa57ad4cff6,
  },
  default::City {
    name: 'Bistritz',
    modern_name: 'Bistri»õa',
    important_places: ['Golden Krone Hotel'],
    id: 8ac23b46-0b04-11ee-bd1f-cf07e2483e97,
  },
}
</code></pre>
<p>And if we want to include the computed <code>name_has_changed</code> property, we can just add it after the splat operator. So the quick query below will return the same output as the first query that needed all the extra typing.</p>
<pre><code class="language-edgeql">select City {
  *,
  name_has_changed := exists .modern_name
};
</code></pre>
<p>If the splat operator is used for a type that is extended by other types, it will choose all of the properties that they have in common. Let's demonstrate that with three queries.</p>
<pre><code>db&gt; select PC{*};
{default::PC {name: 'Emil Sinclair', id: 8b0633d2-0b04-11ee-bd1f-2f48cb19fb35, class: Mystic}}

db&gt; select NPC {*};
{
  default::NPC {name: 'Jonathan Harker', id: 8ae5923a-0b04-11ee-bd1f-e3545fe0bccf, age: {}},
  default::NPC {name: 'The innkeeper', id: 8bd08f10-0b04-11ee-bd1f-bf2be2316e84, age: 30},
}

db&gt; select Person {*};
{
  default::PC {id: 8b0633d2-0b04-11ee-bd1f-2f48cb19fb35, name: 'Emil Sinclair'},
  default::Vampire {id: 8b4aefcc-0b04-11ee-bd1f-c36d2df0b47a, name: 'Count Dracula'},
  default::NPC {id: 8ae5923a-0b04-11ee-bd1f-e3545fe0bccf, name: 'Jonathan Harker'},
  default::NPC {id: 8bd08f10-0b04-11ee-bd1f-bf2be2316e84, name: 'The innkeeper'},
}
</code></pre>
<p>Notice the difference? The <code>PC</code> type contains a <code>class</code> that the two others don't, while <code>NPC</code> has an <code>age</code> property. The base <code>Person</code> type doesn't hold either of these two properties.</p>
<h2 id="the-double-splat-operator"><a class="header" href="#the-double-splat-operator">The double splat operator</a></h2>
<p>But wait, there's more! EdgeDB also has a double splat operator: <code>**</code> instead of <code>*</code>. Let's see what it does with <code>City</code>.</p>
<pre><code class="language-edgeql">select City {**};
</code></pre>
<p>If you try that query...you'll get the same output. That's because <code>City</code> isn't linked to anything, and the double splat operator is used for showing all properties <em>and</em> all links.</p>
<p>Let's demonstrate by querying all of our <code>Person</code> objects. We tried a query just before with <code>select Person {*};</code> which showed us all of the <code>Person</code> types, their <code>id</code> and their <code>name</code>. Could the double splat operator be any different? Let's give it a try.</p>
<pre><code class="language-edgeql">select Person {**};
</code></pre>
<p>The output is...verbose!</p>
<pre><code>{
  default::PC {
    id: 8b0633d2-0b04-11ee-bd1f-2f48cb19fb35,
    name: 'Emil Sinclair',
    places_visited: {},
  },
  default::Vampire {
    id: 8b4aefcc-0b04-11ee-bd1f-c36d2df0b47a,
    name: 'Count Dracula',
    places_visited: {
      default::Country {
        id: 8b2a64f0-0b04-11ee-bd1f-632e60d595d2,
        important_places: {},
        modern_name: {},
        name: 'Romania',
      },
    },
  },
  default::NPC {
    id: 8ae5923a-0b04-11ee-bd1f-e3545fe0bccf,
    name: 'Jonathan Harker',
    places_visited: {
      default::City {
        id: 8a6d06bc-0b04-11ee-bd1f-67f7c83004cb,
        important_places: {},
        modern_name: {},
        name: 'Munich',
      },
      default::City {
        id: 8a9e9222-0b04-11ee-bd1f-cfa57ad4cff6,
        important_places: {},
        modern_name: 'Budapest',
        name: 'Buda-Pesth',
      },
      default::City {
        id: 8ac23b46-0b04-11ee-bd1f-cf07e2483e97,
        important_places: ['Golden Krone Hotel'],
        modern_name: 'Bistri»õa',
        name: 'Bistritz',
      },
    },
  },
  default::NPC {
    id: 8bd08f10-0b04-11ee-bd1f-bf2be2316e84,
    name: 'The innkeeper',
    places_visited: {},
  },
}
</code></pre>
<p>This is because <code>Person</code> is linked to <code>Place</code> via the <code>places_visited</code> link, and the double splat operator shows you both an object's properties and the properties of the objects it links to. This operator only goes down to a depth of one, meaning that it won't follow the links of a linked object. This makes sense because in some databases you could see links that go on almost forever.</p>
<h2 id="deleting-bistritz"><a class="header" href="#deleting-bistritz">Deleting Bistritz</a></h2>
<p>Now that we know how to <code>delete</code>, let's try to get rid of our duplicate Bistritz. Later on we will learn how to do this smoothly thanks to learning how to <code>update</code> in Chapter 6, and how to manage deletion policies in Chapter 13. But even at this point we still know enough to make the deletion happen with a few extra steps.</p>
<p>Let's first do a query to remember what the two objects look like at the moment:</p>
<pre><code class="language-edgeql">select City {*} filter .name = 'Bistritz';
</code></pre>
<p>And the output:</p>
<pre><code>{
  default::City {
    name: 'Bistritz',
    modern_name: 'Bistri»õa',
    id: 8ac23b46-0b04-11ee-bd1f-cf07e2483e97,
    important_places: ['Golden Krone Hotel'],
  },
  default::City {
    name: 'Bistritz',
    modern_name: 'Bistri»õa',
    id: d1e38192-0bd6-11ee-ba45-d7ecb20723cf,
    important_places: {},
  },
}
</code></pre>
<p>Ah yes, we have a <code>City</code> called Bistritz that was inserted before we added the <code>important_places</code> property. There are two differences between the two: they have different <code>id</code> numbers, and one has an <code>important_places</code> property. Our plan is to delete one of them by filtering on its <code>id</code> property, so make a note of the <code>id</code> of the <code>City</code> that doesn't have any <code>important_places</code>. The <code>id</code> will naturally be different on your computer as an <code>id</code> is always unique.</p>
<p>Now if we wanted to delete both of them, we would simply type <code>delete City;</code>. However, this wouldn't work in any case. Give it a try and see what happens!</p>
<pre><code class="language-edgeql">delete City;
</code></pre>
<p>The problem here is that Jonathan Harker is standing in our way. He is an <code>NPC</code> object with a link to the other <code>City</code> objects, and by default you can't delete an object that is being linked to by another one.</p>
<pre><code>edgedb error: ConstraintViolationError: deletion of default::City (f801a034-387c-11ee-95af-87dfbf43e85c) is prohibited by link target policy
  Detail: Object is still referenced in link places_visited of default::Person (fc6522d6-387c-11ee-95af-f750f3ca3b62).
</code></pre>
<p>Within the limitations of what we know at the moment, the only thing we can do is to temporarily delete Jonathan Harker. We'll <code>insert</code> him again shortly, but in the meantime let's just get him out of the way:</p>
<pre><code class="language-edgeql">delete NPC filter .name = 'Jonathan Harker';
</code></pre>
<p>And now that Jonathan is no longer standing in the way, let's try to delete one of the duplicate cities.</p>
<p>This query almost works but not quite:</p>
<pre><code class="language-edgeql">delete City filter .id = 'd1e38192-0bd6-11ee-ba45-d7ecb20723cf';
</code></pre>
<p>Close! Remember the casting we did from a <code>str</code> to <code>uuid</code> in Chapter 2?</p>
<pre><code>error: InvalidTypeError: operator '=' cannot be applied to operands of type 
'std::uuid' and 'std::str'
  ‚îå‚îÄ &lt;query&gt;:1:13
  ‚îÇ
1 ‚îÇ delete City filter .id = 'd1e38192-0bd6-11ee-ba45-d7ecb20723cf';
  ‚îÇ             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
  Consider using an explicit type cast or a conversion function.
</code></pre>
<p>So let's just cast the <code>str</code> to a <code>uuid</code> and it will now work:</p>
<pre><code class="language-edgeql">delete City filter .id = &lt;uuid&gt;'d1e38192-0bd6-11ee-ba45-d7ecb20723cf';
</code></pre>
<p>And now it's gone! We are back to a single <code>City</code> object named Bistritz instead of two.</p>
<p>Finally, let's put Jonathan Harker back into the database. Soon we'll learn enough about EdgeDB so that we won't have to delete him like we did in this chapter.</p>
<pre><code class="language-edgeql">insert NPC {
  name := 'Jonathan Harker',
  places_visited := City,
};
</code></pre>
<p><a href="chapter3/code.html">Here is all our code so far up to Chapter 3.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice-2"><a class="header" href="#time-to-practice-2">Time to practice</a></h2>
<ol>
<li>
<p>This query is trying to display every <code>NPC</code> along with the <code>name</code> plus every <code>City</code> type for each <code>NPC</code>, but it's giving an error. What is it missing?</p>
<pre><code class="language-edgeql">select NPC {
  name,
  cities := select City.name
};
</code></pre>
</li>
<li>
<p>If the <code>City</code> type needed a required property called <code>population</code>, what would it look like? What type would 'population' be?</p>
</li>
<li>
<p>This query wants to display <code>name</code> twice for some reason but is giving an error. Can you think of a way to do it?</p>
<pre><code class="language-edgeql">select Person {
  name,
  name
};
</code></pre>
<p>(Hint: the problem is that the name <code>name</code> is being used twice)</p>
</li>
<li>
<p>People keep trying to make characters with negative ages. Can you think of a constraint that can stop this?</p>
<p>Hint: the current constraint is <code>max_value(120);</code></p>
</li>
<li>
<p>Can you insert a HumanAge type?</p>
</li>
</ol>
<p><a href="chapter3/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>Jonathan: &quot;This Count Dracula knows so much about history! I'm glad I came.&quot;</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>tags: Local Time, Advanced Filtering
leadImage: illustration_04.jpg</h2>
<h1 id="chapter-4---what-a-strange-man-this-count-dracula-is"><a class="header" href="#chapter-4---what-a-strange-man-this-count-dracula-is">Chapter 4 - &quot;What a strange man this Count Dracula is.&quot;</a></h1>
<p>The days and nights continue to go by, and Jonathan Harker is still in the castle. In this chapter it's time for us to learn how to work with time.</p>
<blockquote>
<p>Jonathan Harker wakes up late and is alone in the castle. Dracula appears after nightfall and they talk <strong>through the night</strong>. Dracula is making plans to move to London, and Jonathan gives him some advice about buying houses. Jonathan tells Dracula that a big house called Carfax would be a good house to buy. It's very big and quiet. Carfax is close to a mental asylum, but not too close. Dracula loves the idea.
Dracula then tells Jonathan not to go into any of the locked rooms in the castle, because it could be dangerous. Jonathan sees that it's almost <strong>morning</strong>. They talked through the whole night again! Dracula suddenly stands up and says he must go, and leaves the room. Jonathan thinks about <strong>Mina</strong> back in London, who he is going to marry when he returns. He is beginning to feel that there is something wrong with Dracula, and the castle. Seriously, where are the other people?</p>
</blockquote>
<p>First let's create Jonathan's girlfriend, Mina Murray. It would be nice to represent their relationship somehow, so let's try by adding a new link to the <code>Person</code> type in the schema called <code>lover</code>. Let's change the <code>Person</code> type to what you see here and do a migration:</p>
<pre><code class="language-sdl">abstract type Person {
  required name: str;
  multi places_visited: Place;
  lover: Person;
}
</code></pre>
<p>With this we can link the two of them together. We will assume that a person can only have one <code>lover</code>, so this is a single link. If we wanted <code>lover</code> to be a multi link, we would have written <code>multi lover</code> instead.</p>
<p>Mina is in London, and we don't know if she has been anywhere else. So let's do a quick insert to create the city of London. It couldn't be easier:</p>
<pre><code class="language-edgeql">insert City {
  name := 'London',
};
</code></pre>
<p>To give her the city of London, we can just do a quick <code>(select City filter .name = 'London')</code>. This will give her the <code>City</code> that matches <code>.name = 'London'</code>, but it won't give an error if the city's not there: it will just return an empty set. When giving her Jonathan Harker as a <code>lover</code> link, however, it is a bit more complicated. Let's see why.</p>
<h2 id="using-the-keywords-detached-exists-and-limit"><a class="header" href="#using-the-keywords-detached-exists-and-limit">Using the keywords detached, exists, and limit</a></h2>
<p>The <code>insert</code> for Mina Murry is a bit more complicated. We might be tempted to try an <code>insert</code> this way, but there are two problems:</p>
<pre><code class="language-edgeql">insert NPC {
  name := 'Mina Murray',
  lover := (select NPC filter .name = 'Jonathan Harker'),
  places_visited := (select City filter .name = 'London'),
 };
</code></pre>
<p>Fortunately, the compiler is smart enough to tell us exactly what the problems are! If you try this insert you will see the following error message:</p>
<pre><code>error: QueryError: invalid reference to default::NPC: 
self-referencing INSERTs are not allowed
  ‚îå‚îÄ &lt;query&gt;:3:20
  ‚îÇ
3 ‚îÇ   lover := (select NPC filter .name = 'Jonathan Harker'),
  ‚îÇ                    ^^^ Use DETACHED if you meant to refer 
  to an uncorrelated default::NPC set
</code></pre>
<p>The issue here is that we are inside of an <code>insert</code> for the <code>NPC</code> type, but we want to link to another <code>NPC</code>, not the one we are inserting. We need to add <code>detached</code> to specify that we are talking about <code>NPC</code> in general, not the <code>NPC</code> that we are inserting right now.</p>
<p>Sounds good. Let's change <code>select NPC</code> to <code>select detached NPC</code> so that we can filter on all of the <code>NPC</code> objects. There is one error left, and you might be able to guess what it is. What will the result of the <code>filter</code> be, and does it match with the link <code>lover</code>?</p>
<pre><code class="language-edgeql">insert NPC {
  name := 'Mina Murray',
  lover := (select detached NPC filter .name = 'Jonathan Harker'),
  places_visited := (select City filter .name = 'London'),
 };
</code></pre>
<p>That's right! Our <code>filter</code> will return a set of <code>NPC</code> objects. This set might have zero or one <code>NPC</code> objects...but it also might be more than one. That's not okay for a <code>link</code>, which is by default a <code>single link</code>. Here is the error message:</p>
<pre><code>error: QueryError: possibly more than one element returned by an expression 
for a link 'lover' declared as 'single'
  ‚îå‚îÄ &lt;query&gt;:3:3
  ‚îÇ
3 ‚îÇ   lover := (select detached NPC filter .name = 'Jonathan Harker'),
  ‚îÇ   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error
</code></pre>
<p>To fix this, we can use a function called {eql:func}<code>docs:std::assert_single</code>. This is used here because the link is a single link. EdgeDB doesn't know how many results we might get: for all it knows, there might be 2 or 3 or more <code>Jonathan Harkers</code>. To guarantee that we are only creating a single link, we use the <code>assert_single()</code> function. Careful! This will return an error if more than one result is returned.</p>
<p>The full insert for Mina Murray will look like this:</p>
<pre><code class="language-edgeql">insert NPC {
  name := 'Mina Murray',
  lover := assert_single(
    (select detached NPC filter .name = 'Jonathan Harker')
  ),
  places_visited := (select City filter .name = 'London'),
};
</code></pre>
<p>EdgeDB has another keyword called <code>limit</code> that limits the number of objects returned to any number we like, and in this case we could have gotten the <code>insert</code> to work by using <code>limit 1</code>.</p>
<pre><code class="language-edgeql">insert NPC {
  name := 'Mina Murray',
  lover := (select detached NPC filter .name = 'Jonathan Harker' limit 1),
  places_visited := (select City filter .name = 'London'),
 };
</code></pre>
<p>However, in this case <code>assert_single()</code> is better because <code>filter .name = 'Jonathan Harker'</code> might have returned more than one object. Maybe there are four or five Jonathan Harkers in the database, and only one of them would be returned. And if we used <code>limit 1</code> again in the same way, we might get a different <code>NPC</code> called Jonathan Harker. Using <code>limit 1</code> picks at most one result, but it says nothing about which one, just the first one that the database finds. Picking the order in which results get looked at is covered in <a href="chapter4/../chapter10/index.html">Chapter 10</a>.</p>
<p>We can (and will) add a constraint to ensure that names are unique, but in the meantime keep in mind the difference between <code>assert_single()</code> and <code>limit 1</code>.</p>
<p>Now let's make a query to see who is single and who is not. This is easy by using a &quot;computed&quot; property, where we can create a new variable that we define with <code>:=</code>. First here is a basic query showing the names of each <code>Person</code> object's <code>lover</code>:</p>
<pre><code class="language-edgeql">select Person {
  name,
  lover: {
    name
  }
};
</code></pre>
<p>This gives us:</p>
<pre><code>{
  default::NPC {name: 'Jonathan Harker', lover: {}},
  default::NPC {name: 'The innkeeper', lover: {}},
  default::NPC {name: 'Mina Murray', lover: default::NPC {name: 'Jonathan Harker'}},
  default::PC {name: 'Emil Sinclair', lover: {}},
  default::Vampire {name: 'Count Dracula', lover: {}},
}
</code></pre>
<p>We can see that Mina Murray has a lover but Jonathan Harker does not yet, because he was inserted first when Mina Murray didn't exist yet. We'll learn some techniques later in Chapters 6, 14 and 15 to deal with this. In the meantime we'll just leave Jonathan Harker with <code>{}</code> for the <code>lover</code> link.</p>
<p>Back to the query: what if we just want to say <code>true</code> or <code>false</code> depending on if the character has a lover? To do that we can put a computed property in the query, using <code>exists</code>. We'll call it <code>is_single</code>, but since it's not in the schema for the <code>Person</code> type we could call it anything we like here. The keyword <code>not exists</code> will return <code>false</code> if a set is returned, and <code>true</code> if it gets <code>{}</code> (if there is nothing). This is once again one of the nice things about using empty sets in EdgeDB instead of null. It looks like this:</p>
<pre><code class="language-edgeql">select Person {
  name,
  is_single := not exists .lover,
};
</code></pre>
<p>Now this prints:</p>
<pre><code>{
  default::NPC {name: 'Jonathan Harker', is_single: true},
  default::NPC {name: 'The innkeeper', is_single: true},
  default::NPC {name: 'Mina Murray', is_single: false},
  default::PC {name: 'Emil Sinclair', is_single: true},
  default::Vampire {name: 'Count Dracula', is_single: true},
}
</code></pre>
<p>This also shows why abstract types are useful. Here we did a quick search on <code>Person</code> which returned data from <code>Vampire</code>, <code>PC</code>, and <code>NPC</code> objects, because they all extend the <code>abstract type Person</code>.</p>
<p>We've got a lot of single characters, let's try selecting just one of them:</p>
<pre><code class="language-edgeql">select Person {
  name,
  is_single := not exists .lover,
} filter .is_single limit 1;
</code></pre>
<p>If the first <code>Person</code> type returned from the database is Count Dracula, then we will see the following output:</p>
<pre><code>{default::Vampire {name: 'Count Dracula', is_single: true}}
</code></pre>
<p>Now this time we did want to use <code>limit 1</code> instead of <code>assert_single()</code> because we want just up to one result, even if there are multiple objects that fit our <code>filter</code>. Using <code>assert_single()</code> would cause the database give us an error in case of multiple results. Similarly, <code>limit 2</code>, <code>limit 3</code> and any other number will work just fine if we only want a certain maximum number of objects.</p>
<p>We could also put the computed property in the type itself, so let's do that. Here's the same computed property except now it's inside the <code>Person</code> type:</p>
<pre><code class="language-sdl">abstract type Person {
  required name: str;
  multi places_visited: Place;
  lover: Person;
  property is_single := not exists .lover;
}
</code></pre>
<p>Notice that we have written <code>property is_single</code> this time instead of just <code>is_single</code>. With computed properties and links we need to give EdgeDB a little bit more help by letting it know whether the computed expression will result in a <code>property</code> or a <code>link</code>. So if you are working on your schema and the property or link uses a <code>:=</code> to make it computed, don't forget to choose between <code>property</code> or <code>link</code>!</p>
<p>You might be curious about how computed links and properties are represented in databases on the back end. They are interesting because they {ref}<code>don't show up in the actual database &lt;docs:ref_datamodel_computed&gt;</code>, and only appear when you query them. Computed links also don't specify the type because the expression itself determines the type. You can kind of imagine this when you look at a query with a quick computed variable like <code>select country_name := 'Romania'</code>. Here, <code>country_name</code> is computed every time we do a query, and the type is determined to be a string. A computed link or property on a type does the same thing. But nevertheless, they still work in the same way as all other links and properties because the instructions for the computed ones are part of the type itself and do not change. In other words, they are a bit different on the back but mostly the same up front.</p>
<h2 id="ways-to-tell-time"><a class="header" href="#ways-to-tell-time">Ways to tell time</a></h2>
<p>We will now learn about time, which is important for our game. Keeping track of time is important in general, but is especially important for us because vampires can only go outside at night.</p>
<p>The part of Romania that Jonathan Harker is visiting has an average sunrise of around 7 am and a sunset of 7 pm. This changes by season, but to keep it simple we will just use 7 am and 7 pm to decide if it's day or night.</p>
<p>EdgeDB uses two major types for time:</p>
<ul>
<li><code>std::datetime</code>, which is the most precise because it includes a timezone. Times in <code>datetime</code> use the <a href="https://en.wikipedia.org/w/index.php?title=ISO_8601&amp;oldid=1154675086">ISO 8601 standard</a>.</li>
<li><code>cal::local_datetime</code>, which includes the date and time but no information about the timezone.</li>
</ul>
<p>There are two others that each include half of the information found in <code>cal::local_datetime</code>:</p>
<ul>
<li><code>cal::local_time</code>, for when you only need to know the time,</li>
<li><code>cal::local_date</code>, for when you only need to know the month, the day, and year.</li>
</ul>
<p>Our first concern is whether vampires are sleeping or not, so we'll start with <code>cal::local_time</code> first. Take a close look at the name: this is the first time we have come across something in a different module in the standard library (it's <code>cal::local_time</code>, not <code>std::local_time</code>). The name <code>cal</code> here stands for calendar.</p>
<p><code>cal::local_time</code> is easy to create, because you can just cast to it from a <code>str</code> in the format 'HH:MM:SS':</p>
<pre><code class="language-edgeql">select &lt;cal::local_time&gt;('15:44:56');
</code></pre>
<p>This gives us the output:</p>
<pre><code>{&lt;cal::local_time&gt;'15:44:56'}
</code></pre>
<p>We will imagine that our game engine has a clock that sends the database the time as a <code>str</code>, like the '15:44:56' in the example above. We'll make a quick <code>Time</code> type that will hold this <code>str</code> and use it to make two computed properties. It looks like this:</p>
<pre><code class="language-sdl">type Time { 
  required clock: str; 
  property clock_time := &lt;cal::local_time&gt;.clock; 
  property hour := .clock[0:2]; 
} 
</code></pre>
<p><code>.clock[0:2]</code> is an example of {eql:op}<code>&quot;slicing&quot; &lt;docs:arrayslice&gt;</code> that we learned about in Chapter 2. To review, <code>[0:2]</code> means start from index 0 (the first index) and stop <em>before</em> index 2, which means indexes 0 and 1. This is fine because to cast a <code>str</code> to <code>cal::local_time</code> you need to write the hour with two numbers (e.g. <code>09</code> is okay, but <code>9</code> is not).</p>
<p>So this won't work:</p>
<pre><code class="language-edgeql">select &lt;cal::local_time&gt;'9:55:05';
</code></pre>
<p>It gives this error:</p>
<pre><code>edgedb error: InvalidValueError: invalid input syntax
for type cal::local_time: '9:55:05'
Hint: Please use ISO8601 format. Examples: 18:43:27 or 18:43
Alternatively &quot;to_local_time&quot; function provides custom formatting options.
</code></pre>
<p>Because of that, we are sure that slicing from index 0 to 2 will give us two numbers that indicate the hour of the day.</p>
<p>Let's do a migration so we can insert a <code>Time</code> object. It's pretty easy:</p>
<pre><code class="language-edgeql">insert Time {
    clock := '09:55:05',
};
</code></pre>
<p>And then we can <code>select</code> our <code>Time</code> objects and everything inside:</p>
<pre><code class="language-edgeql">select Time {
  clock,
  clock_time,
  hour,
};
</code></pre>
<p>That gives us a nice output that shows everything, including the hour:</p>
<pre><code>{default::Time {clock: '09:55:05', clock_time: &lt;cal::local_time&gt;'09:55:05', hour: '09'}}
</code></pre>
<p>Finally, we can add some logic to the <code>Time</code> type to see if vampires are awake or asleep. Since this property requires choosing between one of multiple choices, an enum seems like a good choice.</p>
<pre><code class="language-sdl">scalar type SleepState extending enum &lt;Asleep, Awake&gt;;

type Time {
  required clock: str;
  property clock_time := &lt;cal::local_time&gt;.clock;
  property hour := .clock[0:2];
  property vampires_are := SleepState.Asleep if &lt;int16&gt;.hour &gt; 7 and &lt;int16&gt;.hour &lt; 19
    else SleepState.Awake;
}
</code></pre>
<p>So <code>vampires_are</code> is calculated like this:</p>
<ul>
<li>First EdgeDB checks to see if the hour is greater than 7 and less than 19 (7 pm). But it's better to compare with a number than a string, so we cast into an <code>int16</code> with <code>&lt;int16&gt;.hour</code> instead of <code>.hour</code> so it can compare a number to a number.</li>
<li>Then it chooses between the 'Asleep' or 'Awake' values of the enum depending on that.</li>
</ul>
<p>Now let's do a <code>select</code> again with all the properties:</p>
<pre><code class="language-edgeql">select Time {*};
</code></pre>
<p>We then get this output:</p>
<pre><code>{
  default::Time {
    id: 0fb1d964-1989-11ee-915e-5b585f9c9744,
    clock: '09:55:05',
    clock_time: &lt;cal::local_time&gt;'09:55:05',
    hour: '09',
    vampires_are: Asleep,
  },
}
</code></pre>
<p>One more note on <code>else</code>: you can keep on using <code>else</code> as many times as you like in the format <code>(result) if (condition) else</code>. Here's an example showing how this could work if we had more values on the <code>SleepState</code> enum:</p>
<pre><code class="language-sdl">property vampires_are := 
  SleepState.JustWakingUp if &lt;int16&gt;.hour = 19 else
  SleepState.GoingToBed if &lt;int16&gt;.hour = 6 else
  SleepState.Asleep if &lt;int16&gt;.hour &gt; 7 and &lt;int16&gt;.hour &lt; 19 else
  SleepState.Awake;
</code></pre>
<h2 id="selecting-what-you-just-inserted"><a class="header" href="#selecting-what-you-just-inserted">Selecting what you just inserted</a></h2>
<p>Back in Chapter 3, we learned how to <code>select</code> while deleting at the same time. Using an <code>insert</code> also returns the object (or objects) in question, so we can select them too. You can do this by enclosing the output in parentheses and then giving that a shape, same as with any other <code>select</code>. Let's work on this one step at a time.</p>
<p>If we insert a new <code>Time</code>, all we get is a <code>uuid</code>:</p>
<pre><code class="language-edgeql">insert Time {
  clock := '22:44:10'
};
</code></pre>
<p>The output is just something like this: <code>{default::Time {id: 3f6951c6-ff48-11eb-915e-3fd1092b2757}}</code></p>
<p>Now let's wrap it inside a <code>select</code>:</p>
<pre><code class="language-edgeql">select(
  insert Time {
    clock := '22:44:10'
  }
);
</code></pre>
<p>The output is still the same so far. But now that we are using <code>select</code>, we can follow it up with brackets to provide it a shape. Besides the regular properties to display, we can also add a computed property while we are at it. This computed property will give you a taste of what we will learn in the next chapter.</p>
<pre><code class="language-edgeql">select (
  insert Time {
    clock := '22:44:10'
  }
)
  {
    clock,
    hour,
    vampires_are,
    time_until_just_before_midnight := &lt;cal::local_time&gt;'23:59:59'
                         - &lt;cal::local_time&gt;.clock
  };
</code></pre>
<p>(The computed <code>time_until_midnight</code> property used '23:59:59' as its input because the range of a <code>local_time</code> is 0:00:00 to 23:59:59. If we needed more accuracy we could have added a <code>&lt;duration&gt;'1 second'</code> to the expression. We will learn how to work with durations in the next chapter.)</p>
<p>Now the output is more meaningful to us: </p>
<pre><code>{
  default::Time {
    clock: '22:44:10',
    hour: '22',
    vampires_are: Awake,
    time_until_just_before_midnight: &lt;cal::relative_duration&gt;'PT1H15M49S',
  },
}
</code></pre>
<p>We know the clock and the hour, we can see that vampires are awake, and even make a computed property from the object we just entered. Looks like we have one hour, 15 minutes, and 50 seconds until midnight.</p>
<h2 id="making-time-global"><a class="header" href="#making-time-global">Making Time global</a></h2>
<p>Depending on how closely you've been following this chapter, you probably have about three or four <code>Time</code> objects in the database by now. That feels a bit odd, because this <code>Time</code> type is most useful for determining the current state of the game: the current clock time, if vampires are awake or not, and so on. So instead of multiple <code>Time</code> objects floating around in the database, we should have a single global <code>Time</code> object instead.</p>
<p>So first let's delete all the <code>Time</code> objects in the database with <code>delete Time;</code> and make a change to the schema by making a <code>global</code> type called <code>time</code>. In EdgeDB a global type can either be:</p>
<ul>
<li>A scalar type if it isn't computed,</li>
<li>Any type if it is computed.</li>
</ul>
<p>In our case we are going to make <code>time</code> a computed global that selects all the <code>Time</code> objects in the database, which in our case should never be more than one. So we can define it using the <code>assert_single()</code> function again. The global type will now look like this:</p>
<pre><code class="language-sdl">global time := assert_single((select Time));
</code></pre>
<p>Now that this is added, let's do a migration and see what's inside! Selecting a global type is done in the same way as with other types except that it needs the <code>global</code> keyword:</p>
<pre><code class="language-edgeql">select global time {*};
</code></pre>
<p>Doing this should return an empty set. Now let's insert the current time:</p>
<pre><code class="language-edgeql">insert Time { clock := '09:00:00' };
</code></pre>
<p>And then do the query on <code>global time</code> again:</p>
<pre><code class="language-edgeql">select global time {*};
</code></pre>
<p>With this single global <code>Time</code> object in our database, we can now see the current time and what vampires are up to at the moment:</p>
<pre><code>{
  default::Time {
    id: d6363f92-1517-11ee-ab3d-834f250e5e21,
    clock: '09:00:00',
    clock_time: &lt;cal::local_time&gt;'09:00:00',
    hour: '09',
    vampires_are: Asleep,
  },
}
</code></pre>
<p>In Chapter 6 we will learn how to <code>update</code> objects, which will let us change this global <code>Time</code> object whenever we like. And much later on in the book we will also add a global scalar value, so stay tuned!</p>
<p><a href="chapter4/code.html">Here is all our code so far up to Chapter 4.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice-3"><a class="header" href="#time-to-practice-3">Time to practice</a></h2>
<ol>
<li>
<p>This insert is not working.</p>
<pre><code class="language-edgeql">insert NPC {
  name := 'I Love Mina',
  lover := assert_single(
    (select NPC filter .name like '%Mina%')
  )
};
</code></pre>
<p>The error is: <code>invalid reference to default::NPC: self-referencing INSERTs are not allowed</code>. What keyword can we use to make this insert work?</p>
<p>Bonus: there is another method we could use too to make it work without the keyword. Can you think of another way?</p>
</li>
<li>
<p>How would you display up to 2 <code>Person</code> types (and their <code>name</code> property) whose names include the letter <code>a</code>?</p>
</li>
<li>
<p>How would you display all the <code>Person</code> types (and their names) that have never visited anywhere?</p>
<p>Hint: all the <code>Person</code> types for which <code>.places_visited</code> returns <code>{}</code>.</p>
</li>
<li>
<p>Imagine that you have the following <code>cal::local_time</code> type:</p>
<pre><code class="language-edgeql">select has_nine_in_it := &lt;cal::local_time&gt;'09:09:09';
</code></pre>
<p>This displays <code>{&lt;cal::local_time&gt;'09:09:09'}</code> but instead you want to display {true} if it has a 9 and {false} otherwise. How could you do that?</p>
</li>
<li>
<p>We are inserting a character called The Innkeeper's Son:</p>
<pre><code class="language-edgeql">insert NPC {
  name := &quot;The Innkeeper's Son&quot;,
  age := 10
};
</code></pre>
<p>How would you <code>select</code> this insert at the same time to display the <code>name</code>, <code>age</code>, and <code>age_ten_years_later</code> that is made from <code>age</code> plus 10?</p>
</li>
</ol>
<p><a href="chapter4/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>Jonathan's curiosity gets the better of him. What's inside this castle?</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>tags: Datetime, Describing Types
leadImage: illustration_05.jpg</h2>
<h1 id="chapter-5---jonathan-tries-to-leave-the-castle"><a class="header" href="#chapter-5---jonathan-tries-to-leave-the-castle">Chapter 5 - Jonathan tries to leave the castle</a></h1>
<p>Poor Jonathan is still at Castle Dracula and is not having much luck. Here's what happens to him in this chapter:</p>
<blockquote>
<p>During the day, Jonathan decides to try to explore the castle but too many doors and windows are locked. He doesn't know how to get out, and wishes he could at least send a letter to Mina <strong>in London</strong>. He wonders what Mina is doing right about now. <strong>What time is it in London</strong>, and is she okay?</p>
<p>He pretends that there is no problem, and keeps talking to Dracula during the night. One night he sees Dracula climb out of his window and down the castle wall, like a snake. Dracula is not a human, but a monster! Now Jonathan is very afraid.</p>
<p>A few days later he breaks one of the doors and finds another part of the castle. The room is very strange and he feels sleepy. When he opens his eyes, he sees three vampire women next to him. He is attracted to them and afraid of them at the same time. He wants to kiss them, but knows that he will die if he does. They come closer, and he can't move...</p>
</blockquote>
<h2 id="stddatetime"><a class="header" href="#stddatetime">std::datetime</a></h2>
<p>Jonathan in Romania was thinking of Mina back in London, which is in a different timezone. This sounds like a good time to give the <code>std::datetime</code> type a try. To create a datetime, you can just cast a string in ISO 8601 format with <code>&lt;datetime&gt;</code>. The ISO 8601 format is <code>YYYY-MM-DDTHH:MM:SSZ</code>, which next to a concrete example looks like this:</p>
<pre><code>Format:  YYYY-MM-DDTHH:MM:SSZ
Example: 2023-06-06T22:12:10Z
</code></pre>
<p>So a cast to an actual datetime looks like this:</p>
<pre><code class="language-edgeql">select &lt;datetime&gt;'2023-06-06T22:12:10Z';
</code></pre>
<p>The <code>T</code> inside there is just a separator between date and time (in other words, <code>T</code> is where the <em>Time</em> starts), and the <code>Z</code> at the end stands for &quot;zero timeline&quot;. That means that it has no offset ‚Äî no difference ‚Äî from UTC: in other words, it <em>is</em> UTC.</p>
<p>One way to set a timezone is to change the <code>T</code> to an offset: the hour difference between the current time zone and UTC. Our query above returns the time &quot;22:12:10Z&quot;, so 10:12 PM in London. Let's change the <code>T</code> to <code>+09:00</code> (the timezone for Korea and Japan) and see what happens:</p>
<pre><code class="language-edgeql">select &lt;datetime&gt;'2023-06-06T22:12:10+09:00';
</code></pre>
<p>The output shows us the time in UTC again. In other words, it's 1:12 pm in London when it's 10:12 pm in Korea and Japan.</p>
<pre><code>{&lt;datetime&gt;'2023-06-06T13:12:10Z'}
</code></pre>
<p>One other way to get a <code>datetime</code> is to use the <code>to_datetime()</code> function. {eql:func}<code>Here are its signatures &lt;docs:std::to_datetime&gt;</code>, which show that there are six ways to make a <code>datetime</code> with this function depending on how you want to make it. EdgeDB will know which one of the six function signatures you have chosen depending on what input you pass in.</p>
<p>(Keep that point in mind, by the way! It's a hint for when we learn to write our own functions in Chapter 11.)</p>
<p>Let's do a quick detour before getting back to datetime. Inside one of the <code>to_datetime()</code> function signatures you might have noticed one unfamiliar type called a {eql:type}<code> ``decimal`` &lt;docs:std::decimal&gt;</code>. A decimal is a float with &quot;arbitrary precision&quot;, meaning that you can give it as many numbers after the decimal point as you want. The decimal type exists because float types on computers <a href="https://www.youtube.com/watch?v=PZRI1IfStY0&amp;ab_channel=Computerphile">become imprecise after a while</a> thanks to rounding errors. This example shows the problem that floats have after too much precision:</p>
<pre><code>db&gt; select 6.777777777777777; # Good so far
{6.777777777777777}
db&gt; select 6.7777777777777777; # Add one more digit...
{6.777777777777778} # Where did the 8 come from?!
</code></pre>
<p>To avoid this imprecision you can use a <code>&lt;decimal&gt;</code> cast, or just add an <code>n</code> to the end. This will return a <code>decimal</code> type which will be as precise as it needs to be. Now the rounding errors are gone:</p>
<pre><code>db&gt; select 6.7777777777777777n;
{6.7777777777777777n}
db&gt; select 6.7777777777777777777777777777777777777777777777777n;
{6.7777777777777777777777777777777777777777777777777n}
</code></pre>
<p>Similarly, there is a <code>bigint</code> type that also uses <code>n</code> for an arbitrary size. That's because even int64 has a limit: it's 9223372036854775807.</p>
<pre><code>db&gt; select 9223372036854775807; # Good so far...
{9223372036854775807}
db&gt; select 9223372036854775808; # But add 1 and it will fail
edgedb error: NumericOutOfRangeError: std::int64 out of range
</code></pre>
<p>Here as well you can just add an <code>n</code> and it will create a <code>bigint</code> that can accommodate any size.</p>
<pre><code>db&gt; select 9223372036854775808n;
{9223372036854775808n}
</code></pre>
<p>Now that we know all the numeric types, let's get back to the six signatures for the <code>to_datetime()</code> function:</p>
<pre><code>std::to_datetime(s: str, fmt: optional str = {}) -&gt; datetime
std::to_datetime(local: cal::local_datetime, zone: str) -&gt; datetime
std::to_datetime(year: int64, month: int64, day: int64,
  hour: int64, min: int64, sec: float64, timezone: str) -&gt; datetime
std::to_datetime(epochseconds: decimal) -&gt; datetime
std::to_datetime(epochseconds: float64) -&gt; datetime
std::to_datetime(epochseconds: int64) -&gt; datetime
</code></pre>
<p>The last signature works well if you want to know the <code>datetime</code> right now and are getting the epoch seconds (the number of seconds since 1970) from your computer's system time. It's also kind of fun to just experiment with:</p>
<pre><code>db&gt; select to_datetime(0);
{&lt;datetime&gt;'1970-01-01T00:00:00Z'}
db&gt; select to_datetime(100);
{&lt;datetime&gt;'1970-01-01T00:01:40Z'}
db&gt; select to_datetime(9879879870);
{&lt;datetime&gt;'2283-01-30T11:04:30Z'}
db&gt; select to_datetime(87623);
{&lt;datetime&gt;'1970-01-02T00:20:23Z'}
db&gt; select to_datetime(98723987213);
{&lt;datetime&gt;'5098-06-09T17:46:53Z'}
</code></pre>
<p>But the easiest signature is probably the third if you find ISO 8601 unfamiliar or you have a bunch of separate numbers to make into a date. Let's give that signature a try.</p>
<p>Let's imagine that it's May 12. It's a bright morning at 10:35 in Castle Dracula. The sun is up, Dracula is asleep in a coffin somewhere, and Jonathan is trying to use the time during the day to find a way to send Mina a letter. In Romania the timezone is 'EEST' (Eastern European Summer Time), and the year is (probably) 1893. We'll use <code>to_datetime()</code> to generate this.</p>
<pre><code class="language-edgeql">select to_datetime(1893, 5, 12, 10, 35, 0, 'EEST');
</code></pre>
<p>And get the following output:</p>
<p><code>{&lt;datetime&gt;'1893-05-12T07:35:00Z'}</code></p>
<p>The <code>07:35:00</code> part shows that it was automatically converted to UTC, which is London where Mina lives.</p>
<p>We can also use this to see the duration between events. EdgeDB has a <code>duration</code> type that you can get by subtracting a datetime from another one. Let's practice by calculating the exact number of seconds between one date in Central Europe and another in Korea:</p>
<pre><code class="language-edgeql">select to_datetime(2003, 5, 12, 8, 15, 15, 'CET')
     - to_datetime(2003, 5, 12, 6, 10, 0,  'KST');
</code></pre>
<p>This takes May 12 2003 8:15:15 am in Central European Time and subtracts May 12 2003 6:10 in Korean Standard Time. The result is: <code>{&lt;duration&gt;'10:05:15'}</code>, so 10 hours, 5 minutes, and 15 seconds.</p>
<p>Now let's try something similar with Jonathan as he tries to escape Castle Dracula. It's May 12 at 10:35 am in the <code>EEST</code> timezone. On the same day, Mina was in London at 6:10 am, drinking her morning tea. How many seconds passed between these two events? They are in different timezones, which makes the calculation a bit annoying. Fortunately, we don't need to calculate it ourselves! We can just specify the timezone and EdgeDB will do the rest.</p>
<pre><code class="language-edgeql">select to_datetime(1893, 5, 12, 10, 35, 0, 'EEST')
     - to_datetime(1893, 5, 12, 6,  10, 0, 'UTC');
</code></pre>
<p>The answer is 1 hour and 25 minutes: <code>{&lt;duration&gt;'1:25:00'}</code>.</p>
<p>To make the query easier for us to read, we can also use the <code>with</code> keyword to create variables. We can then use the variables in <code>select</code> below. We'll make one called <code>jonathan_wants_to_escape</code> and another called <code>mina_has_tea</code>, and subtract one from another to get a <code>duration</code>. With variable names it is now a lot clearer what we are trying to do:</p>
<pre><code class="language-edgeql">with
  jonathan_wants_to_escape := 
    to_datetime(1893, 5, 12, 10, 35, 0, 'EEST'),
  mina_has_tea := 
    to_datetime(1893, 5, 12, 6,  10, 0, 'UTC'),
select jonathan_wants_to_escape - mina_has_tea;
</code></pre>
<p>The output is the same: <code>{&lt;duration&gt;'1:25:00'}</code>. As long as we know the timezone, the <code>datetime</code> type does the work for us when we need a <code>duration</code>. </p>
<h2 id="casting-to-a-duration"><a class="header" href="#casting-to-a-duration">Casting to a duration</a></h2>
<p>Besides subtracting a <code>datetime</code> from another <code>datetime</code>, you can also just cast to make a <code>duration</code>. To do this, just write the number followed by the unit: <code>microseconds</code>, <code>milliseconds</code>, <code>seconds</code>, <code>minutes</code>, or <code>hours</code>. It will return a number including a number of seconds, or a more precise unit if necessary. For example, <code>select &lt;duration&gt;'2 hours';</code> will return <code>{&lt;duration&gt;'2:00:00'}</code>, and <code>select &lt;duration&gt;'2 microseconds';</code> will return <code>{&lt;duration&gt;'0:00:00.000002'}</code>.</p>
<p>You can include multiple units as well. For example:</p>
<pre><code class="language-edgeql">select &lt;duration&gt;'6 hours 6 minutes 10 milliseconds 678999 microseconds';
</code></pre>
<p>This will return <code>{&lt;duration&gt;'6:06:00.688999'}</code>.</p>
<p>EdgeDB is pretty forgiving when it comes to inputs when casting to a <code>duration</code>. It and will ignore plurals, will recognize abbreviations, and so on:</p>
<pre><code>edgedb&gt; select &lt;duration&gt;'2 milliseconds';
{&lt;duration&gt;'0:00:00.002'}
edgedb&gt; select &lt;duration&gt;'2 hour';
{&lt;duration&gt;'2:00:00'}
edgedb&gt; select &lt;duration&gt;'1 seconds';
{&lt;duration&gt;'0:00:01'}
edgedb&gt; select &lt;duration&gt;'1 H';
{&lt;duration&gt;'1:00:00'}
</code></pre>
<p>It even ignores symbols and irrelevant characters so even this horrible input will work:</p>
<pre><code class="language-edgeql">select &lt;duration&gt;'1 hours, 8 minute ** 5 second ()()()( //// 6 milliseconds'
     - &lt;duration&gt;'10 microsecond 7 minutes %%%%%%% 10 seconds 5 hour';
</code></pre>
<p>The result: <code>{&lt;duration&gt;'-3:59:04.99401'}</code>.</p>
<p>It won't just accept anything, however, so there is a limit:</p>
<pre><code>edgedb&gt; select &lt;duration&gt;'three howers';
edgedb error: InvalidValueError: invalid input syntax for type std::duration: 
&quot;three howers&quot;
</code></pre>
<h2 id="relative-duration"><a class="header" href="#relative-duration">Relative duration</a></h2>
<p>The scene in the book today takes place on the 16th of May, 15 days after Jonathan Harker left London. Jonathan Harker was kind enough to even mark down the time of day during his first journal entry, which gives us a good idea of how much time has gone by since then. Here are the two relevant journal entries:</p>
<pre><code>3 May. Bistritz.‚ÄîLeft Munich at 8:35 P. M., on 1st May, arriving at 
Vienna early next morning;
</code></pre>
<pre><code>The Morning of 16 May.‚ÄîGod preserve my sanity, for to this I am reduced...
All three had brilliant white teeth that shone like pearls against the 
ruby of their voluptuous lips. There was something about them that made
me uneasy, some longing and at the same time some deadly fear.
</code></pre>
<p>Let's imagine that our <code>PC</code> named Emil Sinclair has been accomplishing some missions during this time in order to build up experience and get involved with the events in the book. It would be nice to let the player know how much time has elapsed since the game started. If the player clock currently says 8:03:17 am right now, we can calculate the duration as we did just before:</p>
<pre><code class="language-edgeql">with
  game_start := to_datetime(1893, 5, 3, 20, 35, 0, 'UTC'),
  today      := to_datetime(1893, 5, 16, 8, 3, 17, 'EEST'),
select today - game_start;
</code></pre>
<p>That gives us a duration of <code>{&lt;duration&gt;'296:28:17'}</code>. That's very precise, but it would be nice to show the player these units in more readable units. EdgeDB added a type called <code>relative_duration</code> in 2021 to do exactly this. A relative_duration will show up when you add or subtract local dates and local datetimes. Here is a quick example:</p>
<pre><code class="language-edgeql">select &lt;cal::local_datetime&gt;'2023-05-18T08:00:00'
     - &lt;cal::local_datetime&gt;'2023-05-16T04:06:55';
</code></pre>
<p>This gives the output <code>{&lt;cal::relative_duration&gt;'P2DT3H53M5S'}</code>, which has done all the calculating for us and is easy to split up into parts. Adding a few spaces makes it easy to read: <code>P 2D T 3H 53M 5S</code>. In other words:</p>
<ul>
<li>P - period (i.e. a period of time). This is from the ISO8601 standard.</li>
<li>2D - two days</li>
<li>T - delimiter between days and time</li>
<li>3H = three hours</li>
<li>53M - 53 minutes</li>
<li>5S - 5 seconds</li>
</ul>
<p>So let's make a <code>relative_duration</code> for our <code>PC</code>. Here we will use a function called <code>cal::to_local_datetime</code> which turns a <code>datetime</code> into a <code>local_datetime</code> by entering the <code>datetime</code> to convert and the timezone we want it to show the time of.</p>
<p>The player is currently in Romania so we will choose the EEST timezone. The code looks like this:</p>
<pre><code class="language-edgeql">with
  game_start := to_datetime(1893, 5, 3, 20, 35, 0, 'UTC'),
  today      := to_datetime(1893, 5, 16, 8, 3, 17, 'EEST'),
  select
    cal::to_local_datetime(today, 'EEST') 
  - cal::to_local_datetime(game_start, 'EEST');
</code></pre>
<p>This gives us an output of <code>{&lt;cal::relative_duration&gt;'P12DT8H28M17S'}</code>. Perfect! Now our game can display something like <code>Time elapsed: 12 days, 8 hours, 28 minutes, 17 seconds</code> and we don't need to do any calculations to do so.</p>
<p>Another type called <code>date_duration</code> is useful when you only care about day to day duration. If we change the above code from <code>cal::to_local_datetime</code> to <code>cal::to_local_date</code> then we will cut off the time information and get a <code>date_duration</code> that only shows the number of days passed. So if we type this query:</p>
<pre><code class="language-edgeql">with
  game_start := to_datetime(1893, 5, 3, 20, 35, 0, 'UTC'),
  today      := to_datetime(1893, 5, 16, 8, 3, 17, 'EEST'),
  select 
    cal::to_local_date(today, 'EEST') 
  - cal::to_local_date(game_start, 'EEST');
</code></pre>
<p>We will get the output <code>{&lt;cal::date_duration&gt;'P13D'}</code>. So even though only about 12 days and 8 hours have gone by, in terms of changes to the date it is 13 days. Then we could add one to it and have this output for the character playing the game:</p>
<p><code>Day 14 of your quest...</code></p>
<h2 id="required-links"><a class="header" href="#required-links">Required links</a></h2>
<p>The three female vampires that Jonathan encounters this chapter are controlled by Count Dracula. They have their own thoughts but Dracula can control them if he wants, and they only exist because he exists. We'll need a new type for this sort of vampire, so let's call it <code>MinorVampire</code>. These have a link to the <code>Vampire</code> type, which needs to be <code>required</code>:</p>
<pre><code class="language-sdl">type MinorVampire extending Person {
  required master: Vampire;
}
</code></pre>
<p>Now let's do a migration to add <code>MinorVampire</code> to the schema.</p>
<p>With <code>master</code> as a <code>required</code> link, we can't insert a <code>MinorVampire</code> with just a name:</p>
<pre><code class="language-edgeql">insert MinorVampire {
  name := 'Vampire Woman 1' # We never find out their names in the book
};
</code></pre>
<p>Trying this insert will give us this error: <code>edgedb error: MissingRequiredError: missing value for required link 'master' of object type 'default::MinorVampire'</code>. This is what we want. Now let's insert the same <code>MinorVampire</code> but this time we will connect her to Dracula. This link is to a single object, which means that we should filter on the name 'Count Dracula' and then use the <code>assert_single()</code> function to ensure that <code>master</code> doesn't link to more than one object.</p>
<p>Our three <code>MinorVampire</code> inserts look like this:</p>
<pre><code class="language-edgeql">insert MinorVampire {
  name := 'Vampire Woman 1',
  master := assert_single((select Vampire filter .name = 'Count Dracula'))
};
insert MinorVampire {
  name := 'Vampire Woman 2',
  master := assert_single((select Vampire filter .name = 'Count Dracula'))
};
insert MinorVampire {
  name := 'Vampire Woman 3',
  master := assert_single((select Vampire filter .name = 'Count Dracula'))
};
</code></pre>
<p>Later on we will learn to add a constraint to ensure on the schema level that parameters like <code>name</code> have to be unique. And we will also learn how to insert three objects at the same time instead of doing three separate inserts like we did here.</p>
<h2 id="using-the-describe-keyword-to-look-inside-types"><a class="header" href="#using-the-describe-keyword-to-look-inside-types">Using the 'describe' keyword to look inside types</a></h2>
<p>Our <code>MinorVampire</code> type extends <code>Person</code>, and so does <code>Vampire</code>. Types can continue to extend other types, and they can extend more than one type at the same time. The more you do this, the harder it can be to try to picture it all together in your mind. Or you might be in the middle of using the REPL and don't want to switch to the schema file to get some information about a type. EdgeDB has a keyword called <code>describe</code> that can help in this case. There are four ways to use <code>describe</code>:</p>
<ul>
<li><code>describe type MinorVampire</code> - this will give the {ref}<code>DDL (data definition language) &lt;docs:ref_eql_ddl&gt;</code> description of a type. DDL is the lower level language that we have seen in our migration files that end in <code>.edgeql</code> such as 00001.edgeql, 00002.edgeql, and so on. If we type <code>describe type MinorVampire</code> into the REPL, we will see the following output:</li>
</ul>
<pre><code>{
  'create type default::MinorVampire extending default::Person {
    create required link master: default::Vampire;
};',
}
</code></pre>
<p>The <code>create</code> keyword shows that DDL is a series of quick commands, which is why the order is important. In other words, SDL is <em>declarative</em> (it <em>declares</em> what something will be without worrying about order), while DDL is <em>imperative</em> (it's a series of commands to change the state). Also, because it only shows the DDL commands to create it, it doesn't show us all the <code>Person</code> links and properties that it extends. So we probably don't want that. The next method is:</p>
<ul>
<li><code>describe type MinorVampire as sdl</code> - same thing, but in SDL.</li>
</ul>
<p>The output is almost the same too, just the SDL version of the above. It's also not enough information for what we want now:</p>
<pre><code>{
  'type default::MinorVampire extending default::Person {
    required master: default::Vampire;
};',
}
</code></pre>
<p>This output is basically the same as our SDL schema, just a bit more detailed when it comes to module paths: <code>type default::MinorVampire</code> instead of <code>type MinorVampire</code>, and so on.</p>
<ul>
<li>The third method is <code>describe type MinorVampire as text</code>. Now the output shows almost everything we need to know inside the type, including from the types that it extends. Here's the output:</li>
</ul>
<pre><code>{
  'type default::MinorVampire extending default::Person {
    required single link __type__: schema::Type {
        readonly := true;
    };
    optional single link lover: default::Person;
    required single link master: default::Vampire;
    optional multi link places_visited: default::Place;
    required single property id: std::uuid {
        readonly := true;
    };
    required single property name: std::str;
};',
}
</code></pre>
<p>If you want a bit more information, you can add the keyword <code>verbose</code> to make the command <code>describe type MinorVampire as text verbose</code>. This will look similar to the previous output, except it also includes constraints and annotations. (We'll learn about annotations in Chapter 14.) Here is the output:</p>
<pre><code>{
  'type default::MinorVampire extending default::Person {
    required single link __type__: schema::ObjectType {
        readonly := true;
    };
    optional single link lover: default::Person;
    required single link master: default::Vampire;
    optional multi link places_visited: default::Place;
    required single property id: std::uuid {
        readonly := true;
        constraint std::exclusive;
    };
    required single property name: std::str;
};',
}
</code></pre>
<p>The parts that say <code>readonly := true</code> are parts of each type that are automatically generated and which we can't change (hence the word <code>readonly</code>). The next part we want to scan for is <code>required</code>, giving us the minimum we need to create an object. For <code>MinorVampire</code>, we can see that we need a <code>name</code> and a <code>master</code>, and could add a <code>lover</code> and <code>places_visited</code> for these <code>MinorVampire</code>s.</p>
<p>The most interesting <code>readonly</code> part of an object is <code>__type__</code>, which is a link that every object type has to information about itself. We will learn more about this in Chapters 8 and 13, but if you are curious about what is inside then give it a try with the splat operator:</p>
<pre><code>select Person.__type__ {*};
</code></pre>
<p>For a <em>really</em> long output using <code>describe</code>, try typing <code>describe schema</code> or <code>describe module default</code> (with <code>as sdl</code> or <code>as text</code> if you want). You'll get an output showing the whole schema we've built so far.</p>
<p>So if we can use <code>describe</code> to learn about a <code>type</code> or our <code>schema</code>, are there other things we can describe? Indeed there are: we can describe an <code>object</code>, <code>annotation</code>, <code>constraint</code>, <code>function</code>, <code>link</code>, <code>module</code>, <code>property</code>, <code>scalar type</code>, or <code>type</code>.</p>
<p>If you don't want to remember them all, just go with <code>object</code>: it will match anything inside your schema (except modules). So <code>describe scalar type SleepState</code> and <code>describe object SleepState</code> will both return the same thing.</p>
<p><a href="chapter5/code.html">Here is all our code so far up to Chapter 5.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice-4"><a class="header" href="#time-to-practice-4">Time to practice</a></h2>
<ol>
<li>
<p>What do you think <code>select to_datetime(3600);</code> will return, and why?</p>
<p>Hint: check the function signatures above (or <a href="https://www.edgedb.com/docs/stdlib/datetime#function::std::to_datetime">in the docs</a>) and see which one EdgeDB will pick when you enter 3600.</p>
</li>
<li>
<p>Will <code>select &lt;int16&gt;9 + 1.06n is decimal;</code> work? And if it does, will it return <code>{true}</code>?</p>
</li>
<li>
<p>How many seconds went by between 5:00 am on Christmas Day 2003 in Turkmenistan (TMT) and 7:00 pm on New Year's Eve for the same year in Uzbekistan (UZT)?</p>
</li>
<li>
<p>The query <code>select &lt;datetime&gt;'2023-05-18T10:56:00+09:00' - &lt;datetime&gt;'2020-09-10T05:00:00+00:00';</code> returns <code>{&lt;duration&gt;'23516:56:00'}</code> which is hard to read. How can we display how many days have passed without having to do the math ourselves?</p>
</li>
<li>
<p>How would you write the same query using <code>with</code> for each of the two times?</p>
</li>
<li>
<p>What's the best way to describe a type if you only want to see how you wrote it?</p>
</li>
</ol>
<p><a href="chapter5/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>One of the women vampires to her sisters: &quot;He is young and strong; there are kisses for us all...&quot;</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="tags-updating-filtering-on-insert-json"><a class="header" href="#tags-updating-filtering-on-insert-json">tags: Updating, Filtering On Insert, Json</a></h2>
<h1 id="chapter-6---still-no-escape"><a class="header" href="#chapter-6---still-no-escape">Chapter 6 - Still no escape</a></h1>
<p>This chapter picks up right where the last one left off:</p>
<blockquote>
<p>The women vampires are next to Jonathan and he can't move. Suddenly, Dracula runs into the room and tells the women to leave. He yells: &quot;You can have him later, but not tonight!&quot; The women listen to him, and leave.</p>
<p>Jonathan doesn't remember anything else about that night. He wakes up in his bed the next day and it feels like a bad dream...but he sees that somebody folded his clothes, and he knows it was not just a dream.</p>
<p>The castle has some visitors from Slovakia the next day, which gives Jonathan an idea. He writes two letters, one to Mina and one to his manager at work. He gives the visitors some money, asks them to send the letters, and runs back to his room. But Dracula finds the letters and is angry. He burns the letters in front of Jonathan and tells him not to do that again. Jonathan is still stuck in the castle, and Dracula knows that Jonathan tried to trick him.</p>
</blockquote>
<h2 id="updating-and-filtering-on-sets-when-doing-an-insert"><a class="header" href="#updating-and-filtering-on-sets-when-doing-an-insert">Updating and filtering on sets when doing an insert</a></h2>
<p>There is not much new in this lesson when it comes to types, so let's work on our schema and inserts a bit. Right now Jonathan Harker is still inserted like this:</p>
<pre><code class="language-edgeql">insert NPC {
  name := 'Jonathan Harker',
  places_visited := City,
};
</code></pre>
<p>This was fine when we only had cities, but now we have the <code>Place</code> and <code>Country</code> types. First we'll insert two more <code>Country</code> types to have some more variety:</p>
<pre><code class="language-edgeql">insert Country { name := 'France' };
insert Country { name := 'Slovakia' };
</code></pre>
<p>(In Chapter 9 we'll learn how to do this with just one <code>insert</code>!)</p>
<p>Then we'll make two new types called <code>Castle</code> and <code>OtherPlace</code>. <code>Castle</code> will be used for castles and castle towns, and <code>OtherPlace</code> for any other kind of place. They are super easy to make:</p>
<pre><code class="language-sdl">type Castle extending Place;
type OtherPlace extending Place;
</code></pre>
<p>Put that into the schema and do a migration, and now we can insert our first <code>Castle</code>:</p>
<pre><code class="language-edgeql">insert Castle {
  name := 'Castle Dracula'
};
</code></pre>
<p>We will insert some <code>OtherPlace</code> objects later on in the book. Now we have a good number of types from <code>Place</code> that aren't of the <code>City</code> type.</p>
<p>Now let's get back to Jonathan. In our database, he's been to four cities, one country, and one <code>Castle</code>...but he hasn't been to Slovakia or France, so we can't just insert him with <code>places_visited := select Place</code>. Instead, we can filter on <code>Place</code> against a set with the names of the places he has visited. If we were inserting Jonathan Harker for the first time, it would look like this:</p>
<pre><code class="language-edgeql">insert NPC {
  name := 'Jonathan Harker',
  places_visited := (
    select Place filter .name in {'Munich', 'Buda-Pesth', 'Bistritz', 
    'London', 'Romania', 'Castle Dracula'}
  )
};
</code></pre>
<pre><code class="language-{eval-rst}">.. note::
  You'll notice that we just wrote the names in a set using {}, so we didn't need to use an array with [] to do it. (This is called a {ref}`set constructor &lt;docs:ref_eql_set_constructor&gt;`, by the way.)
</code></pre>
<p>But we already have a Jonathan Harker in the database. We could always do a quick <code>delete NPC filter .name = 'Jonathan Harker'</code> before doing this insert, but that's not ideal. Instead, we should do an update. For that we have the <code>update</code> and <code>set</code> keywords. The <code>update</code> keyword selects the type to start the update, and <code>set</code> is used to specify the parts that we want to change. We'll also want to use <code>filter</code> to make sure that we are only updating the <code>NPC</code> object named Jonathan Harker, and not every single <code>NPC</code> object in the database.</p>
<p>So let's update Jonathan with this code instead:</p>
<pre><code class="language-edgeql">update NPC 
filter .name = 'Jonathan Harker'
set {
  places_visited := (
    select Place filter .name in 
    {'Munich', 'Buda-Pesth', 'Bistritz', 'London', 'Romania', 'Castle Dracula'}
  )
};
</code></pre>
<p>Now what if Jonathan ever escapes Castle Dracula and runs away to a new place? Let's pretend that the <code>PC</code> named Emil Sinclair changed the flow of the story by saving Jonathan and taking him away to Slovakia. In that case, we could select the <code>Place</code> object and use <code>+=</code> to add it to Jonathan's <code>places_visited</code> property:</p>
<pre><code class="language-edgeql">update NPC
filter .name = 'Jonathan Harker'
set {
  places_visited += (select Place filter .name = 'Slovakia')
};
</code></pre>
<p>And to undo this change, you can just change <code>+=</code> to <code>-=</code> and run the command again. Let's do that, because Jonathan Harker doesn't ever actually end up visiting Slovakia.</p>
<p>EdgeDB will return the IDs of the objects that have been updated. In our case, it's just one:</p>
<pre><code>{default::NPC {id: ca4e21c8-014f-11ec-9658-7f88bf45dae6}}
</code></pre>
<p>However, this doesn't mean that <code>places_visited</code> has been changed. If we had written something like <code>filter .name = 'SLLLovakia'</code> then the <code>set</code> portion of the update would have simply added an empty <code>{}</code> set to <code>places_visited</code>, because nothing matched the filter there. The returned <code>default::NPC</code> simply means that an <code>NPC</code> object was found that matched <code>filter .name = 'Jonathan Harker</code>, and that <em>something</em> was done to it. But in this case, the <em>something</em> was the addition of an empty set to an existing set, so nothing at all.</p>
<p>One quick way to ensure that <code>places_visited</code> is actually being updated with something is to use the <code>assert_exists</code> function. This function will pass on the output if it exists, but give an error if the output is an empty set. Here is the same <code>update</code> with the incorrect name 'SLLLovakia', which will now give an error:</p>
<pre><code class="language-edgeql">update NPC
filter .name = 'Jonathan Harker'
set {
  places_visited += assert_exists((select Place filter .name = 'SLLovakia'))
};
</code></pre>
<p>Here is the output now:</p>
<pre><code>edgedb error: CardinalityViolationError: assert_exists violation:
expression returned an empty set
</code></pre>
<p>With that we now know {ref}<code>all three operators &lt;docs:ref_eql_statements_update&gt;</code> used after <code>set</code>: <code>:=</code>, <code>+=</code>, and <code>-=</code>.</p>
<p>Let's do another update. Remember the <code>lover</code> link on the <code>Person</code> type? Let's take a look at Jonathan and see how his love life is doing.</p>
<pre><code class="language-edgeql">select Person {
  name,
  lover
} filter .name = 'Jonathan Harker';
</code></pre>
<p>Here's the output:</p>
<pre><code>{default::NPC {name: 'Jonathan Harker', lover: {}}}
</code></pre>
<p>Ah, that's right. Mina Murray has Jonathan Harker as her <code>lover</code>, but Jonathan doesn't have her as his <code>lover</code> because we inserted him first before Mina Murray was inserted. We can change that now.</p>
<p>This command seems like it will work, but it doesn't quite. Do you remember why?</p>
<pre><code class="language-edgeql">update Person filter .name = 'Jonathan Harker'
set {
  lover := assert_single(
    (select Person filter .name = 'Mina Murray')
  )
};
</code></pre>
<p>No error is generated, but let's look at Jonathan Harker after the update:</p>
<pre><code class="language-edgeql">select Person { name, lover } filter .name = 'Jonathan Harker';
</code></pre>
<p>Surprisingly, the output is <code>{default::NPC {name: 'Jonathan Harker', lover: {}}}</code>!</p>
<p>After a bit of thought, we remember that we learned the <code>detached</code> keyword in Chapter 4 when inserting Mina. At the time we got the following error when we trie to insert Mina without using <code>detached</code>:</p>
<pre><code>error: QueryError: invalid reference to default::NPC: 
self-referencing INSERTs are not allowed
  ‚îå‚îÄ &lt;query&gt;:3:20
  ‚îÇ
3 ‚îÇ   lover := (select NPC filter .name = 'Jonathan Harker'),
  ‚îÇ                    ^^^ Use DETACHED if you meant to refer 
  to an uncorrelated default::NPC set
</code></pre>
<p>However, this time an error wasn't generated because we are doing an update, not an insert. Let's investigate exactly what happens here when <code>detached</code> doesn't get used.</p>
<p>First we'll do a quick <code>select</code> to see what's going on. We'll select Jonathan Harker and also add a computed <code>lover := (select Person filter .name = 'Mina Murray')</code> inside the shape to see what shows up:</p>
<pre><code class="language-edgeql">select Person {
 name,
 lover := (select Person filter .name = 'Mina Murray')
 } filter .name = 'Jonathan Harker';
</code></pre>
<p>Again, the output is <code>{default::NPC {name: 'Jonathan Harker', lover: {}}}</code>. That in itself is a hint that something didn't work properly. Let's try another <code>select</code>. This time we will simply make <code>lover</code> into a <code>(select Person {name})</code> to see everything that shows up before the filter. The query now looks like this:</p>
<pre><code class="language-edgeql">select Person {
 name,
 lover := (select Person {name})
 } filter .name = 'Jonathan Harker';
</code></pre>
<p>This time, the output is <em>very</em> interesting: <code>{default::NPC {name: 'Jonathan Harker', lover: default::NPC {name: 'Jonathan Harker'}}}</code>. This output proves that the <code>select Person</code> inside this query effectively means to select the <code>Person</code> object or objects that have already been selected! And we can't find the <code>Person</code> object called Mina if our set of <code>Person</code> objects only includes Jonathan Harker.</p>
<p>We can see the same behaviour if we remove the <code>filter</code>:</p>
<pre><code class="language-edgeql">select Person {
  name,
  lover_name := (select Person.name)
 };
</code></pre>
<p>There it is again: each time we use <code>select</code> without <code>detached</code> we are simply selecting the <code>Person</code> object in question, and not a full set of all the <code>Person</code> objects in the database.</p>
<pre><code>{
  default::MinorVampire {name: 'Vampire Woman 1', lover_name: 'Vampire Woman 1'},
  default::MinorVampire {name: 'Vampire Woman 2', lover_name: 'Vampire Woman 2'},
  default::MinorVampire {name: 'Vampire Woman 3', lover_name: 'Vampire Woman 3'},
  default::NPC {name: 'The innkeeper', lover_name: 'The innkeeper'},
  default::NPC {name: 'Mina Murray', lover_name: 'Mina Murray'},
  default::NPC {name: 'Jonathan Harker', lover_name: 'Jonathan Harker'},
  default::Vampire {name: 'Count Dracula', lover_name: 'Count Dracula'},
  default::PC {name: 'Emil Sinclair', lover_name: 'Emil Sinclair'},
}
</code></pre>
<p>So now let's do the update properly with the <code>detached</code> keyword so that Jonathan can finally be connected to Mina. (After all, he has enough to worry about without needing to think about this too.)</p>
<pre><code class="language-edgeql">update Person filter .name = 'Jonathan Harker'
set {
  lover := assert_single(
    (select detached Person filter .name = 'Mina Murray')
  )
};
</code></pre>
<p>And now <code>select</code> query now to make sure that it worked:</p>
<pre><code class="language-edgeql">select Person {
  name, 
  lover: {name}
  } filter .name = 'Jonathan Harker';
</code></pre>
<p>The output is now as follows:</p>
<pre><code>{default::NPC {name: 'Jonathan Harker', lover: default::NPC {name: 'Mina Murray'}}}
</code></pre>
<p>Success!</p>
<p>Now, if you use <code>update</code> without <code>filter</code> it will do the same change on all the types. This update below for example would give every <code>Person</code> type every single <code>Place</code> in the database under <code>places_visited</code>:</p>
<pre><code class="language-edgeql">update Person
set {
  places_visited := Place
};
</code></pre>
<h2 id="concatenation-with-"><a class="header" href="#concatenation-with-">Concatenation with ++</a></h2>
<p>One operator we haven't seen before is <code>++</code>, which does concatenation (joining together) instead of adding.</p>
<p>You can do simple operations with it like: <code>select 'My name is ' ++ 'Jonathan Harker';</code> which gives <code>{'My name is Jonathan Harker'}</code>. Or you can do more complicated concatenations as long as you continue to join strings to strings:</p>
<pre><code class="language-edgeql">select 'A character from the book: ' ++ (select NPC.name) 
       ++ ', who is not ' ++ (select Vampire.name);
</code></pre>
<p>This prints:</p>
<pre><code>{
  'A character from the book: The innkeeper, who is not Count Dracula',
  'A character from the book: Mina Murray, who is not Count Dracula',
  'A character from the book: Jonathan Harker, who is not Count Dracula',
}
</code></pre>
<p>The concatenation operator works on arrays too, putting them into a single array. So the output of:</p>
<pre><code class="language-edgeql">select ['I', 'am'] ++ ['Jonathan', 'Harker'];
</code></pre>
<p>Will be:</p>
<pre><code>{['I', 'am', 'Jonathan', 'Harker']}
</code></pre>
<p>The last type that the concatenation operator works on is <code>bytes</code>.</p>
<h2 id="using-insert-instead-of-select-when-adding-links"><a class="header" href="#using-insert-instead-of-select-when-adding-links">Using <code>insert</code> instead of <code>select</code> when adding links</a></h2>
<p>Let's also change the <code>Vampire</code> type to link it to <code>MinorVampire</code> from that side instead. You'll remember that Count Dracula is the only real vampire, while the others are of type <code>MinorVampire</code>. In the book, any person that Dracula bites becomes his slave. And once they die, they become another vampire that lives forever that Dracula can control with his mind (that's what makes the book scary). That means we need a <code>multi</code> link:</p>
<pre><code class="language-sdl">type Vampire extending Person {
  age: int16;
  multi slaves: MinorVampire;
}
</code></pre>
<p>Then we can <code>insert</code> the <code>MinorVampire</code> type at the same time as we insert the information for Count Dracula. But first let's remove the <code>master</code> link from <code>MinorVampire</code>, because it is a bit awkward to have objects linking to each other in this way. There are two reasons for that:</p>
<p>Extra work: A <code>MinorVampire</code> needs to have a <code>master</code> link, which means the order goes as follows:</p>
<ul>
<li>Insert the <code>Vampire</code> object Count Dracula.</li>
<li>Insert the <code>MinorVampire</code> objects that link to Count Dracula.</li>
<li>Count Dracula's <code>slaves</code> link is an empty set though, because nothing is linking him to the <code>MinorVampire</code> objects. Now we have to <code>update</code> him just to link back!</li>
</ul>
<p>Deletion: If both types link to each other, we won't be able to delete them if we need to. The error looks something like this:</p>
<pre><code>db&gt; delete MinorVampire;
  ERROR: ConstraintViolationError: deletion of default::MinorVampire
  (ee6ca100-006f-11ec-93a9-4b5d85e60114) is prohibited by link target policy
  Detail: Object is still referenced in link slave of default::Vampire
  (e5ef5bc6-006f-11ec-93a9-77e907d251d6).
db&gt; delete Vampire;
ERROR: ConstraintViolationError: deletion of default::Vampire
  (e5ef5bc6-006f-11ec-93a9-77e907d251d6) is prohibited by link target policy
  Detail: Object is still referenced in link master of default::MinorVampire (ee6ca100-006f-11ec-93a9-4b5d85e60114).
</code></pre>
<p>There are two options for working with this known as <em>backlinks</em> and <em>deletion policies</em>, which we will learn in chapters 14 and 18. With backlinks we can give <code>MinorVampire</code> a link based on what links <em>to</em> it, and with deletion policies we can change the rules on what can be deleted or not. But we aren't learning advanced concepts just yet so let's just keep things simple by just linking one way.</p>
<p>So first we simply change <code>MinorVampire</code> to a type extending <code>Person</code>:</p>
<pre><code class="language-sdl">type MinorVampire extending Person;
</code></pre>
<p>And then do a migration.</p>
<p>We said we would leave Dracula alone after all the practice deleting him before...but let's delete him again. Let's also delete the <code>MinorVampire</code> objects so that we can practise inserting them all at the same time.</p>
<p>So how do we link a <code>Vampire</code> object to a <code>MinorVampire</code> object if there are no <code>MinorVampire</code> objects to select? Quite easy: just <code>insert</code> them and keep their inserts inside a set with <code>{}</code>. Remember: using <code>select</code> will return a set of objects, but <code>insert</code> returns one or more objects too. So if we capture the output of <code>insert</code>, we can just declare these objects as the objects to link to.</p>
<p>Here's what the insert looks like:</p>
<pre><code class="language-edgeql">insert Vampire {
  name := 'Count Dracula',
  age := 800,
  slaves := {
    (insert MinorVampire {
      name := 'Vampire Woman 1',
    }),
    (insert MinorVampire {
      name := 'Vampire Woman 2',
    }),
    (insert MinorVampire {
      name := 'Vampire Woman 3',
    }),
  }
};
</code></pre>
<p>Now we don't have to insert the <code>MinorVampire</code> types first and then filter: we can just put them in together with Dracula.</p>
<p>Then when we <code>select Vampire</code> like this:</p>
<pre><code class="language-edgeql">select Vampire {
  name,
  slaves: {name}
};
</code></pre>
<p>We have a nice output that shows them all together:</p>
<pre><code>{
  default::Vampire {
    name: 'Count Dracula',
    slaves: {
      default::MinorVampire {name: 'Vampire Woman 1'},
      default::MinorVampire {name: 'Vampire Woman 2'},
      default::MinorVampire {name: 'Vampire Woman 3'},
    },
  },
}
</code></pre>
<p>Speaking of output, EdgeDB lets you display your output in a number of different ways. One of them is JSON!</p>
<h2 id="just-type-json-to-generate-json"><a class="header" href="#just-type-json-to-generate-json">Just type &lt;json&gt; to generate json</a></h2>
<p>What do we do if we want to see output in JSON? It couldn't be easier: just cast using <code>&lt;json&gt;</code>. Any type in EdgeDB can be cast to JSON this easily:</p>
<pre><code class="language-edgeql"># &lt;json&gt; is the only difference from the select above
select &lt;json&gt;Vampire {
  name,
  slaves: {name}
};
</code></pre>
<p>This will transform the results into JSON. However, what the REPL will show by default looks more like this:</p>
<pre><code>{
  Json(&quot;{\&quot;name\&quot;: \&quot;Count Dracula\&quot;, \&quot;slaves\&quot;: [{\&quot;name\&quot;: \&quot;Vampire Woman 1\&quot;}, {\&quot;name\&quot;: \&quot;Vampire Woman 2\&quot;}, {\&quot;name\&quot;: \&quot;Vampire Woman 3\&quot;}]}&quot;),
}
</code></pre>
<p>Let's go through the result together. The outer curly braces are just telling you that what's inside is one or more results returned by the query. Then the actual result is a string containing JSON. Because the JSON part is inside a string all the <code>&quot;</code> there need to be escaped, so they appear as <code>\&quot;</code>.</p>
<p>That's a great JSON output for computers to handle, but it's a little bit ugly for us. Fortunately we can change this: to make the REPL show JSON in a nicer format just type <code>\set output-format json-pretty</code>. Then the results will look more familiar:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;Count Dracula&quot;,
  &quot;slaves&quot;: [{&quot;name&quot;: &quot;Vampire Woman 1&quot;}, {&quot;name&quot;: &quot;Vampire Woman 2&quot;}, {&quot;name&quot;: &quot;Vampire Woman 3&quot;}]
}
</code></pre>
<p>Now to get back to the default format, we can type <code>\set output-format default</code>.
To keep things easy to read, this book will show JSON output using this <code>json-pretty</code> output format.</p>
<h2 id="converting-back-from-json"><a class="header" href="#converting-back-from-json">Converting back from JSON</a></h2>
<p>So what about the other way around, namely JSON to an EdgeDB type? You can do this too, but remember to think about the JSON type that you are giving to cast. The EdgeDB philosophy is that casts should be symmetrical: a type cast into JSON should only be cast back into that type. For example, here is the first date in the book Dracula as a string, then cast to JSON and then into a <code>cal::local_date</code>:</p>
<pre><code class="language-edgeql">select &lt;cal::local_date&gt;&lt;json&gt;'18930503';
</code></pre>
<p>This is fine because <code>&lt;json&gt;</code> turns it into a JSON string, and <code>cal::local_date</code> can be created from a string. The result we get is <code>{&lt;cal::local_date&gt;'1893-05-03'}</code>. But if we try to turn the JSON value into an <code>int64</code>, it won't work:</p>
<pre><code class="language-edgeql">select &lt;int64&gt;&lt;json&gt;'18930503';
</code></pre>
<p>The problem is that it is a conversion from a JSON string to an EdgeDB <code>int64</code>. It gives this error: <code>edgedb error: InvalidValueError: expected JSON number or null; got JSON string</code>. To keep things symmetrical, you need to cast a JSON string to an EdgeDB <code>str</code> and then cast into an <code>int64</code>:</p>
<pre><code class="language-edgeql">select &lt;int64&gt;&lt;str&gt;&lt;json&gt;'18930503';
</code></pre>
<p>Now it works: we get <code>{18930503}</code> which began as an EdgeDB <code>str</code>, turned into a JSON string, then back into an EdgeDB <code>str</code>, and finally was cast into an <code>int64</code>.</p>
<p>The {ref}<code>documentation on JSON &lt;docs:ref_std_json&gt;</code> explains which JSON types turn into which EdgeDB types, lists functions for working with JSON values, and is good to bookmark if you need to convert from JSON a lot. Here is a simplified explanation from the documentation:</p>
<ul>
<li>JSON strings can be cast to a <code>str</code>. Casting uuid and date/time types to JSON returns a JSON string. You can cast back into those types, as long as the formatting is correct.</li>
<li>JSON numbers can be cast to any numeric type.</li>
<li>JSON booleans can be cast to a bool type.</li>
<li>JSON null is unique because it can be cast to an empty set ({}) of any type.</li>
<li>JSON arrays can be cast to any valid array type, but its items must be all the same time, the array cannot contain null, and it can't contain another array.</li>
</ul>
<p>One quick way to turn JSON into a more usable form is to use the <code>json_object_unpack()</code> function, which returns a set of <code>tuple&lt;str, json&gt;</code>.</p>
<p>We will learn a lot more about tuples in Chapter 10, but for now just remember that they use <code>()`` parentheses, can contain different types, and that you access their items by using a dot. So this query will return </code>{10}`:</p>
<pre><code class="language-edgeql">select ('Jonathan Harker', 10).1;
</code></pre>
<p>Now let's look at the <code>json_object_unpack()</code> function with a simple query:</p>
<pre><code class="language-edgeql">with json_dracula := &lt;json&gt;(select Vampire {*}),
  select json_object_unpack(json_dracula);
</code></pre>
<p>The output will look as follows:</p>
<pre><code>{
  ('id', Json(&quot;\&quot;3bc8e902-19d9-11ee-92bf-b3c5cf277bc7\&quot;&quot;)),
  ('age', Json(&quot;800&quot;)),
  ('name', Json(&quot;\&quot;Count Dracula\&quot;&quot;)),
  ('is_single', Json(&quot;true&quot;)),
}
</code></pre>
<p>Change the splat operator from <code>*</code> to <code>**</code> and it gets even more verbose!</p>
<pre><code>{
  ('id', Json(&quot;\&quot;3bc8e902-19d9-11ee-92bf-b3c5cf277bc7\&quot;&quot;)),
  ('age', Json(&quot;800&quot;)),
  ('name', Json(&quot;\&quot;Count Dracula\&quot;&quot;)),
  ('lover', Json(&quot;null&quot;)),
  (
    'slaves',
    Json(&quot;[
      {\&quot;id\&quot;: \&quot;3bc8f1b8-19d9-11ee-92bf-1bd2fcb94b84\&quot;, \&quot;name\&quot;: \&quot;Vampire Woman 1\&quot;, \&quot;is_single\&quot;: true}, 
      {\&quot;id\&quot;: \&quot;3bc8fc08-19d9-11ee-92bf-0f167ba34818\&quot;, \&quot;name\&quot;: \&quot;Vampire Woman 2\&quot;, \&quot;is_single\&quot;: true}, 
      {\&quot;id\&quot;: \&quot;3bc8fcee-19d9-11ee-92bf-cfa75bcb2757\&quot;, \&quot;name\&quot;: \&quot;Vampire Woman 3\&quot;, \&quot;is_single\&quot;: true}]&quot;),
  ),
  ('is_single', Json(&quot;true&quot;)),
  ('places_visited', Json(&quot;[]&quot;)),
}
</code></pre>
<p>There are quite a few other functions related to JSON in the documentation, so do take a look if you need to work with JSON in some other way. Some of the functions include <code>json_array_unpack()</code>, <code>json_get()</code>, <code>json_set()</code>, <code>json_typeof()</code>, and <code>json_object_pack()</code>.</p>
<p><a href="chapter6/code.html">Here is all our code so far up to Chapter 6.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice-5"><a class="header" href="#time-to-practice-5">Time to practice</a></h2>
<ol>
<li>
<p>This select is incomplete. How would you complete it so that it says &quot;Pleased to meet you. I'm &quot; and then the NPC's name followed by a period?</p>
<pre><code class="language-edgeql">select NPC {
  name,
  greeting := ## Put the rest here
};
</code></pre>
</li>
<li>
<p>How would you update Mina's <code>places_visited</code> to include Romania if she went to Castle Dracula for a visit?</p>
</li>
<li>
<p>With the set <code>{'W', 'J', 'C'}</code>, how would you display all the <code>Person</code> types with a name that contains any of these capital letters?</p>
<p>Hint: it involves <code>with</code> and a bit of concatenation.</p>
</li>
<li>
<p>How would you display this same query as JSON?</p>
</li>
<li>
<p>How would you add ' the Great' to every Person type?</p>
<p>Bonus question: what's a quick way to undo this using string indexing?</p>
</li>
</ol>
<p><a href="chapter6/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>Jonathan climbs the castle wall to get into the Count's room.</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="tags-constraint-delegation--parameters"><a class="header" href="#tags-constraint-delegation--parameters">tags: Constraint Delegation, $ Parameters</a></h2>
<h1 id="chapter-7---jonathan-finally-leaves-the-castle"><a class="header" href="#chapter-7---jonathan-finally-leaves-the-castle">Chapter 7 - Jonathan finally &quot;leaves&quot; the castle</a></h1>
<blockquote>
<p>Jonathan sneaks into Dracula's room during the day and sees him sleeping inside a coffin. Now Jonathan knows that Count Dracula is a vampire.</p>
<p>A few days later Count Dracula comes with some news. He tells Jonathan that he will leave the castle tomorrow, and that Jonathan's stay at the castle has also come to an end. Jonathan thinks this is a chance, and asks to leave now instead of tomorrow.</p>
<p>Dracula says, &quot;Fine, if you wish...&quot; and opens the door, but there are a lot of wolves outside, howling and getting ready to attack. Dracula smiles and begins to open the door as he says, &quot;You are free to leave! Goodbye!&quot; Jonathan knows that Dracula called the wolves, and panics. &quot;Shut the door! I shall wait till morning!&quot; says Jonathan. Dracula laughs, slams the door shut and walks away.</p>
<p>Later, Jonathan hears Dracula tell the vampire women they can have Jonathan once he is alone in the castle. Some workers come to take Dracula away inside a coffin the next day, and Jonathan is alone...and soon it will be night. All the doors are locked. Jonathan has no choice and decides to climb out the window. It is better to die by falling than to be alone with the vampire women.</p>
<p>After writing &quot;Good-bye, all! Mina!&quot; in his journal, Jonathan begins to climb the wall.</p>
</blockquote>
<h2 id="more-constraints-and-simple-ordering"><a class="header" href="#more-constraints-and-simple-ordering">More constraints and simple ordering</a></h2>
<p>While Jonathan climbs the wall, we can continue to work on our database schema. Let's give it some more constraints so that we are sure what data is acceptable and what is not.</p>
<p>No character in our book has the same name, so so there should only be one Mina Murray, one Count Dracula, and so on. No <code>PC</code> object should have the same name either: imagine that you created a <code>PC</code> to play the game but the next day someone else shows up with the same name as you! Even worse, any <code>update</code> done to a <code>PC filter .name = your_name</code> might end up updating both characters at the same time.</p>
<p>To avoid this, we can put a {ref}<code>constraint &lt;docs:ref_datamodel_constraints&gt;</code> on <code>name</code> in the <code>Person</code> type to make sure that we don't have duplicate inserts. A <code>constraint</code> is a limitation, which we saw already in <code>age</code> for humans that can only go up to 120:</p>
<p><code>constraint max_value(120);</code></p>
<p>We can give <code>name</code> a constraint too called <code>constraint exclusive</code> which prevents two objects of the same type from having the same value - in this case, a name. Like the other constraint we added, you put <code>constraint</code> in a block after the property, like this:</p>
<pre><code class="language-sdl">abstract type Person {
  required name: str {      # Add a block
      constraint exclusive; # and the constraint
  }
  multi places_visited: Place;
  lover: Person;
}
</code></pre>
<p>With this constraint added, we now know that there will only be one <code>Jonathan Harker</code>, one <code>Mina Murray</code>, and so on. In real life this is often useful for email addresses, User IDs, and other properties that you always want to be unique. In our database we'll also add <code>constraint exclusive</code> to <code>name</code> inside <code>Place</code> because these places are also all unique:</p>
<pre><code class="language-sdl">abstract type Place {
  required name: str {
      constraint exclusive;
  };
  modern_name: str;
  important_places: array&lt;str&gt;;
}
</code></pre>
<p>We are going to do a migration now, but first let's insert an object that will violate the <code>exclusive</code> constraint. Remember the innkeeper from the city of Bistritz? Let's add him again:</p>
<pre><code class="language-edgeql">insert NPC { name := 'The innkeeper' };
</code></pre>
<p>Great! Now our migration is going to fail. However, <code>edgedb migration create</code> will work, because this simply creates the commands to carry out the migration. After that comes <code>migration create</code>, which is when the database will apply the constraint to the existing objects. Fortunately, the output will tell us what has gone wrong:</p>
<pre><code>edgedb error: ConstraintViolationError: name violates exclusivity constraint
  Detail: property 'name' of object type 'default::NPC' violates exclusivity constraint
edgedb error: error in one of the migrations
</code></pre>
<p>&quot;Property 'name' of object type 'default::NPC' violates exclusivity constraint&quot; is a pretty clear error message.</p>
<pre><code class="language-edgeql">select NPC { name };
</code></pre>
<p>The output shows us that there are two <code>NPC</code> objects called 'The innkeeper', which is not okay in our new schema.</p>
<pre><code>{
  default::NPC {name: 'The innkeeper'},
  default::NPC {name: 'Mina Murray'},
  default::NPC {name: 'Jonathan Harker'},
  default::NPC {name: 'The innkeeper'},
}
</code></pre>
<p>We are going to have to delete one, but let's order those results first. After all, there could have been 10 or 20 or more objects and trying to find a duplicate name would have been pretty tough.</p>
<p>Ordering is pretty easy: just add <code>order by</code> and the property to order by: </p>
<pre><code class="language-edgeql">select NPC { name } order by .name;
</code></pre>
<p>Now the output shows 'The innkeeper' right next to the other object of the same name.</p>
<pre><code>{
  default::NPC {name: 'Jonathan Harker'},
  default::NPC {name: 'Mina Murray'},
  default::NPC {name: 'The innkeeper'},
  default::NPC {name: 'The innkeeper'},
}
</code></pre>
<p>We will learn more about ordering in Chapter 10. But in the meantime, let's get back to our duplicate objects so we can delete one. They are identical in every way except their <code>id</code>, so let's find out what they are:</p>
<pre><code>select NPC { id } filter .name = 'The innkeeper';
</code></pre>
<p>Your <code>id</code> values will be different, but the output will look like this:</p>
<pre><code>{
  default::NPC {id: ebe395c4-19cc-11ee-bae7-f7a7bff901b9},
  default::NPC {id: dbb3bb4c-19e6-11ee-9981-03a7bead0c6b},
}
</code></pre>
<p>And now we'll just pick one id, put it inside a <code>str</code> and cast it to a <code>uuid</code> as a filter to delete the one <code>NPC</code> object. </p>
<pre><code class="language-edgedb">delete NPC filter .id = &lt;uuid&gt;'ebe395c4-19cc-11ee-bae7-f7a7bff901b9';
</code></pre>
<p>With the offending object gone, the <code>edgedb migrate</code> command now works!</p>
<h2 id="passing-constraints-with-delegated"><a class="header" href="#passing-constraints-with-delegated">Passing constraints with delegated</a></h2>
<p>Now that our <code>Person</code> type has <code>constraint exclusive</code> for the property <code>name</code>, no type extending <code>Person</code> will be able to have the same name. That's fine for our game in this tutorial, because we already know all the character names in the book and won't be making many real <code>PC</code> type objects. But what if we later on wanted to make a <code>PC</code> named Jonathan Harker? Right now it wouldn't be allowed because we have an <code>NPC</code> with the same name, and <code>NPC</code> takes <code>name</code> from <code>Person</code>.</p>
<p>Fortunately there's an easy way to get around this: by putting the keyword <code>delegated</code> in front of <code>constraint</code>. That &quot;delegates&quot; (passes on) the constraint to the subtypes, so that the check for exclusivity will be done individually for <code>PC</code>, <code>NPC</code>, <code>Vampire</code>, and so on. That makes the <code>Person</code> type exactly the same except for the <code>delegated</code> keyword:</p>
<pre><code class="language-sdl">abstract type Person {
  required name: str {
    delegated constraint exclusive;
  }
  multi places_visited: Place;
  lover: Person;
  strength: int16;
}
</code></pre>
<p>With that you can have up to one Jonathan Harker the <code>PC</code>, the <code>NPC</code>, the <code>Vampire</code>, and anything else that extends <code>Person</code>.</p>
<p>The <code>delegated constraint</code> should also apply to <code>Place</code> since a <code>Country</code> can have the same name as <code>City</code>, and so on for any other types that will extend <code>Place</code>. So let's update the constraint on the <code>name</code> property for the <code>Place</code> type to add <code>delegated</code> there too.</p>
<pre><code class="language-sdl">abstract type Place {
  required name: str {
      delegated constraint exclusive;
  };
  modern_name: str;
  important_places: array&lt;str&gt;;
}
</code></pre>
<h2 id="using-functions-in-queries"><a class="header" href="#using-functions-in-queries">Using functions in queries</a></h2>
<p>Let's also think about our game mechanics a bit. The book says that the doors inside the castle are too tough for Jonathan to open, but Dracula is strong enough to open them all. In a real game it would be more complicated but we can try something simple to mimic this:</p>
<ul>
<li>Doors have a strength, and people have strength as well.</li>
<li>A <code>Person</code> with greater strength than the door will be able to open it.</li>
</ul>
<p>So we will change our <code>Castle</code> type to give it some doors. For now we only want to give it some &quot;strength&quot; numbers, so we'll just make it an <code>array&lt;int16&gt;</code>:</p>
<pre><code class="language-sdl">type Castle extending Place {
    doors: array&lt;int16&gt;;
}
</code></pre>
<p>Then we will also add a <code>strength: int16;</code> to our <code>Person</code> type. This property won't be <code>required</code> because we don't know the strength of everybody in the book. Plus, if we made it a <code>required</code> property, we would have to choose a default strength for every <code>Person</code> object that we already have.</p>
<p>Now it's time to do an insert. We'll imagine that there are three main doors to enter and leave Castle Dracula. First let's update the schema with <code>edgedb migration create</code> and <code>edgedb migrate</code> as usual.</p>
<p>Now we have to add the doors to Castla Dracula, so let's update it:</p>
<pre><code class="language-edgeql">update Castle filter .name = 'Castle Dracula'
  set {
    doors := [6, 9, 10]
  };
</code></pre>
<p>Now we'll give Jonathan a strength of 5. That's another easy <code>update</code>:</p>
<pre><code class="language-edgeql">update Person filter .name = 'Jonathan Harker'
set {
  strength := 5
};
</code></pre>
<p>We can see that Jonathan doesn't have enough strength to break out of the castle, but let's try to show it using a query. To do that, he needs to have a strength greater than that of any a door. Or in other words, he needs a greater strength than the weakest door.</p>
<p>Fortunately, there is a function called <code>min()</code> that gives the minimum value of a set, so we can use that. If his strength is higher than the door with the smallest number, then he can escape. This query looks like it should work, but not quite:</p>
<pre><code class="language-edgeql">with
  jonathan := (select Person filter .name = 'Jonathan Harker'),
  castle   := (select Castle filter .name = 'Castle Dracula'),
select jonathan.strength &gt; min(castle.doors);
</code></pre>
<p>Here's the error:</p>
<pre><code>error: InvalidTypeError: operator '&gt;' cannot be applied to 
operands of type 'std::int16' and 'array&lt;std::int16&gt;'
</code></pre>
<p>We can {eql:func}<code>look at the function signature &lt;docs:std::min&gt;</code> to see the problem:</p>
<pre><code>std::min(values: set of anytype) -&gt; optional anytype
</code></pre>
<p>The important part is <code>set of</code>: it needs a set, so something in curly brackets. We can't just put curly brackets around the array, because then it becomes a set of one item (one array). So <code>select min({[5, 6]});</code> just returns <code>{[5, 6]}</code>, not <code>{5}</code>, because <code>{[5, 6]}</code> is the minimum value of the arrays we gave it...because we only gave it one array to look at.</p>
<p>That also means that <code>select min({[5, 6], [2, 4]});</code> will give us the output <code>{[2, 4]}</code> (instead of 2). That's not what we want.</p>
<p>Instead, what we want to use is the {eql:func}<code> ``array_unpack()`` &lt;docs:std::array_unpack&gt;</code> function which takes an array and unpacks it into a set. So we'll use that on <code>castle_doors</code>:</p>
<pre><code class="language-edgeql">with
  jonathan := (select Person filter .name = 'Jonathan Harker'),
  castle   := (select Castle filter .name = 'Castle Dracula'),
  select jonathan.strength &gt; min(array_unpack(castle.doors));
</code></pre>
<p>That gives us <code>{false}</code>. Perfect! Now we have shown that Jonathan can't open any doors. He will have to climb out the window to escape.</p>
<p>Unsurprisingly, along with <code>min()</code> there is also a function called <code>max()</code>. <code>len()</code> and <code>count()</code> are also useful: <code>len()</code> gives you the length of an object, and <code>count()</code> the number of them. Here is an example of <code>len()</code> to get the name length of all the <code>NPC</code> type objects:</p>
<pre><code class="language-edgeql">select ('Length of &quot;' ++ NPC.name ++ '&quot; is: ' ++ &lt;str&gt;len(NPC.name));
</code></pre>
<p>Don't forget that we need to cast with <code>&lt;str&gt;</code> because <code>len()</code> returns an integer, and EdgeDB won't concatenate a string to an integer. Here is the result:</p>
<pre><code>{
  'Length of &quot;Mina Murray&quot; is: 11',
  'Length of &quot;Jonathan Harker&quot; is: 15',
  'Length of &quot;The innkeeper&quot; is: 13',
}
</code></pre>
<p>This next example uses <code>count()</code>, which also uses a cast to a <code>&lt;str&gt;</code>:</p>
<pre><code class="language-edgeql">select 'There are ' ++ &lt;str&gt;(select count(Place) 
      - count(Castle)) ++ ' more places than castles';
</code></pre>
<p>It prints: <code>{'There are 8 more places than castles'}</code>. Or your query might return a different number if you have been experimenting with inserting <code>Place</code> objects.</p>
<p>In Chapter 11 we will learn how to write our own functions to make queries like these shorter. Once you learn to make your own functions you will be able to write something short like <code>select can_escape('Jonathan Harker', 'Castle Dracula');</code> and the function will do the rest! But in the meantime let's move on to a similar subject: setting parameters in queries.</p>
<h2 id="using--to-set-parameters"><a class="header" href="#using--to-set-parameters">Using $ to set parameters</a></h2>
<p>Imagine we need to look up <code>City</code> type objects all the time, with this sort of query:</p>
<pre><code class="language-edgeql">select Place {
  name,
  modern_name
} filter .name ilike '%i%' and exists .modern_name;
</code></pre>
<p>This works fine, returning one city:</p>
<pre><code>{default::City {name: 'Bistritz', modern_name: 'Bistri»õa'}}
</code></pre>
<p>But this last line with all the filters can be a little annoying to change: there's a lot of moving about to delete and retype before we can hit enter again. Or we might be using EdgeDB through one of its <a href="https://www.edgedb.com/docs/clients/index">client libraries</a> for languages like TypeScript, Python and Rust, and would like to pass in parameters instead of rewriting the query every time.</p>
<p>This could be a good time to add parameters to a query by using <code>$</code>. When EdgeDB sees the <code>$</code> it knows that this must be replaced with a value, and in the REPL it will ask us what value to give it. Let's start with something very simple:</p>
<pre><code class="language-edgeql">select Place {
  name
} filter .name ilike '%ondon%';
</code></pre>
<p>No surprise here: this will return the <code>City</code> object with the name <code>London</code>.</p>
<p>Now let's change 'London' to <code>$name</code>. Note: this won't work yet. Try to guess why!</p>
<pre><code class="language-edgeql">select Place {
  name
} filter .name ilike $name;
</code></pre>
<p>The problem is that <code>$name</code> could be anything, and EdgeDB doesn't know what type it's going to be. The error gives us a hint for what to do:</p>
<pre><code>error: QueryError: missing a type cast before the parameter
  ‚îå‚îÄ &lt;query&gt;:3:18
  ‚îÇ
3 ‚îÇ } filter .name ilike $name;
  ‚îÇ                      ^^^^^ error
</code></pre>
<p>In this case we want to enter a <code>str</code>, so we can use <code>&lt;str&gt;</code> to let EdgeDB know ahead of time that this is the type to expect.</p>
<pre><code class="language-edgeql">select Place {
  name
} filter .name ilike &lt;str&gt;$name;
</code></pre>
<p>When we do that we get a prompt asking us to enter the value:</p>
<pre><code>Parameter &lt;str&gt;$name:
</code></pre>
<p>And now, just typing <code>%ondon%</code> or <code>London</code> and hitting enter will lead to this expected result:</p>
<pre><code>{default::City {name: 'London'}}
</code></pre>
<p>Here are two points to keep in mind before we continue:</p>
<ul>
<li>The REPL now knows to expect a string so you don't need to surround it with quotes. Give <code>'London'</code> a try though and see what happens! The query works, but returns an empty set: <code>{}</code>. That's because it's looking for a <code>City</code> object where the name is <code>'London'</code>, not <code>London</code>.</li>
<li>The <code>&lt;&gt;</code> cast notation in EdgeDB actually has two uses: casting and type specification (letting the compiler know which type to expect). In this case, it is being used for type specification. That means that the compiler is not using <code>&lt;str&gt;</code> to cast input into a <code>str</code>, but simply to know to expect a <code>str</code> - and to reject input that is of a different type. The REPL is smart enough to not allow us to give it improper input when it expects a <code>str</code>, but if you are using a client library then there is no REPL to check a query before you send it to EdgeDB. So make sure that you are sending a string when it expects a <code>str</code>!</li>
</ul>
<p>Now let's use what we know to make a more useful query, using two parameters. We'll call them <code>$name</code> and <code>$name_has_changed</code>. Don't forget to use the cast notation for both:</p>
<pre><code class="language-edgeql">select Place {
  name,
  modern_name
} filter
    .name ilike '%' ++ &lt;str&gt;$name ++ '%'
  and
    exists .modern_name = &lt;bool&gt;$name_has_changed;
</code></pre>
<p>Since there are two of them, EdgeDB will ask us to input two values. Here's one example of what it looks like:</p>
<pre><code>Parameter &lt;str&gt;$name: b
Parameter &lt;bool&gt;$name_has_changed: true
</code></pre>
<p>So that will give all <code>Place</code> type objects with &quot;b&quot; in the name and which have a different name today than their name in the book. In our case, objects with the <code>modern_name</code> property have it because their modern name is different from the name in the book. The result:</p>
<pre><code>{
  default::City {name: 'Buda-Pesth', modern_name: 'Budapest'},
  default::City {name: 'Bistritz', modern_name: 'Bistri»õa'},
}
</code></pre>
<p>Parameters work just as well in inserts too. Here's an update for our global <code>Time</code> object that prompts the user for the hour, minute, and second:</p>
<pre><code>with new_time := &lt;str&gt;$hour ++ ':' ++ &lt;str&gt;$minute ++ ':' ++ &lt;str&gt;$second,
 current_time := (update Time set {
 clock := new_time
 })
 select current_time {*};
Parameter &lt;str&gt;$hour: 20
Parameter &lt;str&gt;$minute: 19
Parameter &lt;str&gt;$second: 00
</code></pre>
<p>And the output:</p>
<pre><code>{
  default::Time {
    id: eae7edc8-19cc-11ee-bae7-e3434cce8ad7,
    clock: '20:19:00',
    clock_time: &lt;cal::local_time&gt;'20:19:00',
    hour: '20',
    vampires_are: Awake,
  },
}
</code></pre>
<p>After doing this query, our <code>global time</code> will be updated as well:</p>
<pre><code class="language-edgeql">select global time {*};
</code></pre>
<p>The output will be the same as the <code>Time</code> object directly above.</p>
<h2 id="optional-parameters-and-the-coalescing-operator"><a class="header" href="#optional-parameters-and-the-coalescing-operator">Optional parameters and the coalescing operator</a></h2>
<p>There is also a way to do queries that just give the <em>option</em> of a parameter. To do this, just put <code>optional</code> before the type name inside the cast (inside the <code>&lt;&gt;</code> brackets). We could use this to change the query on <code>Place</code> object names above to allow a second filter for letters in the name.</p>
<p>With an optional parameter you could search for places that:</p>
<ul>
<li>contain both <code>B</code> and <code>z</code> (which would return <code>Bistritz</code> but not <code>Buda-Pesth</code>), or</li>
<li>contain <code>B</code>, and not provide anything for the second input. In this case the query would return both <code>Bistritz</code> and <code>Buda-Pesth</code>.</li>
</ul>
<p>The opposite of <code>optional</code> is <code>required</code>, but <code>required</code> is the default so you don't need to write it.</p>
<p>Putting all this together ends up with a query like the following. Note that we want to check to see if the optional query <code>exists</code>, and to filter for <code>ilike '%'</code> if it doesn't (that is, to match everything).</p>
<pre><code class="language-edgeql">with
  f1 := &lt;str&gt;$filter_1,
  f2 := &lt;optional str&gt;$filter_2,
 select Place {
   name,
   modern_name
 } filter 
   .name ilike '%' ++ f1 ++ '%' and .name ilike '%' ++ f2 ++ '%' 
     if exists f2 else 
   .name ilike '%' ++ f1 ++ '%';
</code></pre>
<p>Here are two sample outputs for this query from the REPL:</p>
<pre><code>Parameter &lt;str&gt;$filter_1: B
Parameter &lt;str&gt;$filter_2 (Ctrl+D for empty set `{}`): z
{default::City {name: 'Bistritz', modern_name: 'Bistri»õa'}}
</code></pre>
<p>And:</p>
<pre><code>Parameter &lt;str&gt;$filter_1: B
Parameter &lt;str&gt;$filter_2 (Ctrl+D for empty set `{}`):
{
  default::City {name: 'Buda-Pesth', modern_name: 'Budapest'},
  default::City {name: 'Bistritz', modern_name: 'Bistri»õa'},
}
</code></pre>
<p>The second parameter which asks us if we want to enter an empty string or an empty set is interesting, and has to do with some concepts called Cartesian multiplication and the &quot;coalescing operator&quot;. But those subjects are too large to fit into the end of this chapter, so we'll have to wait until Chapter 11 to learn them.</p>
<p><a href="chapter7/code.html">Here is all our code so far up to Chapter 7.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice-6"><a class="header" href="#time-to-practice-6">Time to practice</a></h2>
<ol>
<li>
<p>How would you select each City and the length of its name?</p>
</li>
<li>
<p>How would you select each City and the length of <code>name</code> minus the length of <code>modern_name</code> if <code>modern_name</code> exists, and 0 if <code>modern_name</code> does not exist?</p>
</li>
<li>
<p>What if you wanted to write 'Modern name does not exist' instead of 0?</p>
</li>
<li>
<p>How would you insert an NPC with the name 'NPC number 8' if for example there are already seven other NPCs?</p>
</li>
<li>
<p>How would you select only the <code>Person</code> type objects that have the shortest names?</p>
</li>
</ol>
<p><a href="chapter7/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>Workers in the city of Varna load boxes into a ship. Dracula is inside one of them...</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="tags-multiple-inheritance-polymorphism"><a class="header" href="#tags-multiple-inheritance-polymorphism">tags: Multiple Inheritance, Polymorphism</a></h2>
<h1 id="chapter-8---dracula-takes-the-boat-to-england"><a class="header" href="#chapter-8---dracula-takes-the-boat-to-england">Chapter 8 - Dracula takes the boat to England</a></h1>
<p>We are finally away from Castle Dracula. Here is what happens in this chapter:</p>
<blockquote>
<p>Far away from Castle Dracula, a boat leaves from the city of Varna in Bulgaria, sailing into the Black Sea. It has a <strong>captain, first mate, second mate, cook</strong>, and <strong>five crew</strong>. Dracula is also on the ship inside a coffin, but the crew don't know that he's there. Every night Dracula leaves his coffin, and every night one of the men disappears. They become afraid but don't know what is happening or what to do. One crewman tells the others that he saw a strange man walking around the deck, but the others don't believe him.</p>
<p>The days go by and more and more sailors disappear...</p>
<p>Finally it's the last day before the ship reaches the city of Whitby in England, but the captain is alone - all the others have disappeared. The captain knows the truth now. He ties his hands to the wheel so that the ship will go straight even if Dracula finds him.</p>
<p>The next day the people in Whitby see a ship hit the beach, and a wolf jumps off and runs onto the shore - it's Dracula disguised as a wolf. People find the dead captain tied to the wheel with a notebook in his hand and start to read the story.</p>
<p>Meanwhile, Mina and her friend Lucy are in Whitby on vacation...</p>
</blockquote>
<h2 id="multiple-inheritance-defaults-and-the-overloaded-keyword"><a class="header" href="#multiple-inheritance-defaults-and-the-overloaded-keyword">Multiple inheritance, defaults, and the overloaded keyword</a></h2>
<p>While Dracula arrives at Whitby, let's learn about multiple inheritance. We know that you can <code>extend</code> a type on another, and we have done this many times: <code>Person</code> on <code>NPC</code>, <code>Place</code> on <code>City</code>, etc. Multiple inheritance means to do this with more than one type at the same time.</p>
<p>We'll try some multiple inheritance with the ship's crew. The book doesn't give them any names, so we will give them numbers instead. Most <code>Person</code> types won't need a number, so we'll create an abstract type called <code>HasNumber</code> only for types that need a number:</p>
<pre><code class="language-sdl">abstract type HasNumber {
  required number: int16;
}
</code></pre>
<p>Now let's put the <code>Crewman</code> type together, which will use multiple inheritance. Multiple inheritance is very simple: just add a comma between every type you want to extend.</p>
<pre><code class="language-sdl">type Crewman extending HasNumber, Person;
</code></pre>
<p>However, here we have a problem: we never learn the names of the crewmen in the book, but the property <code>name</code> on <code>Person</code> is required. We know that every <code>Crewman</code> object will have a <code>number</code>, so it would be nice to use this to give them a name like &quot;Crewman 1&quot;, &quot;Crewman 2&quot;, and so on. How can we make this happen?</p>
<p>We can make this happen by giving <code>name</code> a default for the <code>Crewman</code> type. To give a default value, just add <code>{}</code> after the parameter and then give an expression for the default value. So far that gives us a <code>Crewman</code> type that looks like the code below. However, a migration won't quite work yet. Can you guess why?</p>
<pre><code class="language-sdl">type Crewman extending HasNumber, Person {
  name: str {
    default := '' ++ &lt;str&gt;.number;
  }
}
</code></pre>
<p>Fortunately, the error message tells us <em>exactly</em> what to do.</p>
<pre><code>error: property 'name' of object type 'default::Crewman' must be declared using the `overloaded` keyword because it is defined in the following ancestor(s): default::Person
  ‚îå‚îÄ c:\rust\easy-edgedb\dbschema\default.esdl:6:5
  ‚îÇ
6 ‚îÇ ‚ï≠     name: str {
7 ‚îÇ ‚îÇ       default := '' ++ &lt;str&gt;.number;
8 ‚îÇ ‚îÇ     }
  ‚îÇ ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ^ error
</code></pre>
<p>In other words, <code>Person</code> is where the definition for <code>name</code> is, and this definition doesn't include any information about a default value. We still want to use <code>name</code>, but in a slightly different way. That's where the word <code>overloaded</code> comes in. Adding <code>overloaded</code> will keep the other rules for <code>name</code> (that it must be a <code>str</code>, and that it must be <code>exclusive</code>) and will add our new specification that it will have a <code>default</code> value for the <code>Crewman</code> type. So just add <code>overloaded</code> and our work is done!</p>
<pre><code class="language-sdl">type Crewman extending HasNumber, Person {
  overloaded name: str {
    default := 'Crewman ' ++ &lt;str&gt;.number;
  }
}
</code></pre>
<p>Next is the <code>Sailor</code> type. The sailors have ranks, so first we will make an enum for that:</p>
<pre><code class="language-sdl">scalar type Rank extending enum&lt;Captain, FirstMate, SecondMate, Cook&gt;;
</code></pre>
<p>And then we will make a <code>Sailor</code> type that uses <code>Person</code> and this <code>Rank</code> enum. The sailors in the book all have their own names, so we don't need to overload their <code>name</code> keyword.</p>
<pre><code class="language-sdl">type Sailor extending Person {
  rank: Rank;
}
</code></pre>
<p>Then we will make a <code>Ship</code> type to hold them all. As we saw in this chapter, a <code>Ship</code> object can move on its own even if all of its sailors and crewmen are dead, so we won't make its sailors or crew <code>required</code>.</p>
<pre><code class="language-sdl">type Ship {
  required name: str;
  multi sailors: Sailor;
  multi crew: Crewman;
}
</code></pre>
<p>With all those changes done, let's do a migration.</p>
<p>Now that we have the <code>Crewman</code> type and it doesn't need a name, it's super easy to insert our crewmen thanks to <code>count()</code>. We just do this five times:</p>
<pre><code class="language-edgeql">with next_number := count(Crewman) + 1,
  insert Crewman {
  number := next_number
};
</code></pre>
<p>So if there are no <code>Crewman</code> types, he will get the number 1. The next will get 2, and so on. After the five inserts we can <code>select Crewman {name, number};</code> to see the result. It gives us:</p>
<pre><code>{
  default::Crewman {name: 'Crewman 1', number: 1},
  default::Crewman {name: 'Crewman 2', number: 2},
  default::Crewman {name: 'Crewman 3', number: 3},
  default::Crewman {name: 'Crewman 4', number: 4},
  default::Crewman {name: 'Crewman 5', number: 5},
}
</code></pre>
<p>Now to insert the sailors we just give them each a name and choose a rank from the enum. Let's mix up the enums between <code>str</code> and proper enum input to remind ourselves that EdgeDB will accept either one.</p>
<pre><code class="language-edgeql">insert Sailor {
  name := 'The Captain',
  rank := 'Captain'
};

insert Sailor {
  name := 'Petrofsky',
  rank := 'FirstMate'
};

insert Sailor {
  name := 'The Second Mate',
  rank := Rank.SecondMate
};

insert Sailor {
  name := 'The Cook',
  rank := Rank.Cook
};
</code></pre>
<p>Finally we have to insert a <code>Ship</code> to hold them all. This <code>insert</code> is easy because right now every <code>Sailor</code> and every <code>Crewman</code> type is part of this ship - we don't need to <code>filter</code> anywhere.</p>
<pre><code class="language-edgeql">insert Ship {
  name := 'The Demeter',
  sailors := Sailor,
  crew := Crewman
};
</code></pre>
<p>Then we can look up the <code>Ship</code> to make sure that the whole crew is there:</p>
<pre><code class="language-edgeql">select Ship {
  name,
  sailors: {
    name,
    rank,
  },
  crew: {
    name,
    number
  },
};
</code></pre>
<p>The result is:</p>
<pre><code>{
  default::Ship {
    name: 'The Demeter',
    sailors: {
      default::Sailor {name: 'The Captain', rank: Captain},
      default::Sailor {name: 'Petrofsky', rank: FirstMate},
      default::Sailor {name: 'The Second Mate', rank: SecondMate},
      default::Sailor {name: 'The Cook', rank: Cook},
    },
    crew: {
      default::Crewman {name: 'Crewman 1', number: 1},
      default::Crewman {name: 'Crewman 2', number: 2},
      default::Crewman {name: 'Crewman 3', number: 3},
      default::Crewman {name: 'Crewman 4', number: 4},
      default::Crewman {name: 'Crewman 5', number: 5},
    },
  },
}
</code></pre>
<h2 id="using-the-is-keyword-to-query-multiple-types"><a class="header" href="#using-the-is-keyword-to-query-multiple-types">Using the 'is' keyword to query multiple types</a></h2>
<p>We now have quite a few types that extend the <code>Person</code> type, many with their own properties. The <code>Crewman</code> type has a property <code>number</code>, while the <code>NPC</code> type has a property called <code>age</code>. But since the <code>Person</code> type itself doesn't have the properties <code>age</code> or <code>number</code>, we can't just make a <code>Person</code> shape that includes them:</p>
<pre><code class="language-edgeql">select Person {
  name,
  age,
  number,
};
</code></pre>
<p>The error is:</p>
<pre><code>error: InvalidReferenceError: object type 'default::Person'
has no link or property 'age'
</code></pre>
<p>It looks like the only property of the three that we can put in this query is <code>name</code>. That feels pretty limiting!</p>
<pre><code class="language-edgeql">select Person {
  name
};
</code></pre>
<p>So is there a way to include <code>age</code> if the type is an <code>NPC</code> and <code>number</code> if the type is a <code>Crewman</code>? Yes, there is! We can use the <code>is</code> keyword inside square brackets to specify the type. Here's how it works in our query on <code>Person</code> objects:</p>
<ul>
<li><code>.name</code>: this stays the same, because <code>Person</code> has this property</li>
<li><code>.age</code>: this belongs to the <code>NPC</code> type, so change it to <code>[is NPC].age</code></li>
<li><code>.number</code>: this belongs to the <code>Crewman</code> type, so change it to <code>[is Crewman].number</code></li>
</ul>
<p>Now it will work:</p>
<pre><code class="language-edgeql">select Person {
  name,
  [is NPC].age,
  [is Crewman].number,
};
</code></pre>
<p>The output is now quite large, so here's just a part of it. You'll notice that types that don't have a property or a link will return an empty set: <code>{}</code>. So the <code>Crewman</code> objects have an <code>age: {}</code> while other objects have a <code>number: {}</code>.</p>
<pre><code>{
  # ... /snip
  default::Crewman {name: 'Crewman 4', age: {}, number: 4},
  default::Crewman {name: 'Crewman 5', age: {}, number: 5},
  default::PC {name: 'Emil Sinclair', age: {}, number: {}},
  default::NPC {name: 'The innkeeper', age: 30, number: {}},
  default::NPC {name: 'Mina Murray', age: {}, number: {}},
  default::NPC {name: 'Jonathan Harker', age: {}, number: {}},
}
</code></pre>
<p>This is officially called a {ref}<code>polymorphic query &lt;docs:ref_eql_select_polymorphic&gt;</code>, and is one of the best reasons to use abstract types in your schema.</p>
<h2 id="using-type-to-get-the-type"><a class="header" href="#using-type-to-get-the-type">Using <strong>type</strong> to get the type</a></h2>
<p>Let's do a quick experiment with the same query as above, except with the <code>&lt;json&gt;</code> cast. What differences do you notice?</p>
<pre><code class="language-edgeql">select &lt;json&gt;Person {
  name,
  [is NPC].age,
  [is Crewman].number,
};
</code></pre>
<p>Here is part of the output:</p>
<pre><code>{&quot;age&quot;: null, &quot;name&quot;: &quot;Emil Sinclair&quot;, &quot;number&quot;: null}
{&quot;age&quot;: null, &quot;name&quot;: &quot;Vampire Woman 1&quot;, &quot;number&quot;: null}
{&quot;age&quot;: null, &quot;name&quot;: &quot;The Captain&quot;, &quot;number&quot;: null}
{&quot;age&quot;: null, &quot;name&quot;: null, &quot;number&quot;: 1}
</code></pre>
<p>The type information is all gone! This makes sense because a JSON object is just a bunch of keys and values, and with a concrete query like <code>PC</code> this would be no problem. But this query includes various object types extending <code>Person</code> and it's hard to tell which type is which. Fortunately, we can put the type information by adding <code>__type__</code> which is used to refer to an object's own type:</p>
<pre><code class="language-edgeql">select &lt;json&gt;Person {
  name,
  [is NPC].age,
  [is Crewman].number,
  __type__
};
</code></pre>
<p>The result is close to what we want, but not quite. Take a look at two of the results:</p>
<pre><code>{
  &quot;age&quot;: null,
  &quot;name&quot;: &quot;Emil Sinclair&quot;,
  &quot;number&quot;: null,
  &quot;__type__&quot;: {&quot;id&quot;: &quot;4a007f07-f91f-11ed-8096-7bf54ff85912&quot;}
}
{
  &quot;age&quot;: null,
  &quot;name&quot;: &quot;The Captain&quot;,
  &quot;number&quot;: null,
  &quot;__type__&quot;: {&quot;id&quot;: &quot;48b9bb2f-faaa-11ed-966c-6fc3482a7805&quot;}
}
</code></pre>
<p>The <code>id</code> property shows us that they are two different types, but the type name isn't readable. To fix this, we can add the <code>name</code> property after <code>__type__</code> to display this instead of the id.</p>
<pre><code class="language-edgeql">select &lt;json&gt;Person {
  name,
  [is NPC].age,
  [is Crewman].number,
  __type__: {
    name
  }
};
</code></pre>
<p>And now the two objects from out previous output have human-readble names.</p>
<pre><code>{&quot;age&quot;: null, &quot;name&quot;: &quot;Emil Sinclair&quot;, &quot;number&quot;: null, &quot;__type__&quot;: {&quot;name&quot;: &quot;default::PC&quot;}}
{&quot;age&quot;: null, &quot;name&quot;: &quot;The Captain&quot;, &quot;number&quot;: null, &quot;__type__&quot;: {&quot;name&quot;: &quot;default::Sailor&quot;}}
</code></pre>
<p>So what is <code>__type__</code>, exactly? Well, it's a link that all objects have that are used to describe it. You can see this if you type <code>describe type PC as text;</code> (or with any other object in the schema). Inside the description returned you'll see this:</p>
<pre><code>required single link __type__: schema::ObjectType {
    readonly := true;
};
</code></pre>
<p>Interesting! So it's just an object that can be queried like any other. Let's give it a try with <code>PC</code> and the splat operator to see everything inside:</p>
<pre><code class="language-edgeql">select PC.__type__ {*};
</code></pre>
<p>This will show all of the properties for <code>ObjectType</code>, including the <code>name</code>:</p>
<pre><code>{
  schema::ObjectType {
    id: c7c1983a-268c-11ee-8c82-c79bbe432a02,
    name: 'default::PC',
    internal: false,
    builtin: false,
    computed_fields: [],
    final: false,
    is_final: false,
    abstract: false,
    is_abstract: false,
    inherited_fields: [],
    from_alias: false,
    is_from_alias: false,
    expr: {},
    compound_type: false,
    is_compound_type: false,
  },
}
</code></pre>
<p>So that can be pretty useful.</p>
<p>But if you <em>really</em> want to understand the inner workings of EdgeDB, try the same query with the double splat operator:</p>
<pre><code>select PC.__type__ {**};
</code></pre>
<p>This will return pages and pages of information. You'll see a link called <code>pointers</code> that points to just about everything: a link to <code>__type__</code>, a link to <code>strength</code>, a link to <code>is_single</code> and that it is a computable made from the expression <code>not exists .lover</code>...and so on and so on. If you want to get a good feel for how EdgeDB works on the inside, definitely grab a cup of coffee and give this query a try!</p>
<h2 id="supertypes-subtypes-and-generic-types"><a class="header" href="#supertypes-subtypes-and-generic-types">Supertypes, subtypes, and generic types</a></h2>
<p>The official name for a type that gets extended by another type is a <code>supertype</code> (meaning 'above type'). The types that extend them are their <code>subtypes</code> ('below types'). You can visualize it like this:</p>
<ul>
<li>abstract type Person (supertype, above)</li>
<li>‚Ü≥ type PC (subtype, under)</li>
<li>‚Ü≥ type NPC (subtype, under)</li>
</ul>
<p>Because inheriting a type gives you all of its features, a query on objects with <code>subtype is supertype</code> will always return <code>{true}</code>. In our schema a <code>PC</code> object is always a <code>Person</code>, and an <code>NPC</code> object is always a <code>Person</code>.</p>
<p>Conversely, <code>supertype is subtype</code> will return <code>{true}</code> or <code>{false}</code> depending on the concrete type of each object returned. A <code>Person</code> object <em>might</em> be a <code>PC</code> object, and it <em>might</em> be an <code>NPC</code> object.</p>
<p>To make a query that will check this, just add a shape query with the computed property <code>Person is PC</code> and EdgeDB will tell you:</p>
<pre><code class="language-edgeql">select Person {
    name,
    is_PC := Person is PC,
};
</code></pre>
<p>The output will look like this:</p>
<pre><code>{&quot;name&quot;: &quot;Emil Sinclair&quot;, &quot;is_PC&quot;: true}
{&quot;name&quot;: &quot;Vampire Woman 1&quot;, &quot;is_PC&quot;: false}
{&quot;name&quot;: &quot;Vampire Woman 2&quot;, &quot;is_PC&quot;: false}
# ... and so on
</code></pre>
<p>Now how about the simpler scalar types? It's nice that EdgeDB is strict about type safety and has different types for integers, floats and so on, but what if you just want to know if a number is an integer or a float? We could check to see if an integer is one of any integer types, but this makes for a pretty awkward query:</p>
<pre><code class="language-edgeql">with year := 1893,
select year is int16 or year is int32 or year is int64;
</code></pre>
<p>Output: <code>{true}</code>.</p>
<p>But fortunately these types all {ref}<code>extend from abstract types too &lt;docs:ref_std_abstract_types&gt;</code>, and we can use them. These abstract types all start with <code>any</code>, and are: <code>anytype</code>, <code>anyscalar</code>, <code>anyenum</code>, <code>anytuple</code>, <code>anyint</code>, <code>anyfloat</code>, <code>anyreal</code>. The only one with an unclear name is <code>anyreal</code>: this one means any real number, so both integers and floats, plus the <code>decimal</code> type.</p>
<p>So with that you can change the above input to <code>select 1893 is anyint;</code> and get <code>{true}</code>.</p>
<h2 id="array-vs-multi-property-vs-multi-link"><a class="header" href="#array-vs-multi-property-vs-multi-link">Array vs. multi property vs. multi link</a></h2>
<p>We've seen <code>multi</code> links quite a bit already, and you might be wondering if <code>multi</code> can appear in other places too. The answer is yes. A <code>multi</code> property is like any other property, except that it can have more than one value. For example, our <code>Castle</code> type has an <code>array&lt;int16&gt;</code> for the <code>doors</code> property:</p>
<pre><code class="language-sdl">type Castle extending Place {
  doors: array&lt;int16&gt;;
}
</code></pre>
<p>But it could do something similar with a <code>multi</code> property:</p>
<pre><code class="language-sdl">type Castle extending Place {
  multi doors: int16;
}
</code></pre>
<p>With a <code>multi</code> property you would then insert using <code>{}</code> instead of square brackets for an array:</p>
<pre><code class="language-edgeql">insert Castle {
  name := 'Castle Dracula',
  doors := {6, 19, 10},
};
</code></pre>
<p>Which makes you wonder which is best to use: <code>multi</code> for a multi property, <code>array</code>, or an object type via a link. The answer is... it depends. But here are some good rules of thumb to help you decide which to choose.</p>
<ul>
<li>
<p><code>multi</code> property vs. arrays:</p>
<p>How large is the data you are working with? A <code>multi</code> property is more efficient when you have a lot of data, while arrays are slower. But if you have small sets, then arrays are faster than <code>multi</code> property.</p>
<p>If you want to use indexes and constraints on individual elements, then you should use a <code>multi</code> property. We'll look at indexes in Chapter 16, but for now just know that they are a way of making lookups faster.</p>
<p>If order is important, than an array may be better. It's easier to keep the original order of items in an array.</p>
</li>
<li>
<p><code>multi</code> property vs. linking to objects</p>
<p>Here we'll start with two areas where a <code>multi</code> property is better, and then two areas where objects are better.</p>
<p>First negative for objects: objects are always larger, and here's why. Remember <code>describe type as text</code>? Let's look at one of our types with that again. Here's the <code>Castle</code> type:</p>
<pre><code>{
  'type default::Castle extending default::Place {
    required single link __type__: schema::Type {
        readonly := true;
    };
    optional single property doors: array&lt;std::int16&gt;;
    required single property id: std::uuid {
        readonly := true;
    };
    optional single property important_places: array&lt;std::str&gt;;
    optional single property modern_name: std::str;
    required single property name: std::str;
};',
}
</code></pre>
<p>You'll remember seeing the <code>readonly := true</code> properties, which are created for each object type you make. The <code>__type__</code> link and <code>id</code> property together always make up 32 bytes.</p>
<p>The second negative for objects is similar: underneath, they are more work for the computer. EdgeDB runs on top of PostgreSQL, and a multi link to an object needs an extra &quot;join&quot; (a link table + object table), but a <code>multi</code> property only has one. Also, a &quot;backlink&quot; (you'll see those in Chapter 14) takes more work as well.</p>
<p>Having said that, now here are two positives for objects in comparison.</p>
<p>Are there other types that need to refer to the same values? If so, then it may be better to use an object to keep things consistent. That's why we eventually made <code>places_visited</code> a <code>multi</code> link, for example.</p>
<p>Using objects with an <code>exclusive</code> constraint is more efficient when there is a lot of property value duplication.</p>
</li>
</ul>
<p>So hopefully that explanation should help. You can see that you have a lot of choice, so remembering the points above should help you make a decision. Most of the time, you'll probably have a sense for which one you want.</p>
<p><a href="chapter8/code.html">Here is all our code so far up to Chapter 8.</a></p>
<!--
Todo: demonstrate turning array<int64> into multi int64 once this resolved:
https://github.com/edgedb/edgedb/issues/5749
 -->
<!-- quiz-start -->
<h2 id="time-to-practice-7"><a class="header" href="#time-to-practice-7">Time to practice</a></h2>
<ol>
<li>
<p>How would you select all the <code>Place</code> types and their names, plus the <code>doors</code> property if it's a <code>Castle</code>?</p>
</li>
<li>
<p>How would you select <code>Place</code> types with <code>city_name</code> for <code>name</code> if it's a <code>City</code> and <code>country_name</code> for <code>name</code> if it's a <code>Country</code>?</p>
</li>
<li>
<p>How would you do the same but only showing the results of <code>City</code> and <code>Country</code> types?</p>
</li>
<li>
<p>How would you display all the <code>Person</code> types that don't have <code>lover</code>s, with their names and their type names?</p>
</li>
<li>
<p>What needs to be fixed in this query? Hint: two things definitely need to be fixed, while one more should probably be changed to make it more readable.</p>
<pre><code class="language-edgeql">select Place {
  __type__,
  name
  [is Castle]doors
};
</code></pre>
</li>
</ol>
<p><a href="chapter8/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>Time to meet Dr. Seward, Arthur Holmwood, and Quincey Morris...and the strange Renfield.</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="tags-defaults-overloading-for-loops"><a class="header" href="#tags-defaults-overloading-for-loops">tags: Defaults, Overloading, For Loops</a></h2>
<h1 id="chapter-9---strange-events-in-england"><a class="header" href="#chapter-9---strange-events-in-england">Chapter 9 - Strange events in England</a></h1>
<p>The episode for this chapter is a flashback to see why everybody is in the town of Whitby in the first place. Our characters are from London, after all, not a small town on the east coast of England. We'll go back in time a few weeks to when the ship carrying Dracula left Varna, when Mina and Lucy were still back home. The introduction is also split into two parts. Here's the first:</p>
<blockquote>
<p>We still don't know where Jonathan is, and the ship The Demeter is on its way to England with Dracula inside. Meanwhile, Mina Harker is in London writing letters to her friend Lucy Westenra. Lucy has three boyfriends (named Dr. John Seward, Quincey Morris, and Arthur Holmwood), and they all want to marry her....</p>
</blockquote>
<h2 id="working-with-dates-some-more"><a class="header" href="#working-with-dates-some-more">Working with dates some more</a></h2>
<p>It looks like we have some more people to insert, starting with Lucy:</p>
<pre><code class="language-edgeql">insert NPC {
  name := 'Lucy Westenra',
  places_visited := (select City filter .name = 'London')
};
</code></pre>
<p>But let's think about the ship a little more before we insert the rest. Everyone on the ship was killed by Dracula, but that doesn't mean that we want to delete them from the database. After all, the crewmembers on the ship were alive before and could have interacted with some <code>PC</code> objects during that time. The book tells us that the ship left on the 6th of July, and the last person (the captain) died on the 4th of August.</p>
<p>This is a good time to add two new properties to the <code>Person</code> type to indicate when a character is alive and present in the game. We'll call these properties <code>first_appearance</code> and <code>last_appearance</code>. The name <code>last_appearance</code> is a bit better than <code>death</code>, because for the game it doesn't matter: we just want to know when characters are there or not.</p>
<p>For these two properties we will just use <code>cal::local_date</code> for the sake of simplicity. There is also a <code>cal::local_datetime</code> type that includes the time, but we should be fine with just the date.</p>
<p>We used the <code>std::to_datetime</code> function before which took seven parameters to make a <code>DateTime</code>, and <code>cal::local_date</code> has a similar but but shorter function called {eql:func}<code>docs:cal::to_local_date</code>. It just takes three integers.</p>
<p>Here are all of its signatures (we're using the third one):</p>
<pre><code>cal::to_local_date(s: str, fmt: optional str = {}) -&gt; local_date
cal::to_local_date(dt: datetime, zone: str) -&gt; local_date
cal::to_local_date(year: int64, month: int64, day: int64) -&gt; local_date
</code></pre>
<p>In addition, <code>cal::local_date</code> has a pretty simple YYYYMMDD format so casting from a string is pretty easy too:</p>
<pre><code class="language-edgeql">select &lt;cal::local_date&gt;'1893-07-08';
</code></pre>
<p>But we decided before that the dates and datetimes in our game are being generated from a source that gives us individual numbers instead of strings, so we will continue to use that method.</p>
<p>So let's do a migration now that these <code>first_appearance</code> and <code>last_appearance</code> properties have been added.</p>
<p>Doing the inserts for the <code>Crewman</code> objects with the properties <code>first_appearance</code> and <code>last_appearance</code> would have looked something like this:</p>
<pre><code class="language-edgeql">insert Crewman {
  number := count(detached Crewman) +1,
  first_appearance := cal::to_local_date(1893, 7, 6),
  last_appearance := cal::to_local_date(1893, 7, 16),
};
</code></pre>
<p>But since we already have the <code>Crewman</code> objects in the database, we can easily use the <code>update</code> and <code>set</code> syntax on all of them if we assume they all died at the same time (or if we don't care about being super precise). The query to update them looks like this:</p>
<pre><code class="language-edgeql">update Crewman
set {
  first_appearance := cal::to_local_date(1893, 7, 6),
  last_appearance  := cal::to_local_date(1893, 7, 16)
};
</code></pre>
<p>The date type to choose will of course depend on our game. Can a <code>PC</code> actually visit the ship when it's sailing to England? Will there be missions to try to save the crew before Dracula kills them? If so, then we would need more precision and a <code>cal::local_datetime</code> would make more sense. But we're fine with these approximate dates for now.</p>
<h2 id="datetime_current-and-datetime_of_statement"><a class="header" href="#datetime_current-and-datetime_of_statement">datetime_current() and datetime_of_statement()</a></h2>
<p>Speaking of dates and datetimes, sometimes it can be useful to know the datetime right now. EdgeDB has two convenient functions for this: {eql:func}<code> ``datetime_current()`` &lt;docs:std::datetime_current&gt;</code> and {eql:func}<code> ``datetime_of_statement()`` &lt;docs:std::datetime_of_statement&gt;</code>. Let's try the first one out and see what it returns:</p>
<pre><code>db&gt; select datetime_current();
{&lt;datetime&gt;'2023-05-28T10:18:56.889701Z'}
</code></pre>
<p>This can be useful if you want a post date when you insert an object. With this you can sort objects by date, delete the most recent item if you have a duplicate, and so on.</p>
<p>Note though that <code>datetime_current()</code> will not return the exact same date as another call to <code>datetime_current()</code> inside the same statement. This is because <code>datetime_current()</code> returns the datetime at which the <em>function is called</em>, not the datetime of the statement that it's in.</p>
<p>We can easily see this by calling the function twice. The timestamp is almost the same, but not quite: one is a few microseconds after the other.</p>
<pre><code>db&gt; select (datetime_current(), datetime_current());
{
  (&lt;datetime&gt;'2023-07-16T10:55:55.498380Z', 
   &lt;datetime&gt;'2023-07-16T10:55:55.498394Z')
}
</code></pre>
<p>However, if we change the function to <code>datetime_of_statement()</code>, then the exact same datetime will be returned no matter how many times we call it:</p>
<pre><code>edgedb&gt; select (datetime_of_statement(), datetime_of_statement());
{
  (&lt;datetime&gt;'2023-07-16T10:58:03.384721Z', 
   &lt;datetime&gt;'2023-07-16T10:58:03.384721Z')
}
</code></pre>
<p>Or even simpler, a query to see if one function output equals the other.</p>
<pre><code>select (
  datetime_of_statement() = datetime_of_statement(),
  datetime_current() = datetime_current(), 
);
</code></pre>
<p>This should return <code>true</code> followed by <code>false</code> - unless EdgeDB was fast enough to call <code>datetime_current()</code> twice in the same microsecond.</p>
<p>We can put one of these functions to use in our schema too. Our game will have its <code>NPC</code> objects already in the database because they are all detailed in the book, and they will be in the database long before anybody begins playing our game. However, <code>PC</code> objects will only show up when a player decides to make a character. It could be useful to add a <code>date_created</code> property to the <code>PC</code> type so that we know when it was first made.</p>
<p>Let's imagine how it would look if we put it inside the <code>Person</code> type. This is close, but not quite:</p>
<pre><code class="language-sdl">type PC extending Person {
  required class: Class;
  property created_at := datetime_of_statement(); # this is new
}
</code></pre>
<p>Because <code>created_at</code> is a computable here, and computables are calculated when you <em>query</em> an object, this would generate the date when the query happens instead of when the object is inserted. It would effectively be a <code>datetime_of_the_query_you_just_made</code> property. So to make our <code>PC</code> objects have the date when you first inserted it, we can use <code>default</code> instead. And since we are adding a default value, we might as well make <code>created_at</code> a <code>required</code> property.</p>
<pre><code class="language-sdl">type PC extending Person {
  required class: Class;
  required created_at: datetime {
    default := datetime_of_statement()
  }
}
</code></pre>
<p>Let's do a migration and give this a try with a second PC. We'll call him Max Demian and choose a <code>class</code> but nothing else, but thanks to <code>created_at</code> having a default value we don't need to specify it ourselves. Let's <code>select</code> Max Demian right after his creation to see the date he was made.</p>
<pre><code class="language-edgeql">with new_pc := (insert PC {
   name := 'Max Demian',
   class := Class.Mystic
 }),
 select new_pc {
   name,
   created_at
 };
</code></pre>
<p>The output will depend on when you do the insert, but will look something like this:</p>
<pre><code>{default::PC {name: 'Max Demian', 
created_at: &lt;datetime&gt;'2023-05-30T01:13:28.022340Z'}}
</code></pre>
<h2 id="using-the-for-and-union-keywords"><a class="header" href="#using-the-for-and-union-keywords">Using the 'for' and 'union' keywords</a></h2>
<p>We're almost ready to insert our three new characters. They are all <code>NPC</code>s that have been to London before, so the only difference between them at the moment is their name. Wouldn't it be nice if we could use a single insert instead of three?</p>
<p>To do this, we can use a <code>for</code> loop, followed by the keyword <code>union</code>. First, here's the <code>for</code> part:</p>
<pre><code class="language-edgeql">for character_name in {'John Seward', 'Quincey Morris', 'Arthur Holmwood'}
</code></pre>
<p>In other words: take this set of three strings and do something with each one. <code>character_name</code> is the variable name we chose to call each string in this set.</p>
<p><code>union</code> comes next, because it is the keyword used to join sets together. To understand why we need to write <code>union</code> in a <code>for</code> loop, take this example without <code>union</code>:</p>
<pre><code class="language-edgeql">for character_name in {'John Seward', 'Quincey Morris', 'Arthur Holmwood'}
select character_name ++ ' is great';
</code></pre>
<p>This generates an error because we are asking EdgeDB to make three queries when we are actually trying to do one. But what we want instead is a single query result (a single set) that contains the <em>unified</em> results of selecting each name. That's what the <code>union</code> keyword is for here, as it will join the sets together for us. We will also have to surround <code>select</code> in parentheses, indicating that we are capturing the result of each <code>select</code> and joining them together. Altogether the query now looks like this:</p>
<pre><code class="language-edgeql">for character_name in {'John Seward', 'Quincey Morris', 'Arthur Holmwood'}
union (select character_name ++ ' is great');
</code></pre>
<p>With this EdgeDB will select one name at a time, concatenate <code>' is great'</code> on the end, and unify them into a single set that it returns to us as follows:</p>
<pre><code>{'John Seward is great', 'Quincey Morris is great', 'Arthur Holmwood is great'}
</code></pre>
<p>Now let's use what we learned to insert the three characters at once! This query will start with the three character names, but now each time we will insert an <code>NPC</code> with its name:</p>
<pre><code class="language-edgeql">for character_name in {'John Seward', 'Quincey Morris', 'Arthur Holmwood'}
union (
  insert NPC {
    name := character_name,
    places_visited := (select City filter .name = 'London'),
    lover := (select Person filter .name = 'Lucy Westenra'),
  }
);
</code></pre>
<p>We get three <code>uuid</code>s as a response to show that they were inserted.</p>
<p>Then we can check to make sure that it worked:</p>
<pre><code class="language-edgeql">select NPC {
  name,
  places_visited: {
    name,
  },
  lover: {
    name,
  },
} filter .name in {'John Seward', 'Quincey Morris', 'Arthur Holmwood'};
</code></pre>
<p>And as we hoped, they are all connected to Lucy now.</p>
<pre><code>{
  default::NPC {
    name: 'John Seward',
    places_visited: {default::City {name: 'London'}},
    lover: {default::NPC {name: 'Lucy Westenra'}},
  },
  default::NPC {
    name: 'Quincey Morris',
    places_visited: {default::City {name: 'London'}},
    lover: {default::NPC {name: 'Lucy Westenra'}},
  },
  default::NPC {
    name: 'Arthur Holmwood',
    places_visited: {default::City {name: 'London'}},
    lover: {default::NPC {name: 'Lucy Westenra'}},
  },
}
</code></pre>
<p>By the way, now we could also use the <code>for</code> keyword to insert our five <code>Crewman</code> objects inside one <code>insert</code> instead of doing it five times. Previously we used the <code>count()</code> function to insert their numbers, but we know that the book only ever has five crewmen so it will be easier to just use a <code>for</code> loop now. With this we can put their numbers inside a single set, and use the same <code>for</code> and <code>union</code> method to insert them. Of course, we already used <code>update</code> to change the inserts but from now on in our code their insert will look like this:</p>
<pre><code class="language-edgeql">for n in {1, 2, 3, 4, 5}
union (
  insert Crewman {
    number := n,
    first_appearance := cal::to_local_date(1893, 7, 6),
    last_appearance  := cal::to_local_date(1893, 7, 16),
  }
);
</code></pre>
<p>It's a good idea to familiarize yourself with {ref}<code>the order to follow &lt;docs:ref_eql_statements_for&gt;</code> when you use <code>for</code>. Here is the syntax information from the documentation on <code>for</code>:</p>
<pre><code class="language-edgeql-synopsis">[ with with-item [, ...] ]

for variable in iterator-expr

union output-expr ;
</code></pre>
<p>The important part is the <em>iterator-expr</em> which needs to be a single simple expression that gives back some kind of set. Usually, it is a just a set inside <code>{</code> and <code>}</code>. It can also be a path, such as <code>NPC.places_visited</code>, or it can be a function call, such as <code>array_unpack()</code>. More complex expressions should have parentheses around them.</p>
<h2 id="an-interesting-migration"><a class="header" href="#an-interesting-migration">An interesting migration</a></h2>
<p>Now it's time to update Lucy with three lovers. Lucy has already ruined our plans to have <code>lover</code> as just a single link. We'll rename the <code>lover</code> link to <code>multi lovers</code> to make it a multi link instead and do a migration so that she can be linked to all three of the men. This change makes sense in any case, as other <code>Person</code> types could easily have more than one lover.</p>
<p>Sometimes migration output can be a little interesting, as EdgeDB doesn't always exactly know what we are trying to do. For example, during this migration via a previous version of EdgeDB in the summer of 2023, EdgeDB first concluded that we were dropping the <code>lover</code> link, but after being told no, asked if we instead were trying to rename it. This is a good reminder to pay attention to the questions when doing a migration, because (though rare) EdgeDB will sometimes misunderstand what you are trying to do. Here is the migration output from that time:</p>
<pre><code>c:\easy-edgedb&gt;edgedb migration create
Connecting to an EdgeDB instance at localhost:10716...
did you drop link 'lover' of object type 'default::Person'? [y,n,l,c,b,s,q,?]
&gt; n
did you rename link 'lover' of object type 'default::Person' to 'lovers'? [y,n,l,c,b,s,q,?]
&gt; y
did you convert link 'lovers' of object type 'default::Person' to 'multi' cardinality? [y,n,l,c,b,s,q,?]
&gt; y
</code></pre>
<p>In a case such as this you might feel the need to make sure that EdgeDB has understood what you have asked it to do before typing <code>edgedb migrate</code>. Looking at the ddl output in the most recent <code>.edgeql</code> migration file in our <code>migrations</code> folder shows what commands were used to change the link:</p>
<pre><code class="language-edgeql">ALTER TYPE default::Person {
      ALTER LINK lover {
          RENAME TO lovers;
      };
  };
  ALTER TYPE default::Person {
      ALTER LINK lovers {
          SET MULTI;
      };
  };
</code></pre>
<p>That looks correct!</p>
<p>If, on the other hand, we had said yes to dropping <code>link 'lover'</code>, then we would have seen these commands instead:</p>
<pre><code class="language-edgeql">ALTER TYPE default::Person {
    DROP LINK lover;
};
ALTER TYPE default::Person {
    CREATE MULTI LINK lovers: default::Person;
};
</code></pre>
<p>In this case the schema migration would still have worked, but the <code>lover</code> data would now be gone. Then we would have had to update the three men again to give them Lucy back:</p>
<pre><code class="language-edgeql">update NPC filter .name in 
 {'John Seward', 'Quincey Morris', 'Arthur Holmwood'}
   set {
    lovers := (select Person filter .name = 'Lucy Westenra')
 };
</code></pre>
<p>Here is our update for her:</p>
<pre><code class="language-edgeql">update NPC filter .name = 'Lucy Westenra'
set {
  lovers := (
    select Person filter .name in
      {'John Seward', 'Quincey Morris', 'Arthur Holmwood'}
  )
};
</code></pre>
<p>Now we'll select her to make sure it worked. Let's use <code>like</code> this time for fun when doing the filter:</p>
<pre><code class="language-edgeql">  select NPC {
    name,
    lovers: {
      name
    }
  } filter .name like 'Lucy%';
</code></pre>
<p>And this does indeed return Lucy with a link to her three lovers.</p>
<pre><code>{
  default::NPC {
    name: 'Lucy Westenra',
    lovers: {
      default::NPC {name: 'John Seward'},
      default::NPC {name: 'Quincey Morris'},
      default::NPC {name: 'Arthur Holmwood'},
    },
  },
}
</code></pre>
<h2 id="an-uninteresting-migration"><a class="header" href="#an-uninteresting-migration">An uninteresting migration</a></h2>
<p>This migration was pretty interesting, but what if you are doing a really boring migration that you are sure is safe to do? You might have pasted a schema that you've used before, or could have deleted everything inside a module, or anything else that makes you wish you didn't have to reply to every question from the CLI.</p>
<p>In this case there is a solution: just add <code>--non-interactive</code> after <code>edgedb migration create</code>, and the CLI will be quiet and put your migration together ‚Äî if it can. If there are any changes that do require your input, such as making a parameter <code>required</code>, you will instead see the following output: <code>edgedb error: Cannot apply migration without user input</code>.</p>
<p>Note that a non-interactive migration still only creates a migration script, so it won't apply the migration before you have had a chance to review the script yourself. So don't worry!</p>
<h2 id="overloading-instead-of-making-a-new-type"><a class="header" href="#overloading-instead-of-making-a-new-type">Overloading instead of making a new type</a></h2>
<p>Last chapter we learned the <code>overloaded</code> keyword, and we can use it now to improve our schema a bit. Remember the <code>HumanAge</code> scalar type we created before? Right now it looks like this:</p>
<pre><code class="language-sdl">scalar type HumanAge extending int16 {
  constraint max_value(120);
}
</code></pre>
<p>We originally made <code>HumanAge</code> for humans to use because vampires can live forever, but humans only live up to 120. But now we can simplify things. First we move the <code>age</code> property over to the <code>Person</code> type. Then (inside the <code>NPC</code> type) we use <code>overloaded</code> to add a constraint on it there:</p>
<pre><code class="language-sdl">type NPC extending Person {
  overloaded age: int16 {
    constraint max_value(120);
  }
}
</code></pre>
<p>This is convenient because we can delete <code>age</code> from <code>Vampire</code> too. We don't need to use <code>overloaded</code> here because vampires can live up to the maximum value of 32767 for <code>int16</code> which, as far as we are concerned, is forever. The <code>Vampire</code> type will now look like this:</p>
<pre><code class="language-sdl">type Vampire extending Person {
  # age: int16; **Deleted now
  multi slaves: MinorVampire;
}
</code></pre>
<p>Okay, let's do another migration and then read the rest of the introduction for this chapter. It continues to explain what Lucy is up to:</p>
<blockquote>
<p>...Lucy chooses to marry Arthur Holmwood, and says sorry to the other two. The other two men are sad, but fortunately all three men become friends with each other.</p>
<p>Dr. Seward is depressed and tries to concentrate on his work. He is a psychiatrist who works in an asylum close to a large mansion called Carfax not far outside London. Inside the asylum is a strange man named Renfield that Dr. Seward finds most interesting. Renfield is sometimes calm, sometimes completely crazy, and Dr. Seward doesn't know why he changes his mood so quickly. Also, Renfield seems to believe that he can get power from living things by eating them!! Renfield isn't exactly a vampire, but seems to act similar sometimes.</p>
</blockquote>
<p>Oops! Looks like Lucy doesn't have three lovers anymore.  We will have to remove her as a lover from the other two gentlemen. We'll just update each of them a sad empty set.</p>
<pre><code class="language-edgeql">update NPC filter .name in {'John Seward', 'Quincey Morris'}
set {
  lovers := {} # üò¢
};
</code></pre>
<p>That makes it easy to update Lucy's <code>lovers</code> link, since we know she now only shows up inside the <code>lovers</code> for Arthur Holmwood.</p>
<pre><code class="language-edgeql">update NPC filter .name = 'Lucy Westenra'
  set {
    lovers := (
    select Person filter NPC in .lovers
)};
</code></pre>
<p>Looks like we are mostly up to date now. The only thing left is to insert the mysterious Renfield. He is easy because he has no lover to <code>filter</code> for:</p>
<pre><code class="language-edgeql">insert NPC {
  name := 'Renfield',
  first_appearance := cal::to_local_date(1893, 5, 26),
  strength := 10,
};
</code></pre>
<p>But he has some sort of relationship to Dracula, similar to the <code>MinorVampire</code> type but different. He is also quite strong (as we will see later), so we gave him a <code>strength</code> of 10. Later on we'll learn more and more about him and his relationship with Dracula.</p>
<p><a href="chapter9/code.html">Here is all our code so far up to Chapter 9.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice-8"><a class="header" href="#time-to-practice-8">Time to practice</a></h2>
<ol>
<li>
<p>Why doesn't this insert work and how can it be fixed?</p>
<pre><code class="language-edgeql">for castle in
  ['Windsor Castle', 'Neuschwanstein', 'Hohenzollern Castle']
union (
  insert Castle {
    name := castle
  }
);
</code></pre>
</li>
<li>
<p>How would you do the same insert while displaying the castle's name at the same time?</p>
</li>
<li>
<p>How would you change the <code>Vampire</code> type if all vampires needed a minimum strength of 10?</p>
</li>
<li>
<p>How would you update all the <code>Person</code> types to show that they died on September 11, 1893?</p>
<p>Hint: here's the type again:</p>
<pre><code class="language-sdl">abstract type Person {
  required name: str {
    delegated constraint exclusive;
  }
  age: int16;
  strength: int16;
  multi places_visited: Place;
  multi lovers: Person;
  first_appearance: cal::local_date;
  last_appearance: cal::local_date;
}
</code></pre>
</li>
<li>
<p>All the <code>Person</code> characters that have an <code>e</code> or an <code>a</code> in their name have been brought back to life. How would you update to do this?</p>
<p>Hint: &quot;bringing back to life&quot; means that <code>last_appearance</code> should return <code>{}</code>.</p>
</li>
</ol>
<p><a href="chapter9/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>Thick fog and a storm hit the city of Whitby.</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="tags-tuples-computed-properties-math"><a class="header" href="#tags-tuples-computed-properties-math">tags: Tuples, Computed Properties, Math</a></h2>
<h1 id="chapter-10---terrible-events-in-whitby"><a class="header" href="#chapter-10---terrible-events-in-whitby">Chapter 10 - Terrible events in Whitby</a></h1>
<blockquote>
<p>Mina and Lucy are enjoying their time in Whitby. They spend a lot of time hiking nearby the coast and enjoying the view from the ruins of Whitby Abbey, an old church from long ago. One night there is a huge storm and a ship arrives in the fog - it's the Demeter, carrying Dracula. Lucy later begins to sleepwalk at night and looks very pale, and always says strange things. Mina tries to stop her, but sometimes Lucy gets outside.</p>
<p>One night Lucy watches the sun go down and says: &quot;His red eyes again! They are just the same.&quot; Mina is worried and asks Dr. Seward for help, who examines Lucy. She is pale and weak, but Dr. Seward doesn't know why. He decides to call his old teacher Abraham Van Helsing, who comes from the Netherlands to help. Van Helsing examines Lucy and looks shocked. Then he turns to the others and says, &quot;Listen. We can help this girl, but you are going to find the methods very strange. You are going to have to trust me...&quot;</p>
</blockquote>
<p>The city of Whitby is in the northeast of England. Right now our <code>City</code> type just extends <code>Place</code>, which only gives us the properties <code>name</code>, <code>modern_name</code> and <code>important_places</code>. This could be a good time to give it a <code>population</code> property which can help us draw the cities in our game. It will be an <code>int64</code> to give us the size we need:</p>
<pre><code class="language-sdl">type City extending Place {
  population: int64;
}
</code></pre>
<p>By the way, here are the approximate populations for our five cities at the time of the book. They were much smaller back in 1893:</p>
<ul>
<li>Buda-Pesth (Budapest): 402706</li>
<li>London: 3500000</li>
<li>Munich: 230023</li>
<li>Whitby: 14400</li>
<li>Bistritz (Bistri»õa): 9100</li>
</ul>
<p>Now let's do a migration.</p>
<p>Whitby is the only one of the five that isn't in our database already. Inserting it is easy enough:</p>
<pre><code class="language-edgeql">insert City {
  name := 'Whitby',
  population := 14400,
  important_places := ['Whitby Abbey']
};
</code></pre>
<p>But for the rest of them it would be nice to update everything at the same time.</p>
<h2 id="working-with-tuples-and-arrays"><a class="header" href="#working-with-tuples-and-arrays">Working with tuples and arrays</a></h2>
<p>If we have all the city data together, we can do a single insert with a <code>for</code> and <code>union</code> loop again. Let's imagine that the city data we have inside tuples, which seem similar to arrays but are quite different. One big difference is that a tuple can hold different types, so this is okay:</p>
<pre><code>('Buda-Pesth', 402706), ('London', 3500000), 
('Munich', 230023),     ('Bistritz', 9100)
</code></pre>
<p>In this case, the type is called a <code>tuple&lt;str, int64&gt;</code>.</p>
<p>Before we start using these tuples, let's make sure that we understand the difference between tuples and arrays. To start, let's look at slicing arrays and strings in a bit more detail.</p>
<p>Previously we learned how to use square brackets to access part of an array or a string. So this query:</p>
<pre><code class="language-edgeql">select ['Mina Murray', 'Lucy Westenra'][1];
</code></pre>
<p>will give the output <code>{'Lucy Westenra'}</code> (that's index number 1).</p>
<p>We also learned that we can use a colon to indicate the starting and ending index, like in this example:</p>
<pre><code class="language-edgeql">select NPC.name[0:10];
</code></pre>
<p>The output shows the first ten letters of every NPC's name:</p>
<pre><code>{
  'The innkee',
  'Mina Murra',
  'Jonathan H',
  'Lucy Weste',
  'John Sewar',
  'Quincey Mo',
  'Arthur Hol',
  'Renfield',
}
</code></pre>
<p>But the same can be done with a negative number if you want to start from the index at the end. For example:</p>
<pre><code class="language-edgeql">select NPC.name[2:-2];
</code></pre>
<p>This prints from index 2 up to 2 indexes away from the end (in other words, it'll cut off two letters from each side). Here's the output:</p>
<pre><code>{
  'e innkeep',
  'na Murr',
  'nathan Hark',
  'cy Westen',
  'hn Sewa',
  'incey Morr',
  'thur Holmwo',
  'nfie',
}
</code></pre>
<p>Tuples are very different. You can think of them as similar to object types with properties that are numbered instead of named. This is why tuples can hold different types together: <code>str</code> with <code>array&lt;bool&gt;</code>, <code>int64</code> with <code>float32</code>, you name it.</p>
<p>So this is completely fine:</p>
<pre><code class="language-edgeql">select {
  ('Bistritz', 9100, cal::to_local_date(1893, 5, 6)),
  ('Munich', 230023, cal::to_local_date(1893, 5, 8))
};
</code></pre>
<p>The output is:</p>
<pre><code>{
  ('Bistritz', 9100, &lt;cal::local_date&gt;'1893-05-06'),
  ('Munich', 230023, &lt;cal::local_date&gt;'1893-05-08'),
}
</code></pre>
<p>You can really see how similar tuples are to object types by doing a query on one of their properties. Here is the same query as above, except that we will select property <code>.0</code> instead of the whole set:</p>
<pre><code class="language-edgedb">select {
  ('Bistritz', 9100, cal::to_local_date(1893, 5, 6)),
  ('Munich', 230023, cal::to_local_date(1893, 5, 8))
}.0; # Only the .0 is different from the query above
</code></pre>
<p>The output is <code>{'Bistritz', 'Munich'}</code>, so pretty much the same as doing a <code>select City.name</code>;</p>
<p>Tuples can hold multiple types (this one is type <code>tuple&lt;str, int64, cal::local_date&gt;</code>), but you can't work with tuples of different types. So this is not allowed:</p>
<pre><code class="language-edgeql">select {(1, 2, 3), (4, 5, '6')};
</code></pre>
<p>EdgeDB will give an error because it won't try to work with tuples that are of different types. It complains:</p>
<pre><code>error: InvalidTypeError: set constructor has arguments of incompatible types 
'tuple&lt;std::int64, std::int64, std::int64&gt;' and 
'tuple&lt;std::int64, std::int64, std::str&gt;'
  ‚îå‚îÄ &lt;query&gt;:1:8
  ‚îÇ
1 ‚îÇ select {(1, 2, 3), (4, 5, '6')};
  ‚îÇ        ^^^^^^^^^^^^^^^^^^^^^^^^ Consider using an explicit type cast 
  or a conversion function.
</code></pre>
<p>You'll notice that the error suggests that we cast one of the items inside one of the tuples to match the other. Doing so removes the error and EdgeDB is happy again:</p>
<pre><code class="language-edgeql">select {(1, 2, 3), (4, 5, &lt;int64&gt;'6')};
</code></pre>
<p>Now that we know all this, we can update all our cities at the same time. It looks like this:</p>
<pre><code class="language-edgeql">for data in {('Buda-Pesth', 402706), ('London', 3500000),
  ('Munich', 230023), ('Bistritz', 9100)}
union (
  update City filter .name = data.0
  set {
    population := data.1
  }
);
</code></pre>
<p>So this query accesses each tuple one at a time in the <code>for</code> loop, filters by the string (which is <code>data.0</code>) and then updates with the population (which is <code>data.1</code>).</p>
<p>You can actually choose to give names to the items inside tuples if you like. This makes them feel even more like the object types in our schema. Here are the same cities except now we can access them by name:</p>
<pre><code class="language-edgeql">with cities := 
(
  (name := 'Buda-Pesth', pop := 402706), 
  (name := 'London',     pop := 3500000), 
  (name := 'Munich',     pop := 230023),
  (name := 'Bistritz',   pop := 9100)
),
  select cities.1.pop;
</code></pre>
<p>This returns <code>{3500000}</code>, the population of London.</p>
<p>Similarly, we can give each of the tuples inside the <code>cities</code> tuple a name too!</p>
<pre><code class="language-edgeql">with cities := 
(
  budapest := (name := 'Buda-Pesth', pop := 402706), 
  london   := (name := 'London',     pop := 3500000), 
  munich   := (name := 'Munich',     pop := 230023),
  bistritz := (name := 'Bistritz',   pop := 9100)
  ),
  select cities.munich.pop;
</code></pre>
<p>Now we get <code>{230023}</code>, the population of Munich.</p>
<p>You can still access items inside tuples by numbers even if they have a name:</p>
<pre><code>db&gt; select (name := 'Jonathan Harker', age := 25).0;
{'Jonathan Harker'}
db&gt; select (name := 'Jonathan Harker', age := 25).name;
{'Jonathan Harker'}
</code></pre>
<p>And also note that if you choose to name the items inside a tuple you have to name them all. So this won't work:</p>
<pre><code class="language-edgeql">select ('Jonathan Harker', age := 25).age;
</code></pre>
<p>Let's finish this section with a final note about casting. We know that we can cast into any scalar type, and this works for tuples of scalar types too. It uses the same format with <code>&lt;&gt;</code> except that you put it inside of <code>&lt;tuple&gt;</code>. This is a convenient way to do multiple casts at the same time. Take this query for example:</p>
<pre><code class="language-edgeql">with london := ('London', 3500000),
select &lt;tuple&lt;json, int32&gt;&gt;london;
</code></pre>
<p>Using <code>&lt;tuple&lt;json, int32&gt;&gt;</code> lets us cast the whole tuple instead of doing a cast for each individual type inside the tuple.</p>
<p>That gives us this output:</p>
<pre><code>{(Json(&quot;\&quot;London\&quot;&quot;), 3500000)}
</code></pre>
<p>Here's another example if we need to do some math with floats to calculate an increase in London's population:</p>
<pre><code class="language-edgeql">with 
  london := ('London', 3500000),
  # Cast into a float so we can do some precise math
  float_london := &lt;tuple&lt;str, float64&gt;&gt;(london),
  # Increase population, cast back for readability
  select &lt;tuple&lt;str, int32&gt;&gt;(float_london.0, float_london.1 * 1.035);
</code></pre>
<p>The output is <code>{('London', 3622500)}</code>.</p>
<h2 id="more-on-ordering-and-using-math"><a class="header" href="#more-on-ordering-and-using-math">More on ordering and using math</a></h2>
<p>Now that we have some numbers, we can start playing around with ordering and math. We tried out ordering for the first time in Chapter 7 and it was quite simple: type <code>order by</code> and then indicate the property/link you want to order by. Here we order them by population:</p>
<pre><code class="language-edgeql">select City {
  name,
  population
} order by .population desc;
</code></pre>
<p>This returns:</p>
<pre><code>{
  default::City {name: 'London', population: 3500000},
  default::City {name: 'Buda-Pesth', population: 402706},
  default::City {name: 'Munich', population: 230023},
  default::City {name: 'Whitby', population: 14400},
  default::City {name: 'Bistritz', population: 9100},
}
</code></pre>
<p>What's <code>desc</code>? It means descending, so largest first and then going down. If we didn't write <code>desc</code> then it would have assumed that we wanted to sort ascending. You can also write <code>asc</code> (to make it clear to somebody reading the code for example), but you don't need to.</p>
<p>For some actual math, you can check out the functions in <code>std</code> {eql:func}<code>here &lt;docs:std::sum&gt;</code> as well as the <code>math</code> module {ref}<code>here &lt;docs:ref_std_math&gt;</code>. Instead of looking at each function separately, let's do a single big query to show many of them together. To make the output nice, we will write it together with strings explaining the results and then cast them all to <code>&lt;str&gt;</code> so we can join them together using <code>++</code>.</p>
<pre><code class="language-edgeql">with pop := City.population
select (
  'Number of cities with population data: ' ++ &lt;str&gt;count(pop),
  'All cities have more than 50,000 people: ' ++ &lt;str&gt;all(pop &gt; 50000),
  'Total population: ' ++ &lt;str&gt;sum(pop),
  'Smallest/largest population: ' ++ &lt;str&gt;min(pop) ++ ', ' ++ &lt;str&gt;max(pop),
  'Average population: ' ++ &lt;str&gt;math::mean(pop),
  'Any cities with more than 5 million people? ' ++ &lt;str&gt;any(pop &gt; 5000000),
  'Standard deviation: ' ++ &lt;str&gt;math::stddev(pop)
);
</code></pre>
<p>This query used quite a few functions, all of which work on sets:</p>
<ul>
<li><code>count()</code> to count the number of items,</li>
<li><code>all()</code> to return <code>{true}</code> if all items match and <code>{false}</code> otherwise,</li>
<li><code>sum()</code> to add them all together,</li>
<li><code>max()</code> to return the highest value,</li>
<li><code>min()</code> to return the lowest value,</li>
<li><code>math::mean()</code> to give the average,</li>
<li><code>any()</code> to return <code>{true}</code> if any item matches and <code>{false}</code> otherwise, and</li>
<li><code>math::stddev()</code> for the standard deviation.</li>
</ul>
<p>The output also makes it clear how they work:</p>
<pre><code>{
  (
    'Number of cities with population data: 5',
    'All cities have more than 50,000 people: false',
    'Total population: 4156229',
    'Smallest/largest population: 9100, 3500000',
    'Average population: 831245.8',
    'Any cities with more than 5 million people? false',
    'Standard deviation: 1500876.8248',
  ),
}
</code></pre>
<p><code>any()</code>, <code>all()</code> and <code>count()</code> are particularly useful in operations to give you an idea of your data.</p>
<h2 id="importing-modules-using-the-with-keyword"><a class="header" href="#importing-modules-using-the-with-keyword">Importing modules using the <code>with</code> keyword</a></h2>
<p>You can use the <code>with</code> keyword to import modules too. In the example above we used two functions from EdgeDB's <code>math</code> module: <code>math::mean()</code> and <code>math::stddev()</code>. Just writing <code>mean()</code> and <code>stddev()</code> would produce this error:</p>
<pre><code>edgedb error: InvalidReferenceError: function 'default::mean' does not exist
</code></pre>
<p>If you don't want to write the module name every time you can just import the module after <code>with</code>. Let's slip that into the query we just used. See if you can see what's changed:</p>
<pre><code class="language-edgeql">with 
  pop := City.population,
  module math,
select (
  'Number of cities with population data: ' ++ &lt;str&gt;count(pop),
  'All cities have more than 50,000 people: ' ++ &lt;str&gt;all(pop &gt; 50000),
  'Total population: ' ++ &lt;str&gt;sum(pop),
  'Smallest/largest population: ' ++ &lt;str&gt;min(pop) ++ ', ' ++ &lt;str&gt;max(pop),
  'Average population: ' ++ &lt;str&gt;mean(pop),
  'Any cities with more than 5 million people? ' ++ &lt;str&gt;any(pop &gt; 5000000),
  'Standard deviation: ' ++ &lt;str&gt;stddev(pop)
);
</code></pre>
<p>The output is the same, but we added an import of the <code>math</code> module, letting us just write <code>mean()</code> and <code>stddev()</code>.</p>
<p>You can also use <code>as</code> to rename a module (well, to <em>alias</em> a module) in the same way that you can rename a type. So this will work too:</p>
<pre><code class="language-edgeql">with M as module math,
select M::mean(City.population);
</code></pre>
<p>That gives us the mean: <code>{831245.8}</code>.</p>
<p>You can also set a module as the default just by typing <code>set module</code> followed by the module name. This will unset the default module though. So the same query as above would look like this:</p>
<pre><code>db&gt; set module math;
OK: SET ALIAS
# Note: default::City instead of just City
db&gt; select mean(default::City.population);
</code></pre>
<p>This makes it easy to have separate modules (<code>module test</code> for example with test types and data) that you can quickly switch to and query without needing to type too much.</p>
<h2 id="some-more-computed-properties-for-names"><a class="header" href="#some-more-computed-properties-for-names">Some more computed properties for names</a></h2>
<p>We saw in this chapter that Dr. Seward asked his old teacher Dr. Van Helsing to come and help Lucy. Here is how Dr. Van Helsing began his letter to say that he was coming:</p>
<pre><code>Letter, Abraham Van Helsing, M. D., D. Ph., D. Lit., etc., etc., to Dr. Seward.

‚Äú2 September.

‚ÄúMy good Friend,‚Äî
‚ÄúWhen I have received your letter I am already coming to you.
</code></pre>
<p>The <code>Abraham Van Helsing, M. D., D. Ph., D. Lit., etc., etc.</code> part is interesting. This might be a good time to think more about the <code>name</code> property inside our <code>Person</code> type. Right now our <code>name</code> property is just a single string, but we have people with different types of names, in this order:</p>
<p>Title | First name | Last name | Degree</p>
<p>Here are some examples:</p>
<ul>
<li>'Count Dracula' (title + name),</li>
<li>'Dr. Seward' (title + name),</li>
<li>'John Seward, M.D.' (name + degree),</li>
<li>'Mr. Renfield' (title + name),</li>
<li>'Dr. Abraham Van Helsing, M.D, Ph. D. Lit.' (title + first name + last name + degrees),</li>
<li>'Lord Godalming' (title + name)</li>
</ul>
<p>That would lead us to think that we should have properties like <code>first_name</code>, <code>last_name</code>, and <code>title</code> and then join them together using a computed property. But then again, not every character has these exact four parts to their name. Some others that don't are 'Vampire Woman 1' and 'The Innkeeper', and our game would certainly have a lot more of these. It's also somewhat rare to use all four of these properties together: Van Helsing's friends call him &quot;Doctor Van Helsing&quot;, not &quot;Dr. Abraham Van Helsing, M.D, Ph. D. Lit.&quot;!</p>
<p>So it's probably not a good idea to get rid of <code>name</code> and to always build names from separate parts. But in our game we might have characters writing letters or talking to each other, and they will have to use things like titles and degrees.</p>
<p>We could try a middle of the road approach for our <code>Person</code> type instead. We'll keep <code>name</code>, and add some computed properties below it. The property <code>degrees</code> will be an <code>array&lt;str&gt;</code>. We can then use the <code>array_join()</code> function to join them together. This function takes an array, plus a string called a <code>delimeter</code> to tell the function what to place in between each item in the array.</p>
<p>Here are two quick examples of <code>array_join()</code>:</p>
<pre><code># No delimiter, so just joins the two strings
db&gt; select array_join(['Jonathan ', 'Harker'], '');
{'Jonathan Harker'}
# Delimiter of comma and space
db&gt; select array_join(['And a one', 'and a two', 'and a three'], ', ');
{'And a one, and a two, and a three'}
# Without the delimiter:
db&gt; select array_join(['And a one', 'and a two', 'and a three'], '');
{'And a oneand a twoand a three'}
</code></pre>
<p>Now here is the <code>Person</code> type with its new properties:</p>
<pre><code class="language-sdl">abstract type Person {
  required name: str {
    delegated constraint exclusive;
  }
  multi places_visited: Place;
  multi lovers: Person;
  property is_single := not exists .lovers;
  strength: int16;
  first_appearance: cal::local_date;
  last_appearance: cal::local_date;
  age: int16;
  title: str;
  degrees: array&lt;str&gt;;
  property conversational_name := .title ++ ' ' 
    ++ .name if exists .title else .name;
  property pen_name := .name ++ ', ' 
     ++ array_join(.degrees, ', ') if exists .degrees else .name;
}
</code></pre>
<p>Let's do a migration now, and try an insert for Van Helsing...or rather, Dr. Van Helsing!</p>
<pre><code class="language-edgeql">insert NPC {
  name := 'Abraham Van Helsing',
  title := 'Dr.',
  degrees := ['M.D.', 'Ph. D. Lit.', 'etc.']
};
</code></pre>
<p>John Seward is a doctor too so let's be sure to update him with a proper title and degree.</p>
<pre><code class="language-edgeql">update NPC filter .name = 'John Seward'
set { 
  title := 'Dr.',
  degrees := ['M.D.']
};
</code></pre>
<p>Now we can make use of these properties to liven up our conversation engine in the game. For example:</p>
<pre><code class="language-edgeql">with educated := (select Person filter exists .title and exists .degrees)
  select (
  'There goes ' ++ educated.name ++ '.',
  'I say! Are you ' ++ educated.conversational_name ++ '?',
  'I have a letter from you signed as follows:\n\t'
     ++ educated.pen_name);
</code></pre>
<p>By the way, the <code>\n</code> inside the string creates a <em>new</em> line, while <code>\t</code> moves it one <em>tab</em> to the right.</p>
<p>This gives us:</p>
<pre><code>{
  (
    'There goes Abraham Van Helsing.',
    'I say! Are you Dr. Abraham Van Helsing?',
    'I have a letter from you signed as follows:
        Abraham Van Helsing, M.D., Ph. D. Lit., etc.',
  ),
  (
    'There goes John Seward.',
    'I say! Are you Dr. John Seward?',
    'I have a letter from you signed as follows:
        John Seward, M.D.',
  ),
}
</code></pre>
<p>If this were just a standard database with website users it would be much simpler: get users to enter their first names and last names and then use these two properties to compute a full name. But the setting in Bram Stoker's Dracula is much more complex than that!</p>
<h2 id="other-escape-characters-and-raw-strings"><a class="header" href="#other-escape-characters-and-raw-strings">Other escape characters and raw strings</a></h2>
<p>Besides <code>\n</code> and <code>\t</code> there are quite a few other escape characters - you can see the complete list {ref}<code>here &lt;docs:ref_eql_lexical_str_escapes&gt;</code>. Some are rare but hexadecimal with <code>\x</code> and unicode escape character with <code>\u</code> are two that might be useful.</p>
<p>For a quick example of unicode escape characters, try pasting this into your REPL to decode it into what Van Helsing had to say during his first visit.</p>
<pre><code class="language-edgeql">select '\u004E\u0061\u0079\u002C\u0020\u0049\u0020\u0061\u006D
\u006E\u006F\u0074\u0020\u006A\u0065\u0073\u0074\u0069\u006E\u0067\u002E
\u0054\u0068\u0069\u0073\u0020\u0069\u0073\u0020\u006E\u006F
\u006A\u0065\u0073\u0074\u002C\u0020\u0062\u0075\u0074
\u006C\u0069\u0066\u0065\u0020\u0061\u006E\u0064\u0020\u0064\u0065\u0061\u0074\u0068\u002C
\u0070\u0065\u0072\u0068\u0061\u0070\u0073\u0020\u006D\u006F\u0072\u0065\u002E\u2019';
</code></pre>
<p>If you want to ignore escape characters, put an <code>r</code> (which stands for <em>raw</em>) in front of the quote. Let's try it with the example above. Only the last part has an <code>r</code>:</p>
<pre><code class="language-edgeql">with educated := (select Person filter exists .title and exists .degrees)
  select (
  'I say! Are you ' ++ educated.conversational_name ++ '?',
  r'I have a letter from you signed as follows:\n\t'
     ++ educated.pen_name);
</code></pre>
<p>Now we get:</p>
<pre><code>{
  (
    'I say! Are you Dr. Abraham Van Helsing?',
    'I have a letter from you signed as follows:\\n\\tAbraham Van Helsing, M.D., Ph. D. Lit., etc.',
  ),
  (
    'I say! Are you Dr. John Seward?',
    'I have a letter from you signed as follows:\\n\\tJohn Seward, M.D.',
  ),
}
</code></pre>
<p>Finally, EdgeDB can also use <code>$$</code> to make raw string literals. Any string inside this will ignore any and all quotation marks and escape characters, so you won't have to worry about the string ending in the middle. Here's one example with a bunch of single and double quotes inside:</p>
<pre><code class="language-edgeql">select $$ 
&quot;Dr. Van Helsing would like to tell &quot;them&quot; 
about &quot;vampires&quot; and how to &quot;kill&quot; them, 
but he'd sound crazy.&quot;
$$;
</code></pre>
<p>Without the <code>$$</code> EdgeDB would generate an error as it would treat the input as four separate strings with three unknown keywords between them. From EdgeDB's point of view the input would look like this:</p>
<pre><code>&quot;Dr. Van Helsing would like to tell &quot;
them
&quot; about &quot;
vampires
&quot; and how to &quot;
kill
&quot; them, but he'd sound crazy.&quot;
</code></pre>
<h2 id="using-unless-conflict-on--else--update"><a class="header" href="#using-unless-conflict-on--else--update">Using <code>unless conflict on</code> + <code>else</code> + <code>update</code></a></h2>
<p>We have an <code>constraint exclusive</code> on <code>name</code> so that we won't be able to have two characters with the same name. The idea is that someone might see a character in the book and insert it, and then someone else would try to do the same. So this character named Johnny will work:</p>
<pre><code class="language-edgeql">insert NPC {
  name := 'Johnny'
};
</code></pre>
<p>But if we try again we will get this error:</p>
<pre><code>edgedb error: ConstraintViolationError: name violates exclusivity constraint
</code></pre>
<p>But sometimes just generating an error isn't enough - maybe we want something else to happen instead of just giving up. This is where <code>unless conflict on</code> comes in, followed by an <code>else</code> to explain what to do to the existing object.</p>
<p><code>unless conflict on</code> is easiest to explain through an example. We've already populated our database with some city data that comes from the year 1880, but what if we came across some data for 1885 instead which is closer to the setting in the book? Larger cities have better items, more NPCs and quests to do in our game, so having an accurate population is important. But we can't just use <code>insert</code> everywhere, because cities like Munich are already in the database. So this insert would just generate an error and give up:</p>
<pre><code class="language-edgeql"># Munich had a population of 230,023 in 1880 and 261,023 in 1885
insert City {
  name := 'Munich',
  population := 261023
};
</code></pre>
<p>However, we also can't just <code>update</code> every <code>City</code> object either, because a lot of the cities in the 1885 data aren't in the 1880 data - they are new cities. In this case we would like to <em>try</em> to insert a new <code>City</code> object. But if the object already exists, then update its population instead of just giving up.</p>
<p>The way to accomplish this is by first trying an insert, then following with <code>unless conflict on</code>, <code>else</code> and <code>update</code>.</p>
<p>Here is how we would do it for Munich:</p>
<pre><code class="language-edgeql">insert City {
  name := 'Munich',
  population := 261023,
} unless conflict on .name
else (
  update City
  set {
    population := 261023,
  }
);
</code></pre>
<p>Here we tell EdgeDB to keep an eye out for any conflicts by using <code>unless conflict on .name</code>, followed by <code>else</code> to give instructions on what to do to the existing object in the database. Also note that we don't write <code>else insert</code>, because the conflict means that we are unable to do an <code>insert</code>. What we write instead is <code>update</code> for the conflicting object that is already in the database: <code>update City</code>.</p>
<p>With this, we are guaranteed to get a <code>City</code> object called Munich with a population of 261,023, whether it already exists in the database or not.</p>
<p><a href="chapter10/code.html">Here is all our code so far up to Chapter 10.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice-9"><a class="header" href="#time-to-practice-9">Time to practice</a></h2>
<ol>
<li>
<p>Try inserting two <code>NPC</code> types in one insert with the following <code>name</code>, <code>first_appearance</code> and <code>last_appearance</code> information.</p>
<p><code>{('Jimmy the Bartender', '1893-09-10', '1893-09-11'), ('Some friend of Jonathan Harker', '1893-07-08', '1893-07-09')}</code></p>
</li>
<li>
<p>Here are two more <code>NPC</code>s to insert, except the last one has an empty set (she's not dead). What problem are we going to have?</p>
<p><code>{('Dracula\'s Castle visitor', '1893-09-10', '1893-09-11'), ('Old lady from Bistritz', '1893-05-08', {})}</code></p>
</li>
<li>
<p>How would you order the <code>Person</code> types by last letter of their names?</p>
</li>
<li>
<p>Try inserting an <code>NPC</code> with the name <code>''</code>. Now how would you do the same query in question 3?</p>
<p>Hint: the length of <code>''</code> is 0, which may be a problem.</p>
</li>
<li>
<p>Dr. Van Helsing has a list of <code>MinorVampire</code>s with their names and strengths. We already have some <code>MinorVampire</code>s in the database. How would you <code>insert</code> them while making sure to <code>update</code> if the object is already there?</p>
</li>
</ol>
<p><a href="chapter10/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>Will they believe Van Helsing when he tells them the truth?</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="tags-writing-functions-multiplication-coalescing-grouping"><a class="header" href="#tags-writing-functions-multiplication-coalescing-grouping">tags: Writing Functions, Multiplication, Coalescing, Grouping</a></h2>
<h1 id="chapter-11---whats-wrong-with-lucy"><a class="header" href="#chapter-11---whats-wrong-with-lucy">Chapter 11 - What's wrong with Lucy?</a></h1>
<blockquote>
<p>Dr. Van Helsing thinks that Lucy is being visited by a vampire. He doesn't tell the others yet because they won't believe him, but says they should close the windows and place garlic flowers everywhere in Lucy's room. They are confused, but Dr. Seward tells them to listen: Dr. Van Helsing is the smartest person he knows. It works, and Lucy gets better.</p>
<p>But one night Lucy's mother walks into the room and thinks: &quot;This place smells terrible! I'll open the windows for some fresh air.&quot; The next day Lucy wakes up pale and sick again. Every time someone makes a mistake like this Dracula gets in her room, and every time the men give Lucy their blood to help her get better. But Lucy is getting weaker and weaker as the days go by.</p>
<p>Meanwhile, Renfield continues to try to eat living things and Dr. Seward can't understand him. Then one day Renfield doesn't want to talk at all, only saying: ‚ÄúI don‚Äôt want to talk to you: you don‚Äôt count now; the Master is at hand.‚Äù</p>
</blockquote>
<p>We are starting to see more and more events in the book with various characters. Some events have the three men and Dr. Van Helsing together, others have just Lucy and Dracula. Previous events had Jonathan Harker and Dracula, Jonathan Harker and the three women, and so on. In our game, we could use a sort of <code>Event</code> type to group everything together: the people, the time, the place, and so on.</p>
<p>This <code>Event</code> type is a bit long, but it could be the main type for our events in the game so it needs to be detailed. We can put it together like this:</p>
<pre><code class="language-sdl">type Event {
  required description: str;
  required start_time: cal::local_datetime;
  required end_time: cal::local_datetime;
  required multi place: Place;
  required multi people: Person;
  location: tuple&lt;float64, float64&gt;;
  property ns_suffix := '_N_' if .location.0 &gt; 0.0 else '_S_';
  property ew_suffix := '_E' if .location.1 &gt; 0.0 else '_W';
  property url := 'https://geohack.toolforge.org/geohack.php?params=' 
    ++ &lt;str&gt;(math::abs(.location.0)) ++ .ns_suffix 
    ++ &lt;str&gt;(math::abs(.location.1)) ++ .ew_suffix;
}
</code></pre>
<p>You can see that most of the properties are <code>required</code>, because an <code>Event</code> type is not useful if it doesn't have all the information we need. It will always need a description, a time, place, and people participating. The interesting part is the <code>url</code> property: it's a computed property that gives us an exact url for the location if we want, which can then be looked up on the Geohack tool used by Wikipedia. This property is not <code>required</code> because not every event in the book is in a perfectly known location.</p>
<p>The url that we are generating needs to know whether a location is east or west of Greenwich, and also whether they are north or south. Here is the url for Bistritz, for example (modern name Bistri»õa):</p>
<pre><code>https://geohack.toolforge.org/geohack.php?params=47.8_N_24.30_E
</code></pre>
<p>The <code>ns_suffix</code> property is either <code>_N_</code> or <code>_S_</code> depending on whether the latitute is greater than or less than zero. And <code>ew_suffix</code> is either <code>_E</code> or <code>_W</code> depending on whether the longitute is greater than or less than zero. The events in the book all take place in the north half of the planet, but we might as well give the possibility of exploring the south part of the globe. Who knows where the <code>PC</code> objects might end up exploring!</p>
<p>The <code>url</code> property is then computed using the two suffixes, plus the absolute values of the locations so that they show up as positive numbers in the url. EdgeDB just happens to have a function called <code>math::abs()</code> that will let us turn any number into an absolute number. So Whitby, which is located at 54.4858 and -0.6206, should show up as <code>54.4858_N_0.6206_W</code> in the url: both absolute numbers, but with a <code>W</code> to represent that Whitby is at 0.6206 degrees to the <em>west</em>.</p>
<p><img src="chapter11/Lat_long.svg" alt="An image showing how latitude and longitude are divided into north and south, and east and west" /></p>
<p>Let's do a migration to add this <code>Event</code> type, and then insert two of the events from the story that we are familiar with.</p>
<p>One event takes place on the night of September 11th when Dr. Van Helsing is trying to help Lucy. The other event takes place when the Demeter left the Black Sea, entered the Bosphorous and was boarded by Turkish customs officials on its long and tragic journey to England. We aren't sure exactly where the boarding took place, but the lighthouse called Rumeli Feneri looks like a good place for Turkish government officials to notice a ship, so let's insert that as an <code>OtherPlace</code> as we insert the <code>Event</code>. And the <code>people</code> involved in this <code>Event</code> are all the sailors on the ship, plus Dracula. To join them together we can use the <code>union</code> keyword in a few places: once to join the <code>Ship.sailors</code> with the <code>Ship.crew</code>, and then finally to join them with the <code>Vampire</code> object named 'Count Dracula'.</p>
<p>You can see that the <code>description</code> property in the <code>Event</code> type is just a string to make it easy to search later on. It can be as long or as short as we like, and we can even outright paste in parts of the book.</p>
<p>Here are the inserts for these two <code>Event</code>s:</p>
<pre><code class="language-edgeql">insert Event {
  description := &quot;Dr. Seward gives Lucy garlic flowers to help her sleep. She falls asleep and the others leave the room.&quot;,
  start_time := cal::to_local_datetime(1893, 9, 11, 18, 0, 0),
  end_time := cal::to_local_datetime(1893, 9, 11, 23, 0, 0),
  place := (select Place filter .name = 'Whitby'),
  people := (select Person filter .name ilike 
    {'%helsing%', '%westenra%', '%seward%'}),
  location := (54.4858, -0.6206),
};

with 
  ship_people := (select Ship.sailors union Ship.crew filter Ship .name = 'The Demeter'),
  dracula := (select Vampire filter .name = 'Count Dracula'),
insert Event {
  description := &quot;On 11 July at dawn entered Bosphorus. Boarded by Turkish Customs officers. Backsheesh. All correct. Under way at 4 p.m.&quot;,
  start_time := cal::to_local_datetime(1893, 7, 11, 7, 0, 0),
  end_time := cal::to_local_datetime(1893, 7, 11, 16, 0, 0),
  place := (insert OtherPlace {name := 'Rumeli Feneri'}),
  people := ship_people union dracula,
  location := (41.2350, 29.1100)
};
</code></pre>
<p>Let's do a query to show the location, place names, person names, and description for our events so far.</p>
<pre><code class="language-edgeql">select Event { 
  place_name := .place.name,
  map_url := .url,
  people_names := .people.name,
  description,
  };
</code></pre>
<p>It generates a nice output that shows us everything about the event:</p>
<pre><code>{
  default::Event {
    place_name: {'Whitby'},
    map_url: 'https://geohack.toolforge.org/geohack.php?params=54.4858_N_0.6206_W',
    people_names: {'John Seward', 'Abraham Van Helsing', 'Lucy Westenra'},
    description: 'Dr. Seward gives Lucy garlic flowers to help her sleep. She falls asleep and the others leave the room.',
  },
  default::Event {
    place_name: {'Rumeli Feneri'},
    map_url: 'https://geohack.toolforge.org/geohack.php?params=41.235_N_29.11_E',
    people_names: {
      'The Captain',
      'Petrofsky',
      'The First Mate',
      'The Cook',
      'Crewman 1',
      'Crewman 2',
      'Crewman 3',
      'Crewman 4',
      'Crewman 5',
      'Count Dracula',
    },
    description: 'On 11 July at dawn entered Bosphorus. Boarded by Turkish Customs officers. Backsheesh. All correct. Under way at 4 p.m.',
  },
}
</code></pre>
<p>The urls work nicely too. Here is one of them: <a href="https://geohack.toolforge.org/geohack.php?params=54.4858_N_0.6206_W">https://geohack.toolforge.org/geohack.php?params=54.4858_N_0.6206_W</a> Clicking on it takes you directly to the city of Whitby.</p>
<h2 id="writing-our-own-functions"><a class="header" href="#writing-our-own-functions">Writing our own functions</a></h2>
<p>We have seen quite a few functions in EdgeDB so far, but the number of functions is actually unlimited because you can also write your own! Similar to other languages, functions in EdgeDB take an input, apply some logic, and generate an output. But EdgeQL is strongly typed, so it won't accept just anything as is the case with languages like Javascript. That means that you have to indicate both the input type and the return type in the signature.</p>
<p>A function that takes an <code>int16</code> and returns a <code>float64</code> for example would have this signature:</p>
<pre><code class="language-sdl">function does_something(input: int16) -&gt; float64
</code></pre>
<p>The <code>-&gt;</code> skinny arrow is used to show the return value.</p>
<p>For the body of the function we do the following:</p>
<ul>
<li>Write <code>using</code> and then follow it up with <code>()</code> brackets,</li>
<li>Write the function inside it,</li>
<li>Finish with a semicolon.</li>
</ul>
<p>Here's a very simple function that takes a number and returns a string from it:</p>
<pre><code class="language-sdl">function make_string(input: int64) -&gt; str
  using (&lt;str&gt;input);
</code></pre>
<p>That's all there is to it! If you put this into your schema and do a migration then you will now be able to use this function.</p>
<p>Now let's make something a little more useful: a quick function to make our <code>Event</code> type a little nicer to read. Instead of putting <code>'https://geohack.toolforge.org/geohack.php?params='</code> inside the <code>Event</code> type, we can make a function called <code>get_url()</code> that simply returns this <code>str</code> for us. With that, our <code>url</code> property definition can be 42 characters shorter. Let's add this function to the schema and change the <code>url</code> in the <code>Event</code> type to use it:</p>
<pre><code class="language-sdl">function get_url() -&gt; str
  using (&lt;str&gt;'https://geohack.toolforge.org/geohack.php?params=');

type Event {
  required description: str;
  required start_time: cal::local_datetime;
  required end_time: cal::local_datetime;
  required multi place: Place;
  required multi people: Person;
  location: tuple&lt;float64, float64&gt;;
  property ns_suffix := '_N_' if .location.0 &gt; 0.0 else '_S_';
  property ew_suffix := '_E' if .location.1 &gt; 0.0 else '_W';
  property url := get_url() 
    ++ &lt;str&gt;(math::abs(.location.0)) ++ .ns_suffix 
    ++ &lt;str&gt;(math::abs(.location.1)) ++ .ew_suffix;
}
</code></pre>
<p>Next, let's write a function that's less useful but more fun and which will teach us some interesting concepts in EdgeDB. The function will have two <code>Person</code> objects fight each other, so we'll call it <code>fight()</code>. We will make it as simple as possible: the character with more strength wins, and if their strength is the same then the second player wins.</p>
<p>You might be tempted to write this function as follows, but it doesn't quite work!</p>
<pre><code class="language-sdl">function fight(one: Person, two: Person) -&gt; str
  using (
    one.name ++ ' wins!'
    if one.strength &gt; two.strength
    else two.name ++ ' wins!'
  );
</code></pre>
<p>The function <em>looks</em> good, but when you try to create it, you'll get an error. The line at the bottom of the error is the one to pay attention to.</p>
<pre><code>error: return cardinality mismatch in function declared to return exactly one value
    ‚îå‚îÄ C:\rust\easy-edgedb\dbschema\default.esdl:118:9
    ‚îÇ
118 ‚îÇ     using (
    ‚îÇ ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ^
119 ‚îÇ ‚îÇ     one.name ++ ' wins!'
120 ‚îÇ ‚îÇ     if one.strength &gt; two.strength
121 ‚îÇ ‚îÇ     else two.name ++ ' wins!'
122 ‚îÇ ‚îÇ   );
    ‚îÇ ‚ï∞‚îÄ‚îÄ‚îÄ^ error
    ‚îÇ
    = Function may return an empty set.
</code></pre>
<p>This happens because <code>strength</code> is not required on our <code>Person</code> type. That means that we might pass in one or two <code>Person</code> objects that have an empty set for <code>strength</code>, and then the function will return an empty set instead of a <code>str</code>. EdgeDB doesn't like this because we've told it in the function definition that the function will return a string.</p>
<p>We could go back and make <code>strength</code> a <code>required</code> property, but we would need to decide on values for all of our <code>Person</code> objects already in the database. That's a lot of trouble, and it's not something we're ready to do right now.</p>
<h2 id="providing-fallbacks-with-the-coalescing-operator"><a class="header" href="#providing-fallbacks-with-the-coalescing-operator">Providing fallbacks with the coalescing operator</a></h2>
<p>The easiest way to fix our function would be to provide some sort of fallback for the properties that might not be set. If someone doesn't have a strength, we could just default their strength to <code>0</code>.</p>
<p>To do that we can use the {eql:op}<code>coalescing operator &lt;docs:coalesce&gt;</code>, which is written <code>??</code>. It evaluates to whatever is on the left if that's not empty. Otherwise, it evaluates to whatever is on the right.</p>
<p>Here is a quick example of an empty set when the coalescing operator is not used:</p>
<pre><code class="language-edgeql">select &lt;str&gt;{} ++ 'Count Dracula is now in Whitby';
</code></pre>
<p>Interestingly, the output is <code>{}</code>! An empty set combined with anything else is an empty set. But if we change <code>++</code> to <code>??</code> for the coalescing operator, we can return a default value even if there is an empty set to the left.</p>
<pre><code class="language-edgeql">select &lt;str&gt;{} ?? 'Count Dracula is now in Whitby';
</code></pre>
<p>Since the set on the left is empty, the coalescing operator turns its attention to the set on the right and returns that: <code>{'Count Dracula is now in Whitby'}</code> If neither side of the operator is the empty set, the coalescing operator will produce whatever is on the left. If <em>both</em> sides are the empty set, it will produce the empty set.</p>
<p>Here's how we can use the coalescing operator to fix our function:</p>
<pre><code class="language-sdl">function fight(one: Person, two: Person) -&gt; str
  using (
    one.name ++ ' wins!' if (one.strength ?? 0) &gt; (two.strength ?? 0)
    else two.name ++ ' wins!'
  );
</code></pre>
<p>With this change, EdgeDB now has fallbacks in the event that a <code>Person</code> object has an empty set for its <code>strength</code> property: it will return a 0 instead of an empty set. This ensures that the function can always return the string response we promised.</p>
<p>Now that our function works, let's do a migration.</p>
<p>So far only Jonathan and Renfield have the property <code>strength</code>, so let's put them up against each other in this new <code>fight()</code> function:</p>
<pre><code class="language-edgeql">with
  renfield := (select Person filter .name = 'Renfield'),
  jonathan := (select Person filter .name = 'Jonathan Harker')
select (
  fight(jonathan, renfield)
);
</code></pre>
<p>It prints what we wanted to see: <code>{'Renfield wins!'}</code></p>
<p>It might also be a good idea to add <code>assert_single()</code> when doing a filter for this function. Because EdgeDB returns sets, if it gets multiple results then it will use the function against each one for each possible combination. The way EdgeDB handles this is through Cartesian multiplication, so let's learn about that now.</p>
<h2 id="cartesian-multiplication"><a class="header" href="#cartesian-multiplication">Cartesian multiplication</a></h2>
<p>Cartesian multiplication is a key concept in EdgeDB. The name sounds intimidating but it really just means &quot;evaluate every item in one set with every item in the other set&quot;. It's easiest to understand when viewed as an illustration, which fortunately Wikipedia has already made for us. When you do operations on multiple sets in EdgeDB you are given the Cartesian product, which looks like this:</p>
<p><img src="chapter11/cartesian_product.svg" alt="A chart displaying the Cartesian product of 1, 2, 3 multiplied by x, y, and z" /></p>
<p>Source: <a href="https://en.wikipedia.org/wiki/Cartesian_product#/media/File:Cartesian_Product_qtl1.svg">user quartl on Wikipedia</a></p>
<p>Here is a quick example of a query that operates on two sets. Since it will &quot;evaluate every item in one set with every item in the other set&quot;, what do you think the output will be?</p>
<pre><code>select { 'Jonathan', 'Lucy' } ++ ' ' ++ { 'Harker', 'Westenra'};
</code></pre>
<p>That's right, it is using <code>++</code> to concatenate and will concatenate every item in one set with every item in the other. So that will return a set of four strings:</p>
<pre><code>{'Jonathan Harker', 'Jonathan Westenra', 'Lucy Harker', 'Lucy Westenra'}
</code></pre>
<p>The extra <code>' '</code> in the middle doesn't increase the number of items in the set because it is just one item, and one multiplied by four is still four.</p>
<p>And if you add 'Mina' to the first set of names and 'Murray' to the second, the output will be a set of nine strings:</p>
<pre><code>{
  'Jonathan Harker',
  'Jonathan Westenra',
  'Jonathan Murray',
  'Lucy Harker',
  'Lucy Westenra',
  'Lucy Murray',
  'Mina Harker',
  'Mina Westenra',
  'Mina Murray',
}
</code></pre>
<p>This means that if we do a <code>select</code> on <code>Person</code> for our <code>fight()</code> function, it will run the function following this formula:</p>
<pre><code>{number of items in the first set}` \* `{number of items in the second set}
</code></pre>
<p>So if there are two in the first set, and three in the second, it will run the function six times.</p>
<p>To demonstrate, let's put three objects in for each side of our function. We'll be testing our <code>fight</code> function, so we'll just give all the characters strength value 5 if they don't already have some other value:</p>
<pre><code class="language-edgeql">update Person filter not exists .strength
set {
  strength := 5
};
</code></pre>
<p>We'll also make the output a little more clear:</p>
<pre><code class="language-edgeql">with
  first_group := (select Person filter .name in 
    {'Jonathan Harker', 'Count Dracula', 'Arthur Holmwood'}),
  second_group := (select Person filter .name in 
    {'Renfield', 'Mina Murray', 'The innkeeper'}),
select (
  first_group.name ++ ' fights against ' ++ second_group.name 
    ++ '. ' ++ fight(first_group, second_group)
);
</code></pre>
<p>Here is the output. It's a total of nine fights, where each person in Set 1 fights once against each person in Set 2.</p>
<pre><code>{
  'Jonathan Harker fights against Renfield. Renfield wins!',
  'Jonathan Harker fights against The innkeeper. The innkeeper wins!',
  'Jonathan Harker fights against Mina Murray. Mina Murray wins!',
  'Arthur Holmwood fights against Renfield. Renfield wins!',
  'Arthur Holmwood fights against The innkeeper. The innkeeper wins!',
  'Arthur Holmwood fights against Mina Murray. Mina Murray wins!',
  'Count Dracula fights against Renfield. Renfield wins!',
  'Count Dracula fights against The innkeeper. The innkeeper wins!',
  'Count Dracula fights against Mina Murray. Mina Murray wins!',
}
</code></pre>
<p>And if you take out the filter and just write <code>select Person</code> for the function, you will get well over 100 results. EdgeDB by default will only show the first 100, eventually displaying this after the first 100 results:</p>
<pre><code># First 98 results...
'Count Dracula wins!',
'Fighter 2 wins!',
 ... (further results hidden `\set limit 100`)
</code></pre>
<p>If you want to display more or less than a maximum of 100 (the default), just type <code>\set limit</code> followed by whichever number you like.</p>
<h2 id="grouping"><a class="header" href="#grouping">Grouping</a></h2>
<p>In the last chapter we learned how to use <code>order by</code> to order the results of a query, which produces a single set in a certain order. Let's do a quick query to ensure that we remember how to do this:</p>
<pre><code class="language-edgeql">select City {
  name, 
  population
} order by .population;
</code></pre>
<p>The result is a single set with the <code>City</code> objects ordered by population in ascending order (going up). If we had written <code>order by .population desc</code>, it would have gone in descending order.</p>
<pre><code>{
  default::City {name: 'Bistritz', population: 9100},
  default::City {name: 'Whitby', population: 14400},
  default::City {name: 'Munich', population: 230023},
  default::City {name: 'Buda-Pesth', population: 402706},
  default::City {name: 'London', population: 3500000},
}
</code></pre>
<p>Now let's say we want to do a similar query to see which NPCs are single and which are not. Looks a bit weird, doesn't it? After all, <code>.is_single</code> only returns <code>true</code> or <code>false</code>.</p>
<pre><code class="language-edgeql">select NPC {
  name, 
  is_single
} order by .is_single;
</code></pre>
<p>The output is indeed a bit weird:</p>
<pre><code>{
  default::NPC {name: 'Jonathan Harker', is_single: false},
  default::NPC {name: 'Mina Murray', is_single: false},
  default::NPC {name: 'Lucy Westenra', is_single: false},
  default::NPC {name: 'Arthur Holmwood', is_single: false},
  default::NPC {name: 'Abraham Van Helsing', is_single: true},
  default::NPC {name: 'John Seward', is_single: true},
  default::NPC {name: 'Renfield', is_single: true},
  default::NPC {name: 'The innkeeper', is_single: true},
  default::NPC {name: 'Quincey Morris', is_single: true},
}
</code></pre>
<p>The objects returning <code>false</code> do come before those that return <code>true</code>, but this isn't really an ordering. A true ordering would be more along the lines of single<em>ness</em> (let's say from 0 to 100) where a singleness of 0 represents one extreme (someone who is married and never ever has time alone), and a singleness of 100 the other extreme (someone who is absolutely always alone). And most people would have a number somewhere in between.</p>
<p>So what we are looking for here with <code>is_single</code> is not an ordering, but a grouping: one group of NPC objects that are single, and another group of NPC objects that are not. EdgeDB has an operator called <code>group</code> which does just that! To do a <code>group</code> query, just change <code>select</code> to <code>group</code>:</p>
<pre><code class="language-edgeql">group NPC {
  name, 
  is_single
} by .is_single;
</code></pre>
<p>The output for the <code>group</code> operator is quite nice, as each set includes two extra parameters:</p>
<ul>
<li><code>grouping</code> to show how the set has been grouped,</li>
<li><code>key</code> to show which group the set belongs to.</li>
</ul>
<pre><code>{
  {
    key: {is_single: false},
    grouping: {'is_single'},
    elements: {
      default::NPC {name: 'Jonathan Harker', is_single: false},
      default::NPC {name: 'Mina Murray', is_single: false},
      default::NPC {name: 'Lucy Westenra', is_single: false},
      default::NPC {name: 'Arthur Holmwood', is_single: false},
    },
  },
  {
    key: {is_single: true},
    grouping: {'is_single'},
    elements: {
      default::NPC {name: 'Abraham Van Helsing', is_single: true},
      default::NPC {name: 'John Seward', is_single: true},
      default::NPC {name: 'Renfield', is_single: true},
      default::NPC {name: 'The innkeeper', is_single: true},
      default::NPC {name: 'Quincey Morris', is_single: true},
    },
  },
}
</code></pre>
<p>Grouping can be a lot more complex than adding <code>by</code> and a property name. For reference, here is what the full syntax looks like.</p>
<pre><code>[ with with-item [, ...] ]

group [alias := ] expr

[ using using-alias := expr, [, ...] ]

by grouping-element, ... ;
</code></pre>
<p>You don't need to memorize the syntax, but a quick read shows us that the keyword <code>with</code> can be used before writing <code>group</code>, and the keyword <code>using</code> can be used after <code>group</code> to create our name for a grouping.</p>
<p>Take our <code>City</code> objects for example. Each one has a different population, so if we were to use this query we would simply get a big list of groups containing one <code>City</code> object each:</p>
<pre><code class="language-edgeql">group City { population } by .population;
</code></pre>
<p>Instead, we can make up a grouping called <code>is_big</code> that we define as a population greater than 50,000:</p>
<pre><code>group City {name, population}
  using is_big := .population &gt; 50000,
  by is_big;
</code></pre>
<p>With that, we now have our cities divided into big and small while displaying their names and populations.</p>
<pre><code>{
  {
    key: {is_big: false},
    grouping: {'is_big'},
    elements: {
      default::City {name: 'Whitby', population: 14400},
      default::City {name: 'Bistritz', population: 9100},
    },
  },
  {
    key: {is_big: true},
    grouping: {'is_big'},
    elements: {
      default::City {name: 'Munich', population: 230023},
      default::City {name: 'Buda-Pesth', population: 402706},
      default::City {name: 'London', population: 3500000},
    },
  },
}
</code></pre>
<p>We can define as many of these as we like. The query below defines <code>big</code> as any population greater than 50,000, <code>small</code> as any population less than 10,000, and <code>medium</code> as any population that is neither <code>big</code> nor <code>small</code>.</p>
<pre><code class="language-edgeql">group City {name, population}
  using big := .population &gt; 50000,
  small := .population &lt; 10000,
  medium := not big and not small,
  by big, medium, small;
</code></pre>
<p>The output now shows three groups:</p>
<pre><code>{
  {
    key: {big: false, small: false, medium: true},
    grouping: {'big', 'medium', 'small'},
    elements: {default::City {name: 'Whitby', population: 14400}},
  },
  {
    key: {big: false, small: true, medium: false},
    grouping: {'big', 'medium', 'small'},
    elements: {default::City {name: 'Bistritz', population: 9100}},
  },
  {
    key: {big: true, small: false, medium: false},
    grouping: {'big', 'medium', 'small'},
    elements: {
      default::City {name: 'Munich', population: 230023},
      default::City {name: 'Buda-Pesth', population: 402706},
      default::City {name: 'London', population: 3500000},
    },
  },
}
</code></pre>
<p>And because an expression comes right after the <code>group</code> keyword, we can use <code>with</code> and <code>select</code> to create an expression before typing <code>group</code>. This way we can filter an expression before we group it. Let's use this method to group our <code>NPC</code> objects to see who is still single and who has a title (perhaps for a dating app). But we want to make sure that they are alive first! To make sure that they are alive, we can filter by <code>not exists .last_appearance</code>. Here is the full query:</p>
<pre><code class="language-edgeql">with still_alive := (select NPC filter not exists .last_appearance),
  group still_alive { name, title } using
  has_title := exists .title,
  by .is_single, has_title;
</code></pre>
<p>Note that <code>.is_single</code> has a <code>.</code> because it is a property on <code>NPC</code> while <code>has_title</code> does not because it is a name that we defined inside the query.</p>
<p>The result is three groups of people. Interestingly, the NPCs that are doctors are both single!</p>
<pre><code class="language-edgeql">{
  {
    key: {has_title: false, is_single: false},
    grouping: {'is_single', 'has_title'},
    elements: {
      default::NPC {name: 'Jonathan Harker', title: {}},
      default::NPC {name: 'Mina Murray', title: {}},
      default::NPC {name: 'Lucy Westenra', title: {}},
      default::NPC {name: 'Arthur Holmwood', title: {}},
    },
  },
  {
    key: {has_title: false, is_single: true},
    grouping: {'is_single', 'has_title'},
    elements: {
      default::NPC {name: 'Quincey Morris', title: {}},
      default::NPC {name: 'Renfield', title: {}},
      default::NPC {name: 'The innkeeper', title: {}},
    },
  },
  {
    key: {has_title: true, is_single: true},
    grouping: {'is_single', 'has_title'},
    elements: {
      default::NPC {name: 'Abraham Van Helsing', title: 'Dr.'},
      default::NPC {name: 'John Seward', title: 'Dr.'},
    },
  },
}
</code></pre>
<p>Abraham van Helsing, however, is single because he is a widower. Our schema doesn't include that status so he has been grouped along with John Seward who has never been married. Sometimes a database query doesn't tell you the full story!</p>
<p><a href="chapter11/code.html">Here is all our code so far up to Chapter 11.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice-10"><a class="header" href="#time-to-practice-10">Time to practice</a></h2>
<ol>
<li>
<p>How would you write a function called <code>lucy()</code> that just returns all the <code>NPC</code> types matching the name 'Lucy Westenra'?</p>
</li>
<li>
<p>How would you write a function that takes two strings and returns <code>Person</code> objects with names that match each string?</p>
<p>Hint: try using <code>set of Person</code> as the return type.</p>
</li>
<li>
<p>What will the output of this be?</p>
<pre><code class="language-edgeql">select {'Jonathan', 'Arthur'} ++ {' loves '} 
  ++ {'Mina', 'Lucy'} ++ {' but '} ++ {'Dracula', 'The inkeeper'} 
  ++ {' doesn\'t love '} ++ {'Mina', 'Jonathan'};
</code></pre>
</li>
<li>
<p>How would you make a function that tells you how many times larger one city is than another?</p>
</li>
<li>
<p>Will <code>select (City.population + City.population)</code> and <code>select ((select City.population) + (select City.population))</code> produce different results?</p>
</li>
</ol>
<p><a href="chapter11/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>Lucy one night: &quot;What's that flapping against the window? Sounds like a bat or something...&quot;</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="tags-overloading-functions-coalescing"><a class="header" href="#tags-overloading-functions-coalescing">tags: Overloading Functions, Coalescing</a></h2>
<h1 id="chapter-12---from-bad-to-worse"><a class="header" href="#chapter-12---from-bad-to-worse">Chapter 12 - From bad to worse</a></h1>
<p>There is no good news for our heroes this chapter:</p>
<blockquote>
<p>Dracula continues to break into Lucy's room every time people don't listen to Van Helsing's advice, and every time the men give their blood to save her. Dracula always turns into a cloud to sneak in, drinks her blood and sneaks away before morning. Lucy is getting so weak that it's a surprise that she's still alive.</p>
<p>Meanwhile, Renfield breaks out of his cell and attacks Dr. Seward with a knife, causing him to bleed. The moment Renfield sees Dr. Seward's blood he stops and tries to drink it, repeating: ‚ÄúThe blood is the life! The blood is the life!‚Äù. The asylum security men take Renfield away and Dr. Seward is left confused and trying to understand him. Dr. Seward thinks there is a connection between him and the other events.</p>
<p>That night, a wolf controlled by Dracula breaks the windows of Lucy's room and Dracula is able to get in again...</p>
</blockquote>
<p>But there is good news for us, because we are going to keep learning about Cartesian products, plus how to overload a function.</p>
<h2 id="overloading-functions"><a class="header" href="#overloading-functions">Overloading functions</a></h2>
<p>Functions can be overloaded in EdgeDB. Overloading a function means to create a function with the same name as another function but with a different signature, thereby allowing it to take in and return different types. The <code>cal::to_local_date()</code> function that we saw in Chapter 9 is an example of an overloaded function as there are three ways to use it:</p>
<pre><code>cal::to_local_date(s: str, fmt: optional str = {}) -&gt; local_date
cal::to_local_date(dt: datetime, zone: str) -&gt; local_date
cal::to_local_date(year: int64, month: int64, day: int64) -&gt; local_date
</code></pre>
<p>Last chapter, we gave every character a strength of 5 and used the <code>fight()</code> function for a few of them. That's why the Innkeeper defeated Dracula, which is obviously not what would really happen. We should give Dracula a more realistic strength, and randomize some of the strength values for some of our characters.</p>
<p>Jonathan Harker is just a human but is still quite strong. We'll let him keep his strength of 5. We'll treat that as the maximum strength for a human, except Renfield who is a bit unique - we gave him a strength of 10 when we inserted him. And we'll make sure Count Dracula gets 20 strength, because he's Dracula. So we only have to update Count Dracula's strength:</p>
<pre><code class="language-edgeql">update Vampire
filter .name = 'Count Dracula'
set {
  strength := 20
};
</code></pre>
<p>Every other human should have a strength between 0 and 5. EdgeDB has a function called {eql:func}<code>docs:std::random</code> that gives a <code>float64</code> in between 0.0 and 1.0. If we multiply this by 5, we will get a <code>float64</code> in between 0.0 and 5.0. There is another function called {eql:func}<code>docs:std::round</code> that rounds numbers, so we'll use that too, and finally cast it to an <code>&lt;int16&gt;</code>. Give this a try a few times to see the <code>random()</code> function in action:</p>
<pre><code class="language-edgeql">with before_rounded := random() * 5,
  after_rounded := round(before_rounded),
  select (before_rounded, after_rounded);
</code></pre>
<p>The number will differ every time, but the output will look something like <code>{(3.9557656033819555, 4)}</code>. After that we'll just need to cast the rounded number into an <code>int16</code> and that will work as a random <code>strength</code> value for each of our <code>Person</code> objects (except for Jonathan, Dracula and Renfield). Here is what the update looks like:</p>
<pre><code class="language-edgeql">update Person
  filter .name not in {'Jonathan Harker', 'Count Dracula', 'Renfield'}
  set {
    strength := &lt;int16&gt;round(random() * 5)
  };
</code></pre>
<p>The vampire women are also pretty strong. Let's give them a random strength plus 5. This will ensure that they are stronger than average humans but not as strong as Dracula:</p>
<pre><code class="language-edgeql">update MinorVampire
  set {
    strength := &lt;int16&gt;round(random() * 5) + 5
  };
</code></pre>
<p>Now let's <code>select Person { name, strength };</code> and see if it works. The output should have mostly random numbers now, something similar to this:</p>
<pre><code>{
  default::Crewman {name: 'Crewman 1', strength: 1},
  default::Crewman {name: 'Crewman 2', strength: 4},
  default::Crewman {name: 'Crewman 3', strength: 3},
  default::Crewman {name: 'Crewman 4', strength: 2},
  default::Crewman {name: 'Crewman 5', strength: 3},
  default::MinorVampire {name: 'Vampire Woman 1', strength: 1},
  default::MinorVampire {name: 'Vampire Woman 2', strength: 4},
  default::MinorVampire {name: 'Vampire Woman 3', strength: 3},
  default::Sailor {name: 'The Captain', strength: 0},
  default::Sailor {name: 'Petrofsky', strength: 3},
  default::Sailor {name: 'The First Mate', strength: 4},
  default::Sailor {name: 'The Cook', strength: 1},
  default::PC {name: 'Emil Sinclair', strength: 5},
  default::PC {name: 'Max Demian', strength: 3},
  default::NPC {name: 'Renfield', strength: 10},
  default::NPC {name: 'Jonathan Harker', strength: 5},
  default::NPC {name: 'The innkeeper', strength: 2},
  default::NPC {name: 'Mina Murray', strength: 2},
  default::NPC {name: 'Quincey Morris', strength: 3},
  default::NPC {name: 'Arthur Holmwood', strength: 2},
  default::NPC {name: 'John Seward', strength: 1},
  default::NPC {name: 'Abraham Van Helsing', strength: 1},
  default::NPC {name: 'Lucy Westenra', strength: 3},
  default::Vampire {name: 'Count Dracula', strength: 20},
}
</code></pre>
<p>Looks like it worked.</p>
<p>So now let's overload the <code>fight()</code> function. Right now it only works for one <code>Person</code> vs. another <code>Person</code>, but in the book all the characters get together to try to defeat Dracula. We'll need to overload the function so that more than one character can work together to fight.</p>
<pre><code class="language-sdl">function fight(people_names: array&lt;str&gt;, opponent: Person) -&gt; str
  using (
    with
        people := (select Person filter contains(people_names, .name)),
    select
        array_join(people_names, ', ') ++ ' win!'
        if sum(people.strength) &gt; (opponent.strength ?? 0)
        else opponent.name ++ ' wins!'
  );
</code></pre>
<p>With this overloaded function we accept two arguments: an array of the names of the fighters and a <code>Person</code> object that is their opponent. You're seeing a couple of new standard library functions in use here that we'll dig into more later. For now, here are the basics you need to know:</p>
<ul>
<li>We call <code>contains</code>, passing our array of names and the <code>.name</code> property. This allows us to filter only <code>Person</code> objects with a <code>.name</code> that matches one of those in the array.</li>
<li><code>sum</code> in the next line of our <code>select</code> takes all the values in a set and adds them together. That gives us a total strength of the fighters to compare against their opponent's strength.</li>
</ul>
<p>Note that overloading only works if the function signature is different. Here are the two signatures we have now for comparison:</p>
<pre><code class="language-sdl">fight(one: Person, two: Person) -&gt; str
fight(people_names: array&lt;str&gt;, opponent: Person) -&gt; str
</code></pre>
<p>If we tried to overload our function with an input of <code>(Person, Person)</code>, it wouldn't work because that's the same as the original signature. EdgeDB uses the input we give it to decide which form of the function to use, so without different signatures, it would have no way to decide between the two.</p>
<p>The function name is the same, but to call it, we enter an array of the fighters' names and the <code>Person</code> they are fighting.</p>
<p>Let's do a migration now and see what happens if Jonathan and Renfield try to fight Dracula together. The migration output is a little interesting, as EdgeDB simply asks us if we created a function <code>default::fight</code> - it doesn't ask us if we overloaded a function. For humans the function looks the same because of the function name (which is what makes overloading convenient), but as far as EdgeDB is concerned this simply an entirely new function.</p>
<pre><code>c:\easy-edgedb&gt;edgedb migration create
Connecting to an EdgeDB instance at localhost:10716...
did you create function 'default::fight'? [y,n,l,c,b,s,q,?]
&gt; y
</code></pre>
<p>Now it's time to join together to fight Dracula. Good luck!</p>
<pre><code class="language-edgeql">with
  party := ['Jonathan Harker', 'Renfield'],
  dracula := (select Person filter .name = 'Count Dracula'),
select fight(party, dracula);
</code></pre>
<p>So did they...</p>
<pre><code>{'Count Dracula wins!'}
</code></pre>
<p>No, they didn't win. How about five people?</p>
<pre><code class="language-edgeql">with
  party := ['Jonathan Harker', 'Renfield', 'Arthur Holmwood', 
    'The innkeeper', 'Lucy Westenra'],
  dracula := (select Person filter .name = 'Count Dracula'),
select fight(party , dracula);
</code></pre>
<p>At this point it is most likely that the random <code>strength</code> values for everyone together will be greater than 20 and they will finally win. Then we will see the following output:</p>
<pre><code>{'Jonathan Harker, Renfield, Arthur Holmwood, The innkeeper, Lucy Westenra win!'}
</code></pre>
<p>So that's how function overloading works - you can create functions with the same name as long as the signature is different.</p>
<p><code>fight()</code> was pretty fun to make, but that sort of function is better done on the gaming side. So let's make a function that we might actually use. Since EdgeQL is a query language, the most useful functions are usually ones that make queries shorter.</p>
<p>Here is a simple one that tells us if a <code>Person</code> type has visited a <code>Place</code> or not:</p>
<pre><code class="language-sdl">function visited(person: str, city: str) -&gt; bool
  using (
    with person := (select Person filter .name = person),
    select city in person.places_visited.name
  );
</code></pre>
<p>Pretty simple! Let's add it to the schema and do a migration. Now our queries are much shorter:</p>
<pre><code>db&gt; select visited('Mina Murray', 'London');
{true}
db&gt; select visited('Mina Murray', 'Bistritz');
{false}
</code></pre>
<p>Thanks to the function, even more complicated queries are still quite readable:</p>
<pre><code class="language-edgeql">select (
  'Did Mina visit Bistritz? ' ++ &lt;str&gt;visited('Mina Murray', 'Bistritz'),
  'What about Jonathan and Romania? ' 
    ++ &lt;str&gt;visited('Jonathan Harker', 'Romania')
);
</code></pre>
<p>This prints <code>{('Did Mina visit Bistritz? false', 'What about Jonathan and Romania? true')}</code>.</p>
<h2 id="more-about-cartesian-products-and-the-coalescing-operator"><a class="header" href="#more-about-cartesian-products-and-the-coalescing-operator">More about Cartesian products and the coalescing operator</a></h2>
<p>Now let's learn more about Cartesian products in EdgeDB. You might recall from the previous chapter that even a single empty set always results in an output of <code>{}</code> when working with multiple sets:</p>
<pre><code>edgedb&gt; select 'My name is ' ++ &lt;str&gt;{} ++ '!';
{}
</code></pre>
<p>That's why we had to change our <code>fight()</code> function to use the coalescing operator in the previous chapter. Let's dig a little deeper into why that is.</p>
<p>Remember, a <code>{}</code> has a length of 0 and anything multiplied by 0 is also 0. For example, let's try to concatenate the names of places that start with b with those that start with x.</p>
<pre><code class="language-edgeql">with b_places := (select Place filter Place.name ilike 'b%'),
     x_places := (select Place filter Place.name ilike 'x%'),
select b_places.name ++ ' ' ++ x_places.name;
</code></pre>
<p>Yep, it's an empty set.</p>
<pre><code>{}
</code></pre>
<p>Let's explore this a bit more. A search for places that start with &quot;b&quot; should give us <code>{'Buda-Pesth', 'Bistritz'}</code>. Let's manually type out the city names this time just to make sure and add an empty set after:</p>
<pre><code class="language-edgeql">select {'Buda-Pesth', 'Bistritz'} ++ {};
</code></pre>
<p>So that should give a <code>{}</code>. The output is...</p>
<pre><code>error: operator '++' cannot be applied to operands of type 'std::str' and 'anytype'
  ‚îå‚îÄ query:1:8
  ‚îÇ
1 ‚îÇ select {'Buda-Pesth', 'Bistritz'} ++ {};
  ‚îÇ        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Consider 
using an explicit type cast or a conversion function.
</code></pre>
<p>Ah, that's right - we saw one example of an empty set with a cast in the last chapter when we tried the query <code>select &lt;str&gt;{} ?? 'Count Dracula is now in Whitby';</code>. EdgeDB requires a cast for an empty set, because there's no way to know the type of a set if all EdgeDB sees is <code>{}</code>.</p>
<p>You can probably guess that the same is true for array or set constructors too, so <code>select [];</code> returns an error: <code>QueryError: expression returns value of indeterminate type</code>. And <code>select {};</code> too.</p>
<p>Okay, one more time, this time making sure that the <code>{}</code> empty set is of type <code>str</code>:</p>
<pre><code>db&gt; select {'Buda-Pesth', 'Bistritz'} ++ &lt;str&gt;{};
{}
</code></pre>
<p>Good, so we have manually confirmed that using <code>{}</code> with another set always returns <code>{}</code>. But we would like to do the following:</p>
<ul>
<li>Concatenate the two strings if they exist, and</li>
<li>Return what we have if one is an empty set.</li>
</ul>
<p>In other words, we would like to add <code>{'Buda-Peth', 'Bistritz'}</code> to another set and return the original <code>{'Buda-Peth', 'Bistritz'}</code> if the second is empty. So we use the {eql:op}<code>coalescing operator &lt;docs:coalesce&gt;</code> to make it work:</p>
<pre><code class="language-edgeql">with b_places := (select Place filter .name ilike 'b%'),
     x_places := (select Place filter .name ilike 'x%'),
select b_places.name ++ ' ' ++ x_places.name
  if exists b_places.name and exists x_places.name
  else b_places.name ?? x_places.name;
</code></pre>
<p>This returns:</p>
<pre><code>{'Buda-Pesth', 'Bistritz'}
</code></pre>
<p>That's better.</p>
<p>But now back to Cartesian products. Remember, when we add or concatenate sets we are working with <em>every item in each set</em> separately. Let's see what happens if we change the query to search for places that start with b (Buda-Pesth and Bistritz) and m (Munich). We would like to get the result <code>{'Buda-Pesth, Bistritz, Munich'}</code>, but it doesn't quite work that way:</p>
<pre><code class="language-edgeql">with b_places := (select Place filter .name ilike 'b%'),
     m_places := (select Place filter .name ilike 'm%'),
select b_places.name ++ ' ' ++ m_places.name
  if exists b_places.name and exists m_places.name
  else b_places.name ?? m_places.name;
</code></pre>
<p>We get this result instead:</p>
<pre><code>{'Buda-Pesth Munich', 'Bistritz Munich'}
</code></pre>
<p>In other words, we concatenated each item inside each set with each item inside the other. How can we just join one set with another one instead?</p>
<p>One way to join the two together without thinking about Cartesian multiplication is to turn them into an array. The {eql:func}<code>docs:std::array_agg</code> function will do this: it 'aggregates' them.</p>
<pre><code class="language-edgeql">with b_places := (select Place filter .name ilike 'b%'),
     m_places := (select Place filter .name ilike 'm%'),
select array_agg(b_places.name) ++
       array_agg(m_places.name);
</code></pre>
<p>Using this gives us an output of <code>{['Buda-Pesth', 'Bistritz', 'Munich']}</code>.</p>
<p>But if we just want to stick with a set, there is an even easier way: just <code>union</code> the sets.</p>
<pre><code class="language-edgeql">with b_places := (select Place filter .name ilike 'b%'),
     m_places := (select Place filter .name ilike 'm%'),
  select b_places.name union m_places.name;
</code></pre>
<p>And that will give us an output of <code>{'Buda-Pesth', 'Bistritz', 'Munich'}</code>.</p>
<p>With this, we don't need to worry about getting <code>{}</code> if we choose a letter like x. Let's look at every place that contains k or e:</p>
<pre><code class="language-edgeql">with has_k := (select Place filter .name ilike '%k%'),
     has_e := (select Place filter .name ilike '%e%'),
     has_either := has_k union has_e,
select has_either.name;
</code></pre>
<p>This gives us the result:</p>
<pre><code>{'Slovakia', 'France', 'Castle Dracula', 'Buda-Pesth'}
</code></pre>
<p>Similarly, you can use <code>?=</code> instead of <code>=</code> and <code>?!=</code> instead of <code>!=</code> when doing comparisons if you think one side might be an empty set. So if you can write a query like this:</p>
<pre><code class="language-edgeql">with city_names := {'Slovakia', 'Buda-Pesth', 'Castle Dracula'},
     city_name := (select City.name filter City.name = &quot;Hi I'm a City&quot;),
select city_names = city_name;
</code></pre>
<p>It will return <code>{}</code> because <code>city_name</code> has returned an empty set. Now if we change <code>=</code> to <code>?=</code> then the query will work as we would like:</p>
<pre><code class="language-edgeql">with city_names := {'Slovakia', 'Buda-Pesth', 'Castle Dracula'},
     city_name := (select City.name filter City.name = &quot;Hi I'm a City&quot;),
select city_names ?= city_name;
</code></pre>
<p>This will return the output <code>{false, false, false}</code> instead of <code>{}</code> for the whole thing. </p>
<p>In addition, two empty sets are treated as equal if you use <code>?=</code>. So this query will return <code>{true}</code>:</p>
<pre><code class="language-edgeql">select Vampire.lovers.name ?= Crewman.lovers.name;
</code></pre>
<p>It returns <code>{true}</code> because neither Dracula nor any of the Crewmen have a lover: both sides of the query return empty sets of type <code>str</code>. If we had used <code>=</code> instead of <code>?=</code> in this case, we would have just seen an empty set.</p>
<p><a href="chapter12/code.html">Here is all our code so far up to Chapter 12.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice-11"><a class="header" href="#time-to-practice-11">Time to practice</a></h2>
<ol>
<li>
<p>Consider these two functions. Will EdgeDB allow both of them to be defined at the same time?</p>
<p>First function:</p>
<pre><code class="language-sdl">function gives_number(input: int64) -&gt; int64
  using(input);
</code></pre>
<p>Second function:</p>
<pre><code class="language-sdl">function gives_number(input: int64) -&gt; int32
  using(&lt;int32&gt;input);
</code></pre>
</li>
<li>
<p>How about these two functions? Will EdgeDB allow both of them to be defined at the same time?</p>
<p>First function:</p>
<pre><code class="language-sdl">function make64(input: int16) -&gt; int64
  using(input);
</code></pre>
<p>Second function:</p>
<pre><code class="language-sdl">function make64(input: int32) -&gt; int64
  using(input);
</code></pre>
</li>
<li>
<p>Will <code>select {} ?? {3, 4} ?? {5, 6};</code> work?</p>
</li>
<li>
<p>Will <code>select &lt;int64&gt;{} ?? &lt;int64&gt;{} ?? {1, 2};</code> work?</p>
</li>
<li>
<p>Trying to make a single string of everyone's name with <code>select array_join(array_agg(Person.name));</code> isn't working. What's the problem?</p>
</li>
</ol>
<p><a href="chapter12/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>One of the men gives his blood to try to save Lucy. Will it be enough?</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="tags-introspection-type-union-operator"><a class="header" href="#tags-introspection-type-union-operator">tags: Introspection, Type Union Operator</a></h2>
<h1 id="chapter-13---meet-the-new-lucy"><a class="header" href="#chapter-13---meet-the-new-lucy">Chapter 13 - Meet the new Lucy</a></h1>
<blockquote>
<p>This time it was too late to save Lucy, and she is dying. Suddenly she opens her eyes, but they look very strange. She looks at Arthur and says ‚ÄúArthur! Oh, my love, I am so glad you have come! Kiss me!‚Äù</p>
<p>Arthur tries to kiss her, but Van Helsing grabs him and says &quot;Don't you dare!&quot; It was not Lucy, but the vampire spirit inside her that was talking. Lucy soon dies, and Van Helsing puts a golden crucifix on her lips to stop her from moving (crucifixes have that power over vampires). Unfortunately, the nurse steals the crucifix to sell when nobody is looking and vampire Lucy is able to move again...</p>
<p>A few days later there is news about a lady who is stealing and biting children. The newspaper calls it the &quot;Bloofer Lady&quot;, because the young children try to call her the &quot;Beautiful Lady&quot; but can't pronounce <em>beautiful</em> right.</p>
<p>Van Helsing decides that it's time to tell the other people the truth about vampires, but Arthur doesn't believe him and becomes angry that he would say crazy things about his wife. Van Helsing says, &quot;Fine, you don't believe me. Let's go to the graveyard together tonight and see what happens. Maybe then you will.&quot;</p>
</blockquote>
<p>Looks like Lucy, an <code>NPC</code>, has become a <code>MinorVampire</code>. How should we show this in the database? Let's look at the types again first.</p>
<p>Right now <code>MinorVampire</code> is nothing special, just a type that extends <code>Person</code>:</p>
<pre><code class="language-sdl">type MinorVampire extending Person;
</code></pre>
<p>Fortunately for us, according to the book she is a new &quot;type&quot; of person. The old Lucy is gone, and this new Lucy is now one of the <code>slaves</code> linked to the <code>Vampire</code> object named Count Dracula. We can treat them as two separate objects.</p>
<p>So instead of trying to change the <code>NPC</code> type, we can just give <code>MinorVampire</code> an optional link to <code>Person</code>:</p>
<pre><code class="language-sdl">type MinorVampire extending Person {
  former_self: Person;
}
</code></pre>
<p>The <code>former_self</code> link isn't <code>required</code> because we don't always know anything about people before they were made into vampires. For example, we don't know anything about the three vampire women before Dracula found them so we can't make an <code>NPC</code> type for them.</p>
<p>Another way to (informally) link them is to give the same date to <code>last_appearance</code> for an <code>NPC</code> and <code>first_appearance</code> for a <code>MinorVampire</code>. First we will update Lucy with her <code>last_appearance</code>:</p>
<pre><code class="language-edgeql">update Person filter .name = 'Lucy Westenra'
set {
  last_appearance := cal::to_local_date(1893, 9, 20)
};
</code></pre>
<p>After doing the migration, let's practice a big insert to add Dracula along with all of the <code>MinorVampire</code> objects. We haven't done much our existing objects so let's just  <code>delete Vampire;</code> and <code>delete MinorVampire;</code> and insert them all again.</p>
<p>Note the first line of the insert where we create a variable called <code>lucy</code>. We can then use that to bring in all the data to make her a <code>MinorVampire</code>, which is much more efficient than manually inserting all the information. It also includes her strength: we should add 5 to that, because vampires are generally stronger than humans.</p>
<p>We could give her the name 'Lucy Westenra' here because the <code>name</code> property is a delegated constraint from the <code>Person</code> type, but we'll just call her Lucy now.</p>
<p>Here's the insert:</p>
<pre><code class="language-edgeql">with lucy := assert_single(
    (select Person filter .name = 'Lucy Westenra')
)
insert Vampire {
  name := 'Count Dracula',
  age := 800,
  strength := 20,
  slaves := {
    (insert MinorVampire {
      name := 'Vampire Woman 1',
      strength := &lt;int16&gt;round(random() * 5) + 5
    }),
    (insert MinorVampire {
      name := 'Vampire Woman 2',
      strength := &lt;int16&gt;round(random() * 5) + 5
    }),
    (insert MinorVampire {
      name := 'Vampire Woman 3',
      strength := &lt;int16&gt;round(random() * 5) + 5
    }),
    (insert MinorVampire {
      name := 'Lucy',
      former_self := lucy,
      first_appearance := lucy.last_appearance,
      strength := lucy.strength + 5,
    }),
  },
  places_visited := (select Place filter .name in {'Romania', 'Castle Dracula'})
};
</code></pre>
<p>And thanks to the <code>former_self</code> link, it's easy to find all the minor vampires that come from <code>Person</code> objects. Just filter by <code>exists .former_self</code>:</p>
<pre><code class="language-edgeql">select MinorVampire {
  name,
  strength,
  first_appearance,
} filter exists .former_self;
</code></pre>
<p>This gives us the following input (though strength will vary):</p>
<pre><code>{
  default::MinorVampire {
    name: 'Lucy',
    strength: 9,
    first_appearance: &lt;cal::local_date&gt;'1893-09-20',
  },
}
</code></pre>
<p>Other filters such as <code>filter .name in Person.name and .first_appearance in Person.last_appearance;</code> are possible too but checking if the link <code>exists</code> is easiest. We could also switch to <code>cal::local_datetime</code> instead of <code>cal::local_date</code> to get the exact time down to the minute. But we won't need to get that precise just yet.</p>
<!-- 
-->
<h2 id="the-type-union-operator-"><a class="header" href="#the-type-union-operator-">The type union operator: |</a></h2>
<p>Another operator related to types is <code>|</code>, which is used to combine them (similar to writing <code>or</code>). This query for example pulling up all <code>Person</code> types will return <code>{true}</code>:</p>
<pre><code class="language-edgeql">with lucy := (select Person filter .name like 'Lucy%'),
select lucy is NPC | MinorVampire | Vampire;
</code></pre>
<p>It returns true if the <code>Person</code> type selected is of type <code>NPC</code>, <code>MinorVampire</code>, or <code>Vampire</code>. Since Lucy the <code>NPC</code> and Lucy the <code>MinorVampire</code> match any of the three types, the return value is <code>{true, true}</code>.</p>
<p>One cool thing about the type union operator is that you can also add it to links in your schema. Let's say for example there are other <code>Vampire</code> objects in the game, and one <code>Vampire</code> that is extremely powerful can control another less powerful vampire. Right now though a <code>Vampire</code> can only control a <code>MinorVampire</code>:</p>
<pre><code>type Vampire extending Person {
  multi slaves: MinorVampire;
}
</code></pre>
<p>So to represent this change, you could just use <code>|</code> and add another type:</p>
<pre><code>type Vampire extending Person {
  multi slaves: MinorVampire | Vampire;
}
</code></pre>
<p>We only have Count Dracula in our database as the main <code>Vampire</code> type so we won't change our schema in this way, but keep the <code>|</code> operator in mind in case you need it.</p>
<!--
Content to change for when https://github.com/edgedb/edgedb/issues/5823 is solved:

But how about our `Ship` type? Let's look at it again.

```
type Ship {
  required name: str;
  multi sailors: Sailor;
  multi crew: Crewman;
}
```

Both `sailors` and `crew` link to pretty similar objects, so this could be a good place to try out the type union operator by turning them into a single link called `crew: Sailor | Crewman;`. This will take two migrations though, because we don't want to lose any of the `crew` data. So we will first change the `Ship` to have `crew` hold both types:

```
type Ship {
  required name: str;
  multi sailors: Sailor;
  multi crew: Crewman | Sailor;
}
```
-->
<h2 id="on-target-delete-on-source-delete"><a class="header" href="#on-target-delete-on-source-delete">On target delete, on source delete</a></h2>
<p>We've decided to keep the existing <code>NPC</code> object for Lucy, because that Lucy will be in the game as an <code>NPC</code> until September 1893. Other <code>PC</code> objects could interact with her as an <code>NPC</code> up to this time, for example. </p>
<p>But what if we had chosen to delete her, what would have happened to the objects she is linked to? Or more realistically, what if all <code>MinorVampire</code> types connected to a <code>Vampire</code> should be deleted when the vampire dies? This is the way vampire physics works in Bram Stoker's book: vampires drain people of their blood and turn them into minor vampires, who are only alive because the vampire is still controlling them. But when the master vampire dies, the souls of the minor vampires are finally set free and they disappear too.</p>
<p>We can begin thinking about these vampire physics in our game by learning about how to set a deletion policy. We'll start with the keywords <code>on target delete</code>. This <code>on target delete</code> means &quot;when the target is deleted&quot;, or in other words &quot;when the object that is linked to is deleted&quot;. It goes inside <code>{}</code> after the link declaration. After this point there are some options {ref}<code>four options &lt;docs:ref_datamodel_link_deletion&gt;</code> to choose.</p>
<p>One deletion policy is <code>restrict</code>, and forbids you from deleting the target object. This is the default setting. In other words, anything you link to can't be deleted unless you specify otherwise in the schema. So when you declare a <code>type Vampire</code> like this:</p>
<pre><code class="language-sdl">type Vampire extending Person {
  multi slaves: MinorVampire;
}
</code></pre>
<p>It is as if you had written the following:</p>
<pre><code class="language-sdl">type Vampire extending Person {
  multi slaves: MinorVampire {
    on target delete restrict;
  }
}
</code></pre>
<p>We can test this out right now with an attempt to delete one of the vampire women:</p>
<pre><code class="language-edgeql">delete MinorVampire filter .name = 'Vampire Woman 1';
</code></pre>
<p>Here is the error:</p>
<pre><code>edgedb error: ConstraintViolationError: deletion of default::MinorVampire (db56215a-268c-11ee-ab5e-6322976b513c) is prohibited by link target policy
  Detail: Object is still referenced in link slaves of default::Vampire (db561336-268c-11ee-ab5e-b338ce4886f8).
</code></pre>
<p>Another deletion policy is <code>allow</code>, and simply allows you to delete the target. Inside the <code>Vampire</code> type it would look like this, which would let us delete any <code>MinorVampire</code> linked to a <code>Vampire</code> object.</p>
<pre><code class="language-sdl">type Vampire extending Person {
  multi slaves: MinorVampire {
    on target delete allow;
  }
}
</code></pre>
<p>A third deletion policy is called <code>delete source</code>, which deletes the source of a link when the target is deleted. Be careful with this deletion policy! You want to be absolutely certain when setting a policy that results in automatic deletions, because EdgeDB won't let you know about the automatic deletions that happen as a result of another deletion query. And if you have an automatic deletion policy that leads to another type that has its own automatic deletion policy...you'll end up with a cascade of deletions that maybe you didn't expect to happen.</p>
<p>Now in our case, using <code>on target delete delete source</code> would delete Count Dracula if we deleted the <code>MinorVampire</code> (the target) called <code>Vampire Woman 1</code>. So this schema is the opposite of what we want!</p>
<pre><code class="language-sdl">type Vampire extending Person {
  multi slaves: MinorVampire {
    on target delete delete source;
  }
}
</code></pre>
<p>Fortunately, to switch the target and source around we can just change the keyword <code>target</code> to <code>source</code>. This gives us a deletion policy of <code>on source delete delete target</code>, which looks like this:</p>
<pre><code class="language-sdl">type Vampire extending Person {
  multi slaves: MinorVampire {
    on source delete delete target;
  }
}
</code></pre>
<p>Again, you want to be careful when setting a deletion policy like this one. But our database is small and controlled, so let's add this <code>on source delete delete target</code> deletion policy to the <code>Vampire</code> type and do a migration.</p>
<p>Now let's give this deletion policy a quick test. We'll insert a <code>Vampire</code> named 'Alucard' who has bitten a man named Brian, and made him into a <code>MinorVampire</code>. We'll insert both together:</p>
<pre><code>insert Vampire {
  name := 'Alucard',
  slaves := (insert MinorVampire {name := &quot;Brian&quot;})
};
</code></pre>
<p>Now let's make sure that both of them are in the database:</p>
<pre><code class="language-edgeql">select Vampire {**} filter .name = 'Alucard';
</code></pre>
<p>There they are! Selecting Alucard leads us to Brian as well thanks to the link.</p>
<pre><code>{
  default::Vampire {
    strength: {},
    last_appearance: {},
    first_appearance: {},
    degrees: {},
    title: {},
    name: 'Alucard',
    pen_name: 'Alucard',
    conversational_name: 'Alucard',
    age: {},
    is_single: true,
    id: 5d3a42da-286a-11ee-9442-9fa367e8a4c0,
    places_visited: {},
    lovers: {},
    slaves: {
      default::MinorVampire {
        strength: {},
        last_appearance: {},
        first_appearance: {},
        degrees: {},
        title: {},
        name: 'Brian',
        pen_name: 'Brian',
        conversational_name: 'Brian',
        age: {},
        is_single: true,
        id: 5d3a4a96-286a-11ee-9442-c31d83f69190,
      },
    },
  },
}
</code></pre>
<p>Now if Alucard is killed, Brian should turn to dust and vanish as well:</p>
<pre><code class="language-edgeql">delete Vampire filter .name = 'Alucard';
</code></pre>
<p>And then let's do a query to see if we can find Brian anywhere:</p>
<pre><code>select Person filter .name = 'Brian';
</code></pre>
<p>The query returns <code>{}</code>. Thanks to the <code>on source delete delete target</code> deletion policy, Brian is gone too!</p>
<h2 id="adding-if-orphan-to-a-deletion-policy"><a class="header" href="#adding-if-orphan-to-a-deletion-policy">Adding 'if orphan' to a deletion policy</a></h2>
<p>Deletion policies can be pretty tricky to get right so let's put together another concrete example of one in our schema and walk through it step by step.</p>
<p>PCs can join together as parties inside games to work together on a common goal. We could allow players of our game to create a party that can then be joined by anyone who is interested. To start, let's make a simple <code>Party</code> type that <code>PC</code> can link to.</p>
<pre><code class="language-sdl">type Party {
  name: str;
}

type PC extending Person {
  required class: Class;
  required created_at: datetime {
    default := datetime_of_statement();
  }
  multi party: Party; # New link here
}
</code></pre>
<p>Easy enough! Now let's think about what the <code>multi party: Party</code> line means in practice. It has a default <code>on target delete restrict</code> placed on it, which means that we can't delete any <code>Party</code> that is linked to by a PC. Let's give this a try by adding a Party and two PC objects:</p>
<pre><code class="language-edgeql">insert Party { name := &quot;Ye olde party&quot; };
insert PC {
  name := &quot;Talloon&quot;,
  class := Class.Merchant,
  party := (select Party filter .name = &quot;Ye olde party&quot;)
};
insert PC {
  name := &quot;Alena&quot;,
  class := Class.Rogue,
  party := (select Party filter .name = &quot;Ye olde party&quot;)
};
</code></pre>
<p>And now any attempt to <code>delete Party;</code> will give this error:</p>
<pre><code>edgedb error: ConstraintViolationError: deletion of default::Party (86b32874-299c-11ee-8bd8-737485b849cd) is prohibited by link target policy
  Detail: Object is still referenced in link party of default::PC (9a6eaabe-299c-11ee-8bd8-c76e1f17a3f2).
</code></pre>
<p>We don't want old <code>Party</code> objects to just sit around in our database when no <code>PC</code>s are using them anymore, so let's set up a deletion policy to delete any <code>Party</code> when all <code>PC</code> objects linking to it are deleted.</p>
<p>There are two items to think about here. First of all, simply adding a <code>on source delete delete target</code> as below will not work. But let's give it a try and see what happens. First change the <code>PC</code> type to have this deletion policy and do a migration:</p>
<pre><code class="language-sdl">type PC extending Person {
  required class: Class;
  required created_at: datetime {
    default := datetime_of_statement();
  }
  multi party: Party {
    on source delete delete target;
  }
}
</code></pre>
<p>And then let's try to delete both PC objects that link to the <code>Party</code> object:</p>
<pre><code class="language-edgeql">delete PC filter .name in { &quot;Alena&quot;, &quot;Talloon&quot; };
</code></pre>
<p>We get an error!</p>
<pre><code>edgedb error: ConstraintViolationError: deletion of default::Party (86b32874-299c-11ee-8bd8-737485b849cd) is prohibited by link target policy
  Detail: Object is still referenced in link party of default::PC (a2bb7ce2-299c-11ee-8bd8-431f1e9112d6).
</code></pre>
<p>This is because EdgeDB is attempting to delete <code>Party</code> when we delete each <code>PC</code> object, but there is still an invisible <code>on target delete restrict</code> policy that prevents the <code>Party</code> object from being deleted. In other words, our query tries to delete the <code>PC</code> called Alena but can't because the <code>PC</code> called Talloon still links to the Party object.</p>
<p>So let's add an <code>on target delete allow</code> to the <code>PC</code> type to allow the linked to <code>Party</code> object to be deleted. This is closer to what we want, but not quite! But let's do a migration and see what happens in this case.</p>
<pre><code class="language-sdl">type PC extending Person {
  required class: Class;
  required created_at: datetime {
    default := datetime_of_statement();
  }
  multi party: Party {
    on source delete delete target;
    on target delete allow;
  }
}
</code></pre>
<p>Okay, now let's delete Talloon.</p>
<pre><code class="language-edgeql">delete PC filter .name = &quot;Talloon&quot;;
</code></pre>
<p>Success! Talloon is now deleted. But hold on a second...where did the Party go?</p>
<pre><code class="language-edgeql">select Party;
</code></pre>
<p>The query returns an empty set! The <code>PC</code> named Alena is still in the database but her <code>Party</code> has outright disappeared. This <code>Party</code> object was automatically deleted because that's what we instructed EdgeDB to do: adding <code>on source delete delete target</code> means &quot;delete the target every time any object linking to it is deleted&quot;. That's not what we want.</p>
<p>The solution here is to add two new keywords: <code>if orphan</code>. Here is the difference once <code>if orphan</code> is added:</p>
<ul>
<li><code>on source delete delete target</code> means &quot;delete the target if any object linking to it is deleted&quot;</li>
<li><code>on source delete delete target if orphan</code> means &quot;delete the target if the last object linking to it is deleted&quot;.</li>
</ul>
<p>That's what we want! So now let's change the PC type to add these two new words and do another migration:</p>
<pre><code class="language-sdl">type PC extending Person {
  required class: Class;
  required created_at: datetime {
    default := datetime_of_statement();
  }
  multi party: Party {
    on source delete delete target if orphan;
    on target delete allow;
  }
}
</code></pre>
<p>Next we have a bit of work to insert the <code>Party</code> object again, link the existing <code>PC</code> named Alena to it, and then to insert the <code>PC</code> named Talloon again...</p>
<pre><code class="language-edgeql">insert Party { name := &quot;Ye olde party&quot; };
update PC filter .name = &quot;Alena&quot; 
  set { 
    party := (select Party filter .name = &quot;Ye olde party&quot;) 
  };
insert PC { 
  name := &quot;Talloon&quot;,
  class := Class.Merchant,
  party := (select Party filter .name = &quot;Ye olde party&quot;) 
  };
</code></pre>
<p>And with that we are ready to delete our PC objects one at a time again. We'll start with Talloon again:</p>
<pre><code class="language-edgeql">delete PC filter .name = &quot;Talloon&quot;;
</code></pre>
<p>Alena is still linking to the Party object, so it should still be there. Let's check:</p>
<pre><code class="language-edgeql">select Party { name };
</code></pre>
<p>It sure is!</p>
<pre><code>{default::Party {name: 'Ye olde party'}}
</code></pre>
<p>And with just a single (orphan) link left, deleting Alena the PC should delete the Party object as well. Let's try it:</p>
<pre><code class="language-edgeql">delete PC filter .name = &quot;Alena&quot;;
</code></pre>
<p>Now if we try <code>select Party;</code> we will get an empty set, just as we hoped!</p>
<h2 id="set-operators-distinct-intersect-except-and-losing-shape"><a class="header" href="#set-operators-distinct-intersect-except-and-losing-shape">Set operators (distinct, intersect, except) and losing shape</a></h2>
<p>We are already familiar with one of the set operators in EdgeDB: <code>union</code>. This is used to join two sets together. So <code>select MinorVampire.name union MinorVampire.name;</code> will return the following:</p>
<pre><code>{
  'Vampire Woman 1',
  'Vampire Woman 2',
  'Vampire Woman 3',
  'Vampire Woman 1',
  'Vampire Woman 2',
  'Vampire Woman 3',
}
</code></pre>
<p>The <code>distinct</code> keyword is used if we want to remove duplicate values in a set, and is easy: just change <code>select</code> to <code>select distinct</code>. </p>
<p>A quick example of a property that has a lot of duplicates is the <code>strength</code> property on the <code>Person</code> type. A quick <code>select Person.strength;</code> will show this. The output will vary because it comes from the <code>random</code> function, but it will look something like this:</p>
<pre><code>{1, 1, 7, 8, 9, 9, 5, 3, 0, 0, 5, 10, 2, 0, 
2, 5, 3, 4, 0, 1, 4, 20, 5, 5, 5, 5, 5}
</code></pre>
<p>Change it to <code>select distinct Person.strength;</code> and now only the distinct values remain:</p>
<pre><code>{0, 1, 2, 3, 4, 5, 10, 20}
</code></pre>
<p>Note that <code>distinct</code> works by item and doesn't unpack or aggregate, so something like a set of arrays will check to see if the entire array is distinct or not, not each of the values inside. Thus using <code>distinct</code> on the following query won't do anything!</p>
<pre><code class="language-edgeql">select distinct {[7, 8], [7, 8], [9]};
</code></pre>
<p>It will simply return the original <code>{[7, 8], [9]}</code>, and not <code>{7, 8, 9}</code>.</p>
<p>The next set operator is called <code>intersect</code> and returns all the items in one set that match any item in the other set. Let's try this one out on the <code>places_visited</code> property on the <code>Person</code> type. First let's look at the places visited by all our <code>NPC</code> and <code>PC</code> objects:</p>
<pre><code>db&gt; select PC.places_visited.name;
{'Buda-Pesth', 'Bistritz', 'Munich'}
db&gt; select NPC.places_visited.name;
{'Romania', 'Castle Dracula', 'Buda-Pesth', 'Bistritz', 'London', 'Munich'}
</code></pre>
<p>Now let's intersect them!</p>
<pre><code class="language-edgeql">select PC.places_visited.name intersect NPC.places_visited.name;
</code></pre>
<p>This will simply return <code>{'Bistritz', 'Buda-Pesth', 'Munich'}</code>.</p>
<p>What if we want to use <code>intersect</code> on some object types and give them a shape? Let's try giving a shape to all these <code>Place</code> objects instead of just showing their name. Simply putting a <code>{*}</code> after an <code>intersect</code> might seem to be the right way to make this happen:</p>
<pre><code class="language-edgeql">select PC.places_visited intersect NPC.places_visited {*};
</code></pre>
<p>And indeed the query does work, but the output is a bit unexpected. The shape is gone!</p>
<pre><code>{
  default::City {id: da23b4be-268c-11ee-ab5e-0bda71669b0c},
  default::City {id: da317478-268c-11ee-ab5e-8b58f378092b},
  default::City {id: da41f9ec-268c-11ee-ab5e-e3cd443a19f2},
}
</code></pre>
<p>The issue here is that set operators don't preserve the original expression type, so they don't preserve the shape of an expression either. There is in effect no shape for us to work with.</p>
<p>Fortunately, the solution here is fairly simple: we can use <code>with</code> to capture the result of a set operator, and then <em>that</em> will have a shape that we can work with. So a small change to our query will do the job:</p>
<pre><code class="language-edgeql">with common_locations := PC.places_visited intersect NPC.places_visited,
  select common_locations {*};
</code></pre>
<p>The result is what we hoped to see: not just the names of the places visited by both <code>PC</code> and <code>NPC</code> objects, but their properties too.</p>
<pre><code>{
  default::City {
    id: da41f9ec-268c-11ee-ab5e-e3cd443a19f2,
    important_places: ['Golden Krone Hotel'],
    modern_name: 'Bistri»õa',
    name: 'Bistritz',
  },
  default::City {
    id: da23b4be-268c-11ee-ab5e-0bda71669b0c,
    important_places: {},
    modern_name: {},
    name: 'Munich',
  },
  default::City {
    id: da317478-268c-11ee-ab5e-8b58f378092b,
    important_places: {},
    modern_name: 'Budapest',
    name: 'Buda-Pesth',
  },
}
</code></pre>
<p>The last set operator to learn is called <code>except</code>, and it's the opposite of <code>intersect</code>. While <code>intersect</code> returns items that are in the first set as well as the other, <code>except</code> returns items from the first set that are <em>not</em> shared with the second set.</p>
<p>The <code>except</code> operator is a good opportunity to demonstrate that order can matter when using a set operator. Our <code>PC</code> objects have been to three cities: <code>{'Buda-Pesth', 'Bistritz', 'Munich'}</code>. The <code>NPC</code> objects have been to more places: <code>{'Romania', 'Castle Dracula', 'Buda-Pesth', 'Bistritz', 'London', 'Munich'}</code>. What do you think will happen in the query below that uses <code>intersect</code>? Note the order in which it is done.</p>
<pre><code class="language-edgeql">select PC.places_visited.name except NPC.places_visited.name;
</code></pre>
<p>That's right, the query simply returns a <code>{}</code> empty set. That's because EdgeDB went through the three names returned by <code>PC.places_visited.name</code> as follows:</p>
<ul>
<li>'Buda-Pesth': Is this one inside NPC.places_visited.name? Yes. So don't return it.</li>
<li>'Bistritz': Same.</li>
<li>'Munich': Same.</li>
</ul>
<p>And then the query was done.</p>
<p>But if we reverse the query then it will return some names:</p>
<pre><code class="language-edgeql">select NPC.places_visited.name except PC.places_visited.name;
</code></pre>
<p>The result is <code>{'Castle Dracula', 'London', 'Romania'}</code>, because this time EdgeDB began with the names of the places visited by the NPC objects and found three names that didn't have a matching value in the set of names returned by the <code>PC</code> objects.</p>
<p>In other words, you can sort of think of <code>except</code> as meaning <code>minus</code>.</p>
<h2 id="being-introspective"><a class="header" href="#being-introspective">Being introspective</a></h2>
<p>We saw back in Chapter 8 that we can use <code>__type__</code> to get object types in a query, and that <code>__type__</code> always has a <code>name</code> property that shows us the type's name (otherwise we will only see its <code>uuid</code>). In the same way that we can get all the names of <code>Person</code> objects with <code>select Person.name</code>, we can use <code>__type__.name</code> to get all the type names that extend the <code>Person</code> type:</p>
<pre><code class="language-edgeql">select Person.__type__.name;
</code></pre>
<p>The output shows us all the names of types attached to <code>Person</code> so far, namely the types that extend <code>Person</code>:</p>
<pre><code>{
  'default::NPC',
  'default::Sailor',
  'default::MinorVampire',
  'default::Crewman',
  'default::Vampire',
  'default::PC',
}
</code></pre>
<p>On top of the <code>name</code> property, the two most useful fields inside <code>__type__</code> are <code>properties</code> and <code>links</code>. (You can also just choose the field <code>pointers</code> which holds both <code>properties</code> and <code>links</code> together.) If we add these to the query the output will get quite long.</p>
<pre><code class="language-edgeql">select Person.__type__ {
   name,
   properties: {name},
   links: {name}
};
</code></pre>
<p>The output contains the name, properties and links of each and every type that extends <code>Person</code>:</p>
<pre><code>{
  schema::ObjectType {
    name: 'default::NPC',
    properties: {
      schema::Property {name: 'strength'},
      schema::Property {name: 'last_appearance'},
      schema::Property {name: 'first_appearance'},
      schema::Property {name: 'degrees'},
      schema::Property {name: 'title'},
      schema::Property {name: 'name'},
      schema::Property {name: 'pen_name'},
      schema::Property {name: 'conversational_name'},
      schema::Property {name: 'is_single'},
      schema::Property {name: 'id'},
      schema::Property {name: 'age'},
    },
    links: {
      schema::Link {name: '__type__'},
      schema::Link {name: 'places_visited'},
      schema::Link {name: 'lovers'},
    },
  },
  schema::ObjectType {
    name: 'default::Sailor',
    # And so on...
</code></pre>
<p>For such type-related queries, EdgeDB has a keyword called <code>introspect</code> that is specialized for looking inside types. (Indeed, the word <em>introspect</em> itself means to &quot;look inside&quot;.) It's a little bit similar to adding <code>__type__</code> to a query, but is more focused and has certain abilities and uses that you can't get by using <code>__type__</code>.</p>
<p>A good rule of thumb is that:</p>
<ul>
<li>If you are doing a query on objects and want to add some type information on the object itself, adding <code>__type__</code> lets you do this.</li>
<li>If you want to do a query exclusively on the type itself, go with <code>introspect</code>.</li>
</ul>
<p>To do an <code>introspect</code> query, just wrap it in parentheses inside a <code>select</code>. Here is how we can use <code>introspect</code> to look inside the <code>Person</code> type:</p>
<pre><code class="language-edgeql">select (introspect Person) {
    name,
    pointers: {name}
};
</code></pre>
<p>Both the query and output are now quite clean:</p>
<pre><code>{
  schema::ObjectType {
    name: 'default::Person',
    pointers: {
      schema::Link {name: '__type__'},
      schema::Property {name: 'id'},
      schema::Link {name: 'lovers'},
      schema::Property {name: 'is_single'},
      schema::Link {name: 'places_visited'},
      schema::Property {name: 'age'},
      schema::Property {name: 'name'},
      schema::Property {name: 'title'},
      schema::Property {name: 'conversational_name'},
      schema::Property {name: 'degrees'},
      schema::Property {name: 'pen_name'},
      schema::Property {name: 'first_appearance'},
      schema::Property {name: 'last_appearance'},
      schema::Property {name: 'strength'},
    },
  },
}
</code></pre>
<p>Using <code>introspect</code> also lets us look inside scalar types, which isn't possible with <code>__type__</code> (which only works on object types). So this query won't work:</p>
<pre><code class="language-edgeql">select Class.__type__ {*};
</code></pre>
<p>But <code>introspect</code> will:</p>
<pre><code class="language-edgeql">select (introspect Class);
</code></pre>
<p>That query just returns a <code>{schema::ScalarType {id: c7c181cc-268c-11ee-980e-a10f818aefc0}}</code>. But <code>ScalarType</code> looks like an object type of its own that we can use the splat operator on! Let's see what's inside:</p>
<pre><code class="language-edgeql">select (introspect Class) {*};
</code></pre>
<p>There it is! Lots of info about our <code>Class</code> enum:</p>
<pre><code>{
  schema::ScalarType {
    final: false,
    is_final: false,
    abstract: false,
    is_abstract: false,
    id: c7c181cc-268c-11ee-980e-a10f818aefc0,
    name: 'default::Class',
    internal: false,
    builtin: false,
    computed_fields: [],
    expr: {},
    from_alias: false,
    is_from_alias: false,
    inherited_fields: [],
    default: {},
    enum_values: ['Rogue', 'Mystic', 'Merchant'],
    arg_values: {},
  },
}
</code></pre>
<p>You can even <code>introspect</code> the most basic of EdgeDB's scalar types:</p>
<pre><code class="language-edgeql">select ((introspect str), (introspect int64), (introspect int16));
</code></pre>
<p>The output for this query is actually pretty interesting. We can see that the <code>id</code>s for EdgeDB's basic scalar types have been manually chosen instead of automatically generated.</p>
<pre><code>{
  (
    schema::ScalarType {id: 00000000-0000-0000-0000-000000000101},
    schema::ScalarType {id: 00000000-0000-0000-0000-000000000105},
    schema::ScalarType {id: 00000000-0000-0000-0000-000000000103},
  ),
}
</code></pre>
<p>But the <code>introspect</code> keyword isn't limited to doing queries on types for our own information and fun. EdgeDB has one type that requires you to <code>introspect</code> it whenever it gets used! Let's take a look at that now.</p>
<h2 id="the-sequence-type"><a class="header" href="#the-sequence-type">The sequence type</a></h2>
<p>We made a few inserts of <code>Crewman</code> objects a few chapters ago, in which we gave them each a number. To do that, we used the <code>count()</code> function to count the number of <code>Crewman</code> objects, to which we added one:</p>
<pre><code class="language-edgeql">with next_number := count(Crewman) + 1,
  insert Crewman {
  number := next_number
};
</code></pre>
<p>This gave us a sequence of numbers.</p>
<p>Well, it just so happens that EdgeDB has a type called {eql:type}<code>docs:std::sequence</code> that has this incrementation built in. This type is defined as an &quot;auto-incrementing sequence of int64&quot;, so an <code>int64</code> that starts at 1 and goes up every time you increment it.</p>
<p>A <code>sequence</code> is used as an abstract type for other type names to extend, which allows each one of these sequence types to increment independently of any others. Note the similarity to the enum syntax we are familiar with:</p>
<pre><code class="language-sdl">scalar type SomeSequence extending sequence;
scalar type SomeEnumType extending enum&lt;OptionOne, OptionTwo, OptionThree&gt;;
</code></pre>
<p>And once it is defined, we can just stick it on our object types as a property.</p>
<pre><code class="language-sdl">scalar type SomeSequenceNumber extending sequence;

type SomeType {
  # This wouldn't work
  # required number: sequence;

  # But this will
  required number: SomeSequenceNumber;
}
</code></pre>
<p>This sequence number could be useful for our <code>PC</code> objects, because players of our game might want us to delete their accounts. When that happens we will have to delete the <code>PC</code> object that the player used, so the data will be gone. That means that we can't use <code>count(PC)</code> as a sequence number. If we did that, then the 51st player would have the number 51, but if a <code>PC</code> object was then deleted then the next one would also be number 51! A sequence is just right for us here.</p>
<p>Let's experiment first. We'll add a <code>SomeSequenceNumber</code> to our schema with the following, and do a migration:</p>
<pre><code class="language-sdl">scalar type SomeSequenceNumber extending sequence;
</code></pre>
<p>And now let's play around with this sequence type a bit before we make a <code>PCNumber</code> to put on our <code>PC</code> type as a property. Basic sequence behavior is pretty simple: you increment them with the <code>sequence_next()</code> function, and reset them with <code>sequence_reset()</code>. But here's an important point: inside these functions you need to specify the sequence type that we want to increment.</p>
<p>In other words, just typing <code>sequence_next()</code> won't work because EdgeDB doesn't know which sequence type we want to increment:</p>
<pre><code>db&gt; select sequence_next();
error: QueryError: function &quot;sequence_next()&quot; does not exist
  ‚îå‚îÄ &lt;query&gt;:1:8
  ‚îÇ
1 ‚îÇ select sequence_next();
  ‚îÇ        ^^^^^^^^^^^^^^^ Did you want &quot;std::sequence_next(seq: schema::ScalarType)&quot;?
</code></pre>
<p>And typing <code>SomeSequenceNumber</code> won't work either because SomeSequenceNumber isn't an object type in our schema:</p>
<pre><code>db&gt; select sequence_next(SomeSequenceNumber);
error: InvalidReferenceError: object type or alias 'default::SomeSequenceNumber' does not exist
  ‚îå‚îÄ &lt;query&gt;:1:22
  ‚îÇ
1 ‚îÇ select sequence_next(SomeSequenceNumber);
  ‚îÇ                      ^^^^^^^^ error
</code></pre>
<p>But did you notice that the function is expecting an argument of <code>ScalarType</code>? We saw this just above when we learned the <code>introspect</code> keyword. So let's try replacing <code>SomeSequenceNumber</code> with <code>introspect SomeSequenceNumber</code> which returns a <code>ScalarType</code>:</p>
<pre><code>db&gt; select sequence_next(introspect SomeSequenceNumber);
{1}
</code></pre>
<p>Success! Just add <code>introspect</code> and the <code>sequence_next()</code> and <code>sequence_reset()</code> functions will know which sequence type to increment.</p>
<p>Now that we know how sequences work, let's play around with this sequence number of ours for a bit. As you can see, it can be incremented or reset, but can't be reset to anything less than 1.</p>
<pre><code>db&gt; select sequence_next(introspect SomeSequenceNumber);
{2}
db&gt; select sequence_next(introspect SomeSequenceNumber);
{3}
db&gt; select sequence_next(introspect SomeSequenceNumber);
{4}
db&gt; select sequence_next(introspect SomeSequenceNumber);
{5}
db&gt; select sequence_reset(introspect SomeSequenceNumber, 10);
{10}
db&gt; select sequence_reset(introspect SomeSequenceNumber, 0);
edgedb error: NumericOutOfRangeError: setval: value 0 is out of bounds for 
sequence &quot;6f7e322d-ff25-11ed-95e6-558fd8f3e188_sequence&quot; (1..9223372036854775807)
db&gt; select sequence_reset(introspect SomeSequenceNumber, 1);
{1}
</code></pre>
<p>Finally, let's change the schema for our <code>PC</code> type to include this number. We could type <code>sequence_next(introspect PCNumber)</code> every time we insert a PC object, but it's much easier just to set <code>sequence_next(introspect PCNumber)</code> in the schema as the default value. Delete <code>SomeSequenceNumber</code> from the schema if you like, and then change the schema around <code>PC</code> to look like the following and do a migration:</p>
<pre><code class="language-sdl">scalar type PCNumber extending sequence;

type PC extending Person {
  required class: Class;
  required created_at: datetime {
    default := datetime_of_statement()
  }
  required number: PCNumber {
    default := sequence_next(introspect PCNumber);
  }
}
</code></pre>
<p>And now let's do a quick query to see if it worked:</p>
<pre><code class="language-edgeql">select PC {
  name, 
  number,
  created_at
};
</code></pre>
<p>And with that, the sequence incrementing just works. That was easy! And thanks to the default value we provided, EdgeDB has even updated our existing object types with the <code>number</code> property.</p>
<pre><code>{
  default::PC {
    name: 'Emil Sinclair',
    number: 1,
    created_at: &lt;datetime&gt;'2023-05-28T10:40:53.598763Z',
  },
  default::PC {
    name: 'Max Demian',
    number: 2,
    created_at: &lt;datetime&gt;'2023-05-30T01:13:28.022340Z',
  },
}
</code></pre>
<p><a href="chapter13/code.html">Here is all our code so far up to Chapter 13.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice-12"><a class="header" href="#time-to-practice-12">Time to practice</a></h2>
<ol>
<li>
<p>How would you insert an <code>NPC</code> named 'Mr. Swales' who has visited the <code>City</code> called 'York', the <code>Country</code> called 'England', and the <code>OtherPlace</code> called 'Whitby Abbey'? Try it in a single insert.</p>
</li>
<li>
<p>How readable is the result of this introspect query?</p>
<pre><code class="language-edgeql">select (introspect Ship) {
  name,
  properties,
  links
};
</code></pre>
</li>
<li>
<p>What would be the shortest way to see what links form the <code>Vampire</code> type?</p>
</li>
<li>
<p>What do you think the output of <code>select distinct {1, 2} + {1, 2};</code> will be?</p>
<p>Hint: don't forget the Cartesian multiplication.</p>
</li>
<li>
<p>What do you think the output of <code>select distinct {2, 2} + {2, 2};</code> will be?</p>
</li>
</ol>
<p><a href="chapter13/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>An old friend returns.</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="tags-type-annotations-backlinks"><a class="header" href="#tags-type-annotations-backlinks">tags: Type Annotations, Backlinks</a></h2>
<h1 id="chapter-14---a-ray-of-hope"><a class="header" href="#chapter-14---a-ray-of-hope">Chapter 14 - A ray of hope</a></h1>
<blockquote>
<p>Finally there is some good news: Jonathan Harker is alive. It seems that he managed to escape Castle Dracula, after which he found his way to Buda-Pesth (Budapest) in August and then to a hospital. The staff at the hospital are worried about Jonathan's mental health and send Mina a letter in which they say that he had &quot;had some fearful shock and continues to talk about wolves and poison and blood, of ghosts and demons.&quot;</p>
<p>Poor Jonathan! Sitting in the hospital he begins to wonder if he has just gone insane. Was Count Dracula real? Were the vampire women real too? Or did he just imagine the whole thing? How can Mina marry a man who is slowly going insane?</p>
<p>Mina takes a train to the hospital where Jonathan is recovering, after which they take a train back to England to the city of Exeter where they get married. Mina sends Lucy a letter from Exeter about the good news...but it arrives too late and Lucy never opens it.</p>
<p>Meanwhile, Van Helsing continues to contact his associates in universities around Europe to search for information on vampires and their activities. The men visit the graveyard as planned and see vampire Lucy walking around. When Arthur sees Lucy he finally believes Van Helsing, and so do the rest of the men. They now know that vampires are real, and manage to destroy her. Arthur is sad but also happy to see that Lucy is no longer forced to be a vampire and can now die in peace.</p>
</blockquote>
<p>Looks like we have a new city called Exeter, which is easy to add:</p>
<pre><code class="language-edgeql">insert City {
  name := 'Exeter',
  population := 40000
};
</code></pre>
<p>That's the population of Exeter at the time of the book (it has 130,000 people today), and it doesn't have a <code>modern_name</code> that is different from the one in the book.</p>
<p>We can also update the city of Buda-Pesth to add the name of the hospital where Jonathan Harker was staying. In addition, one of the universities that Van Helsing contacted for information is in the same city. Let's add them both:</p>
<pre><code class="language-edgeql">update City filter .name = 'Buda-Pesth' 
  set { important_places := [
    'Hospital of St. Joseph and Ste. Mary',
    'Buda-Pesth University'
    ] 
  };
</code></pre>
<h2 id="adding-and-accessing-properties-to-links"><a class="header" href="#adding-and-accessing-properties-to-links">Adding and accessing properties to links</a></h2>
<p>One interesting thing about links is that they can hold properties too. Since a link doesn't exist without a connection between objects, properties on a link usually have something to do with the relationship between these objects as well. Or link properties may be a computed value that only makes sense when you have objects joined by a link.</p>
<p>We can add a link property to our schema too by thinking of some more vampire physics. We know that <code>Vampire</code> objects control <code>MinorVampire</code> objects, and are so powerful that <code>MinorVampire</code>s are even deleted when their controlling <code>Vampire</code> dies. We represented this in our schema by adding a deletion policy:</p>
<pre><code class="language-edgeql">type Vampire extending Person {
  multi slaves: MinorVampire {
    on source delete delete target;
  }
}
</code></pre>
<p>Now let's add a link property as well. Both <code>MinorVampire</code>s and <code>Vampire</code>s have the property <code>strength</code>, and let's now say that a <code>Vampire</code>, with enough concentration, is able to give some of its own strength to the <code>MinorVampire</code>s that it controls. We'll call this link property <code>combined_strength</code>, and define it as the combined strength of both divided by two. So if one <code>Vampire</code> has a strength of 16 and a <code>MinorVampire</code> has a strength of 10, their combined strength will be 13 (16 plus 10, then divided by 2).</p>
<p>Added to the <code>Vampire</code> type, the <code>combined_strength</code> link property looks like this:</p>
<pre><code class="language-sdl">type Vampire extending Person {
  multi slaves: MinorVampire {
    on source delete delete target;
    property combined_strength := (Vampire.strength + .strength) / 2;
  }
}
</code></pre>
<p>And then we can add another interesting property to the <code>Vampire</code> type, called <code>army_strength</code>. This property will be the combined total of all the <code>combined_strength</code> link properties between a <code>Vampire</code> and the <code>MinorVampire</code>s it controls. So this number will be the total strength of the <code>Vampire</code>'s army when it is fully concentrating on giving as much strength as possible to its <code>MinorVampires</code>.</p>
<p>Here is what the <code>Vampire</code> type looks like after these changes. Notice anything in the syntax that looks different from what we've seen so far?</p>
<pre><code class="language-sdl">type Vampire extending Person {
  multi slaves: MinorVampire {
    on source delete delete target;
    property combined_strength := (Vampire.strength + .strength) / 2;
  }
  property army_strength := sum(.slaves@combined_strength);
}
</code></pre>
<p>That's right, there is an <code>@</code> in there! EdgeDB uses <code>@</code> to represent link properties as they are structurally somewhat different from regular properties. We don't need to get into the internal details but there are two things to keep in mind about link properties: they can only be <code>single</code>, and must always be optional.</p>
<p>And with those schema changes made, we can do a query on Count Dracula to see what his army looks like. Don't forget the <code>@</code> when doing queries too!</p>
<pre><code class="language-edgeql">select Vampire {
  name,
  age,
  strength,
  slaves: {
    name,
    strength,
    @combined_strength
  },
  army_strength
};
</code></pre>
<p>The <code>strength</code> property of Dracula's vampire slaves is determined randomly so the query output will look different on your end, but it will be similar to the output below. You can see that the <code>MinorVampire</code> types that Dracula controls are significantly stronger when he concentrates to control them as directly as possible.</p>
<pre><code>{
  default::Vampire {
    name: 'Count Dracula',
    age: 800,
    strength: 20,
    slaves: {
      default::MinorVampire {name: 'Vampire Woman 1', strength: 5, @combined_strength: {12.5}},
      default::MinorVampire {name: 'Vampire Woman 2', strength: 9, @combined_strength: {14.5}},
      default::MinorVampire {name: 'Vampire Woman 3', strength: 8, @combined_strength: {14}},
      default::MinorVampire {name: 'Lucy', strength: 9, @combined_strength: {14.5}},
    },
    army_strength: 55.5,
  },
}
</code></pre>
<h2 id="adding-annotations-to-types"><a class="header" href="#adding-annotations-to-types">Adding annotations to types</a></h2>
<p>Now that we know how to do introspection queries, we can start to give <code>annotations</code> to our types. An annotation is a string inside the type definition that gives us information about it when using an <code>introspect</code> query or when we put <code>__type__</code> into a query on an object type. By default, annotations can use the titles <code>title</code> or <code>description</code>.</p>
<p>Let's imagine that in our game a <code>City</code> needs at least 50 buildings, and we want the other developers to know this. Let's use an <code>annotation description</code> for this:</p>
<pre><code class="language-sdl">type City extending Place {
  annotation description := 'A place with 50 or more buildings. Anything else is an OtherPlace';
  population: int64;
}
</code></pre>
<p>After migrating our schema, we can now do an <code>introspect</code> query on it. We know how to do this from the last chapter - just add <code>: {name}</code> everywhere to get the inner details. Ready!</p>
<pre><code class="language-edgeql">select (introspect City) {
  annotations: {name}
  name,
  properties: {name},
};
</code></pre>
<p>Uh oh, not quite. The <code>annotations</code> part of the <code>introspect</code> query just says <code>std::description</code>:</p>
<pre><code>{
  schema::ObjectType {
    annotations: {schema::Annotation {name: 'std::description'}},
    name: 'default::City',
    properties: {
      schema::Property {name: 'name'},
      schema::Property {name: 'modern_name'},
      schema::Property {name: 'important_places'},
      schema::Property {name: 'id'},
      schema::Property {name: 'population'},
    },
  },
}
</code></pre>
<p>Let's do an <code>introspect</code> query on <code>City</code> again, but this time using the splat operator on the annotations to see what is inside.</p>
<pre><code class="language-edgeql">select (introspect City) { annotations: {*}};
</code></pre>
<p>There it is!</p>
<pre><code>{
  schema::ObjectType {
    annotations: {
      schema::Annotation {
        id: 6478af55-27fe-11ee-a636-8f86ec27644b,
        name: 'std::description',
        internal: false,
        builtin: true,
        computed_fields: [],
        inheritable: false,
        @is_owned: true,
        @owned: true,
        @value: 'A place with 50 or more buildings. Anything else is an OtherPlace',
      },
    },
  },
}
</code></pre>
<p>Ah, of course: the <code>annotations: {name}</code> part returns the name of the <em>type</em>, which is <code>std::description</code>. In other words, it's a link, and the target of a link just tells us the kind of annotation that gets used. But we're looking for the value inside it. And we can see from the <code>@</code> in the output above that the value of an annotation is a link property.</p>
<p>Let's try the query one more time:</p>
<pre><code class="language-edgeql">select (introspect City) {
  annotations: {
  name,
  @value
},
  name,
  properties: {name},
};
</code></pre>
<p>And now the actual annotation shows up in the output.</p>
<pre><code>{
  schema::ObjectType {
    annotations: {
      schema::Annotation {
        name: 'std::description',
        @value: 'A place with 50 or more buildings. Anything else is an OtherPlace',
      },
    },
    name: 'default::City',
    properties: {
      schema::Property {name: 'name'},
      schema::Property {name: 'modern_name'},
      schema::Property {name: 'important_places'},
      schema::Property {name: 'id'},
      schema::Property {name: 'population'},
    },
  },
}
</code></pre>
<p>What if we want an annotation with a different name besides <code>title</code> and <code>description</code>? This is surprisingly easy, just declare a new annotation by typing <code>abstract annotation</code> inside the schema and give it a name. We want to add a <code>warning</code> for other developers to read so that's what we'll call it:</p>
<pre><code class="language-sdl">abstract annotation warning;
</code></pre>
<p>Maybe it is important to use <code>Castle</code> instead of <code>OtherPlace</code> for not just castles, but castle towns too. Thanks to the new abstract annotation, now <code>OtherPlace</code> gives that information along with the other annotation. Here are the two annotations to add to <code>OtherPlace</code>:</p>
<pre><code class="language-sdl">type OtherPlace extending Place {
  annotation description := 'A place with under 50 buildings - hamlets, small villages, etc.';
  annotation warning := 'Castles and castle towns do not count! Use the Castle type for that';
}
</code></pre>
<p>Now let's migrate the schema again and do an introspect query on just its name and annotations:</p>
<pre><code class="language-edgeql">select (introspect OtherPlace) {
  name,
  annotations: {name, @value}
};
</code></pre>
<p>And here it is:</p>
<pre><code>{
  schema::ObjectType {
    name: 'default::OtherPlace',
    annotations: {
      schema::Annotation {
        name: 'std::description',
        @value: 'A place with under 50 buildings - hamlets, small villages, etc.',
      },
      schema::Annotation {
        name: 'default::warning',
        @value: 'Castles and castle towns do not count! Use the Castle type for that',
      },
    },
  },
}
</code></pre>
<h2 id="global-scalars"><a class="header" href="#global-scalars">Global scalars</a></h2>
<p>Every game needs to be tested before it can be sold, and it's nice to have different possible modes when testing a game. Any game testers should be able to experience the game in the same way that a regular player would, but another mode with extra information would be helpful too.</p>
<p>Another global type could help here. We've had a global <code>Time</code> object in our database for some time now, which so far is our only global type. But globals can be scalar types too.</p>
<p>A global scalar isn't an object though, so changing its value is a bit different: instead, we use the <code>set</code> and <code>unset</code> keywords to work with it.</p>
<p>To try using a global scalar we can add an enum called <code>Mode</code>, and give it two values: <code>Info</code> or <code>Debug</code>. <code>Info</code> will be the default, while <code>Debug</code> will be the mode that provides extra information for the testers. After this we can make a global called <code>tester_mode</code>:</p>
<pre><code class="language-sdl">scalar type Mode extending enum&lt;Info, Debug&gt;;

required global tester_mode: Mode {
    default := Mode.Info;
  }
</code></pre>
<p>A <code>required</code> global always needs a default value, which makes sense: a global is available across the entire database and is <code>required</code> so it must be present. The only way to ensure this is to add a default value. Fortunately, the EdgeDB compiler won't let a schema migration happen if we forget this. The error message would look like this:</p>
<pre><code>error: required globals must have a default
  ‚îå‚îÄ c:\easy-edgedb\dbschema\default.esdl:9:3
  ‚îÇ
9 ‚îÇ   required global tester_mode: Mode;
  ‚îÇ   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error

edgedb error: cannot proceed until .esdl files are fixed
</code></pre>
<p>With the migration done, let's make sure that the global value is there:</p>
<pre><code class="language-edgeql">select global tester_mode;
</code></pre>
<p>The output is simple: just <code>{Info}</code>.</p>
<p>Changing a global scalar is easy too: just use the <code>set</code> keyword.</p>
<pre><code class="language-edgeql">set global tester_mode := Mode.Debug;
</code></pre>
<p>The output here is simple too, just a message informing us that the value was successfully set:</p>
<pre><code>OK: SET GLOBAL
</code></pre>
<p>The opposite of the <code>set</code> keyword is <code>reset</code>, which resets a global to its default value. In our case the default value is <code>Mode.Info</code>, but if we hadn't specified that <code>tester_mode</code> is <code>required</code> then the default value would have been <code>{}</code>, an empty set.</p>
<p>Pretty easy! The output below shows the sort of feedback you will see in the REPL when setting and resetting a global scalar value.</p>
<pre><code>db&gt; select global tester_mode;
{Info}
db&gt; set global tester_mode := Mode.Debug;
OK: SET GLOBAL
db&gt; select global tester_mode;
{Debug}
db&gt; reset global tester_mode;
OK: RESET GLOBAL
</code></pre>
<p>And with this global value in place, we can now do queries that match on the <code>tester_mode</code> enum. Here is an example of a query that a tester using the <code>PC</code> named Emil Sinclair might use. During regular <code>Info</code> mode the query will only show the character's own info, but during <code>Debug</code> mode it will also show info on all the <code>NPC</code> objects as well. In a more complex schema we can imagine that this could be used to show a tester the health, location and so on of all the NPCs in a game, which could then be used to show them on a map or in a separate chart on the screen that is only visible during debug mode.</p>
<pre><code class="language-edgeql"># Select all NPC objects in Debug mode
with info := NPC if global tester_mode = Mode.Debug 
             else &lt;NPC&gt;{},
  select PC {
    name,
    class,
    strength,
    locations := .places_visited.name,
    npc_info := info { 
      name, 
      strength
    }
} filter .name = 'Emil Sinclair';
</code></pre>
<p>The output is pretty short during <code>Info</code> mode, which only provides the necessary info to play the game in the same way as every other player.</p>
<pre><code>{
  default::PC {
    name: 'Emil Sinclair',
    class: Mystic,
    strength: 2,
    locations: {},
    npc_info: {},
  },
}
</code></pre>
<p>But if you use <code>set global tester_mode := Mode.Debug;</code> then all of a sudden the same query will display all of the extra info!</p>
<pre><code>{
  default::PC {
    name: 'Emil Sinclair',
    class: Mystic,
    strength: 2,
    locations: {},
    npc_info: {
      default::NPC {name: 'Jonathan Harker', strength: 5},
      default::NPC {name: 'Renfield', strength: 10},
      default::NPC {name: 'The innkeeper', strength: 1},
      default::NPC {name: 'Mina Murray', strength: 2},
      default::NPC {name: 'Quincey Morris', strength: 4},
      default::NPC {name: 'Arthur Holmwood', strength: 4},
      default::NPC {name: 'John Seward', strength: 3},
      default::NPC {name: 'Abraham Van Helsing', strength: 1},
      default::NPC {name: 'Lucy Westenra', strength: 0},
    },
  },
}
</code></pre>
<p>You could imagine some other combinations of global modes such as a &quot;God Mode&quot; that also makes the character invincible - because it's annoying to try to debug test a game when other <code>PC</code>s think you are a regular player and keep killing your character without knowing that you are just there to test the game mechanics.</p>
<h2 id="backlinks"><a class="header" href="#backlinks">Backlinks</a></h2>
<p>It's finally time to learn one of EdgeDB's most powerful and useful features: backlinks. A backlink is like a regular link, except that it works in the other direction: instead of a link from your object to other objects, it's a computed property that shows the objects that link to you!</p>
<p>Understanding backlinks and the syntax can take a bit of effort, but it's well worth it.</p>
<p>First let's start by looking at some regular links. We know how to get Count Dracula's <code>slaves</code> by name with something like this:</p>
<pre><code class="language-edgeql">select Vampire {
  name,
  slaves: {
    name
  }
};
</code></pre>
<p>That shows us the following:</p>
<pre><code>{
  default::Vampire {
    name: 'Count Dracula',
    slaves: {
      default::MinorVampire {name: 'Vampire Woman 1'},
      default::MinorVampire {name: 'Vampire Woman 2'},
      default::MinorVampire {name: 'Vampire Woman 3'},
      default::MinorVampire {name: 'Lucy'},
    },
  },
}
</code></pre>
<p>But what if we are doing the opposite? Namely, starting from <code>select MinorVampire</code> and wanting to access the <code>Vampire</code> type connected to it. Because right now the <code>MinorVampire</code> type only gives us access to properties and links that belong to the <code>MinorVampire</code> and <code>Person</code> type. Imagine that we want to have a <code>master</code> link that shows the <code>Vampire</code> object that links to a <code>MinorVampire</code>...how do we do it?</p>
<pre><code class="language-edgeql">select MinorVampire {
  name,
  # master... how do we get this?
  # There's no link to Vampire inside MinorVampire...
}
</code></pre>
<p>Since there's no <code>master: Vampire</code> link, how do we go backwards to see the <code>Vampire</code> type that links to it?</p>
<p>This is where backlinks come in, by doing the following:</p>
<ul>
<li>Select the type that is being linked back to. Here that would be <code>MinorVampire</code>, because we want to see links to <code>MinorVampire</code> objects. If you are inside a type's schema, you don't need to write the type name.</li>
<li>Create a link that uses the <code>.&lt;</code> syntax instead of <code>.</code></li>
<li>Indicate the name of the link. We want to see <code>slaves</code> links from the <code>Vampire</code> type, so type <code>slaves</code> next.</li>
<li>Specify the type that we are looking for: <code>[is Vampire]</code>. This isn't strictly necessary, but helpful. We'll see why in a moment.</li>
</ul>
<p>So let's follow these steps to make our first backlink query. We want:</p>
<ul>
<li>A link to <code>MinorVampire</code> objects, so <code>select MinorVampire</code></li>
<li>The link to be a backlink, so add <code>.&lt;</code>: <code>select MinorVampire.&lt;</code></li>
<li>To look for links via a link called <code>slaves</code>, so add <code>slaves</code>: <code>select MinorVampire.&lt;slaves</code></li>
<li>The link to be from a <code>Vampire</code> object, so add <code>Vampire</code>: <code>select MinorVampire.&lt;slaves[is Vampire]</code></li>
</ul>
<p>This will return us one or more <code>Vampire</code> objects, on which of course we can add a shape. So the query will now look like this:</p>
<pre><code class="language-edgeql">select MinorVampire.&lt;slaves[is Vampire] {
  name,
  age
};
</code></pre>
<p>Because it goes in reverse order, it is selecting the <code>Vampire</code> objects that have a link called <code>slaves</code> that goes back <code>.&lt;</code> to the type <code>MinorVampire</code>.</p>
<p>You can think of the human readable version of <code>MinorVampire.&lt;slaves[is Vampire] {name, age}</code> as &quot;Show the name and age of the Vampire objects with a link called <code>slaves</code> that are of type MinorVampire&quot; - from right to left.</p>
<p>Here is the output:</p>
<pre><code>{default::Vampire {name: 'Count Dracula', age: 800}}
</code></pre>
<p>So far that's the same as just <code>select Vampire: {name, age}</code>. But it becomes very useful in our query before, where we wanted to access multiple types. Now we can select all the <code>MinorVampire</code> objects and their master:</p>
<pre><code class="language-edgeql">select MinorVampire {
  name,
  master := .&lt;slaves[is Vampire] {name},
};
</code></pre>
<p>And here is the human-readable version of <code>.&lt;slaves[is Vampire] {name}</code> to help it stick in your memory: &quot;the <code>Vampire</code> objects and their names that link back to <code>MinorVampire</code> through the link <code>slaves</code>&quot;.</p>
<p>Here is the output:</p>
<pre><code>{
  default::MinorVampire {name: 'Vampire Woman 1', 
    master: {default::Vampire {name: 'Count Dracula'}}},
  default::MinorVampire {name: 'Vampire Woman 2', 
    master: {default::Vampire {name: 'Count Dracula'}}},
  default::MinorVampire {name: 'Vampire Woman 3', 
    master: {default::Vampire {name: 'Count Dracula'}}},
  default::MinorVampire {name: 'Lucy', 
    master: {default::Vampire {name: 'Count Dracula'}}},
}
</code></pre>
<p>So why do we need <code>[is Vampire]</code> in the query anyway? We need this because there might be other objects of different types that link back to <code>MinorVampire</code> through a link called <code>slaves</code>. We can show this in a query on our <code>Place</code> type which is linked from quite a few types. What do you think this query will show?</p>
<pre><code class="language-edgeql">select Place {
 name,
 visitors := .&lt;places_visited
 };
</code></pre>
<p>In this case, we are asking EdgeDB to show us each and every object that is linking to each <code>Place</code> object via a link called <code>places_visited</code>. The output is quite large, so here is just one part of it:</p>
<pre><code>{
  default::Country {
    name: 'Romania',
    visitors: {
      default::Vampire {id: 41c0bdc4-fef1-11ed-a968-cb41382f27c2},
      default::NPC {id: e03f804e-f9b4-11ed-86c0-835ec28e5d08},
    },
  },
  default::City {
    name: 'Munich',
    visitors: {
      default::PC {id: dfd4e9dc-f9b4-11ed-86c0-b32fa282657d},
      default::NPC {id: e03f804e-f9b4-11ed-86c0-835ec28e5d08},
    },
  }
}
</code></pre>
<p>You can see that Romania has been visited by a <code>Vampire</code> object (that's Dracula) and an <code>NPC</code> object (that's Jonathan Harker), while Munich has been visited by a <code>PC</code> object (Emil Sinclair) and an <code>NPC</code> object (Jonthan Harker again).</p>
<p>So if we don't specify with <code>[is Vampire]</code> or <code>[is NPC]</code> then it will just return each and every object connected via a link called <code>places_visited</code>. This is fine, but it limits the shapes that we can make in the query. For example, there is no guarantee that any linking object will have the property <code>name</code> so this query won't work:</p>
<pre><code>db&gt; select Place {
.......  name,
.......  visitors := .&lt;places_visited {name}
.......  };
error: InvalidReferenceError: object type 'std::BaseObject' has no link or property 'name'
  ‚îå‚îÄ &lt;query&gt;:3:32
  ‚îÇ
3 ‚îÇ  visitors := .&lt;places_visited {name}
  ‚îÇ                                ^^^^ error
</code></pre>
<p>But if we specify the type, EdgeDB will now be able to tell if it has a certain property or not.</p>
<pre><code class="language-edgeql">select Place {
  name,
  vampire_visitors := .&lt;places_visited[is Vampire] {name},
  npc_visitors := .&lt;places_visited[is NPC] {name}
};
</code></pre>
<p>And with that we get a nice output that shows backlinks from multiple concrete types. Here is part of the output:</p>
<pre><code>{
  default::Country {
    name: 'Romania',
    vampire_visitors: {default::Vampire {name: 'Count Dracula'}},
    npc_visitors: {default::NPC {name: 'Jonathan Harker'}},
  },
  default::City {
    name: 'Munich',
    vampire_visitors: {},
    npc_visitors: {default::NPC {name: 'Jonathan Harker'}},
  },
}
</code></pre>
<p>One final note: this is why backlinks in EdgeDB are <code>multi</code> by default, as opposed to regular links which are <code>single</code> by default. After all, there might be a lot of objects here and there in our database that link back and it makes sense to assume that there could be a lot of them. But you can declare a backlink in your schema to be <code>single</code> if you want to insist that there can only be one object in a backlink.</p>
<p><a href="chapter14/code.html">Here is all our code so far up to Chapter 14.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice-13"><a class="header" href="#time-to-practice-13">Time to practice</a></h2>
<ol>
<li>
<p>How would you create a global str that tells you whether vampires are currently asleep or awake?</p>
</li>
<li>
<p>Using a computed backlink, how would you display 1) all the <code>Place</code> objects (plus their names) that have an <code>o</code> in the name and 2) the names of the people that visited them?</p>
</li>
<li>
<p>Using a computed backlink, how would you display all the Person objects that will later become <code>MinorVampire</code>s?</p>
<p>Hint: Remember, <code>MinorVampire</code> has a link back to the vampire's former self.</p>
</li>
<li>
<p>How would you give the <code>MinorVampire</code> type an annotation called <code>note</code> that says <code>'first_appearance for MinorVampire should always match last_appearance for its matching NPC type'</code>?</p>
</li>
<li>
<p>How would you see this <code>note</code> annotation for <code>MinorVampire</code> in a query?</p>
</li>
</ol>
<p><a href="chapter14/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>Time to get revenge.</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="tags-expression-on-error-messages"><a class="header" href="#tags-expression-on-error-messages">tags: Expression On, Error Messages</a></h2>
<h1 id="chapter-15---the-vampire-hunt-begins"><a class="header" href="#chapter-15---the-vampire-hunt-begins">Chapter 15 - The vampire hunt begins</a></h1>
<blockquote>
<p>It's good that Jonathan is back, but he is still in shock. He doesn't know if the experience with Dracula was real or not, and thinks he might be crazy. But then Jonathan meets Van Helsing who tells him that it was all true. Now that he knows everything was true, Jonathan becomes strong and confident again.</p>
<p>Our heroes begin the search for Dracula. The others learn that the Carfax mansion across from Dr. Seward's asylum is the one that Dracula bought. So that's why Renfield was so strongly affected!</p>
<p>The heroes search the house when the sun is up and find boxes of earth in which Dracula sleeps. They destroy them all in Carfax, but there are still many left in London. If they don't destroy the other boxes, Dracula will be able to rest in them during the day and terrorize London every night when the sun goes down.</p>
</blockquote>
<h2 id="more-abstract-types"><a class="header" href="#more-abstract-types">More abstract types</a></h2>
<p>Our heroes learned something about vampires in this chapter: vampires need to sleep in coffins (boxes for dead people) with holy earth during the day. That's why Dracula brought 50 of them over by ship on the Demeter. This is important for the mechanics of our game so we should create a type for this. And if we think about it:</p>
<ul>
<li>Each place in the world either has coffins or doesn't have them,</li>
<li>A place that has coffins is a place that vampires can enter and terrorize the people,</li>
<li>If a place has coffins, we should know how many of them there are.</li>
</ul>
<p>This sounds like a good case for an abstract type. Here it is:</p>
<pre><code class="language-sdl">abstract type HasCoffins {
  required coffins: int16 {
    default := 0;
  }
}
</code></pre>
<p>Most places will not have a special vampire coffin, so the default is 0. The <code>coffins</code> property is just an <code>int16</code>, and vampires can remain close to a place if the number is 1 or greater. In the mechanics of our game we would probably give vampires an activity radius of about 100 km from a place with a coffin. That's because of the typical vampire schedule which is usually as follows:</p>
<ul>
<li>Wake up refreshed in the coffin after the sun goes down, get ready to leave by 8 pm to find people to terrorize.</li>
<li>Feel a sense of freedom because the night has just begun, and start moving away from the safety of the coffins to find victims. A vampire might use a horse-driven carriage at 25 kph, which gives a pretty wide radius.</li>
<li>Around 1 or 2 am, the vampire start to feel nervous. The sun will be up in about 5 hours. Is there enough time to get home?</li>
</ul>
<p>So the part between 8 pm and 1 am is when the vampire is free to move away, and at 25 kph we get an activity radius of about 100 km around a coffin. At that distance, even the bravest vampire will start running back towards home by 2 am.</p>
<p>If we were building a more complex game, vampire terrorism on humans would be worse in the winter, when the activity radius might increase to about 150km due to longer nights... but we won't get that detailed here.</p>
<p>With our abstract type done, we will want to have a lot of types <code>extending</code> this. First we can have <code>Place</code> extend it, and that gives it to all the other location types such as <code>City</code> and <code>OtherPlace</code>:</p>
<pre><code class="language-sdl">abstract type Place extending HasCoffins {
  required name: str {
    delegated constraint exclusive;
  };
  modern_name: str;
  important_places: array&lt;str&gt;;
}
</code></pre>
<p>Ships are also big enough to have coffins (the Demeter had 50 of them, after all) so we'll extend for <code>Ship</code> as well:</p>
<pre><code class="language-sdl">type Ship extending HasCoffins {
  name: str;
  multi sailors: Sailor;
  multi crew: Crewman;
}
</code></pre>
<p>If we want, we can now make a quick function to test whether a vampire can enter a place:</p>
<pre><code class="language-sdl">function can_enter(person_name: str, place: HasCoffins) -&gt; optional str
  using (
    with vampire := (select Person filter .name = person_name),
    has_coffins := place.coffins &gt; 0,
      select vampire.name ++ ' can enter.' 
        if has_coffins else vampire.name ++ ' cannot enter.'
    );
</code></pre>
<p>The function returns an <code>optional str</code> because it may return an empty set. You'll also notice that <code>person_name</code> in this function actually just takes a str that it uses to select a <code>Person</code>. So technically it could say something like 'Jonathan Harker cannot enter'. </p>
<p>If we can't trust the user of the function to always enter a <code>Vampire</code> or <code>MinorVampire</code> object, there are some options:</p>
<ul>
<li>Overload the function to have two signatures, one for each type of Vampire:</li>
</ul>
<pre><code class="language-sdl">function can_enter(vampire: Vampire, place: HasCoffins) -&gt; optional str
function can_enter(vampire: MinorVampire, place: HasCoffins) -&gt; optional str
</code></pre>
<ul>
<li>Create an abstract type (like <code>type AnyVampire</code>) and extend it for <code>Vampire</code> and <code>MinorVampire</code>. Then <code>can_enter</code> can have this signature: </li>
</ul>
<pre><code class="language-sdl">function can_enter(vampire: AnyVampire, place: HasCoffins) -&gt; optional str
</code></pre>
<p>Let's learn a bit more about the <code>optional</code> keyword. Without it, you need to trust the users that the input argument will be there, because a function won't be called if the input is empty. We can illustrate this point with this simple function:</p>
<pre><code class="language-sdl">function try(place: City) -&gt; str
  using (
    select 'Called!'
  );
</code></pre>
<p>If we call it with this:</p>
<pre><code class="language-edgeql">select try((select City filter .name = 'London'));`
</code></pre>
<p>Then the output is <code>Called!</code> as we expected. The function requires a City as an argument, and then ignores it and returns 'Called!' instead. </p>
<p>So far so good, but the input is not optional so what happens if we type this instead?</p>
<pre><code class="language-edgeql">select try((select City filter .name = 'Beijing'));
</code></pre>
<p>Now the output will be {} because we've never inserted any data for the city 'Beijing' in our database (nobody in Bram Stoker's Dracula ever goes to Beijing). So what if we want the function to be called in any case? We can put the keyword <code>optional</code> in front of the parameter like this:</p>
<pre><code class="language-sdl">function try(place: optional City) -&gt; str
  using (
    select 'Called!'
  );
</code></pre>
<p>In this case we are still ignoring the argument <code>place</code> (the <code>City</code> type) but making it optional lets the function select 'Called!' regardless of whether it finds an argument or not. Having a <code>City</code> type and not having a <code>City</code> type are both acceptable in this case, and the function gets called in either case.</p>
<p>{ref}<code>The documentation &lt;docs:ref_sdl_function_typequal&gt;</code> explains it like this: </p>
<pre><code>...the function is called normally when the corresponding argument is empty ...
A notable example of a function that gets called on empty input is the coalescing operator.
</code></pre>
<p>Interesting! You'll remember the coalescing operator <code>??</code> that we first saw in Chapter 11. And when we look at {eql:op}<code>its signature &lt;docs:coalesce&gt;</code>, you can see the <code>optional</code> in there:</p>
<p><code>optional anytype ?? set of anytype -&gt; set of anytype</code></p>
<p>So those are some ideas for how to set up your functions depending on how you think people might use them.</p>
<p>We're coming up to an insert, so let's migrate the schema. Here are all the schema changes from the discussion so for in this chapter:</p>
<pre><code class="language-sdl">abstract type HasCoffins {
  required coffins: int16 {
    default := 0;
  }
}

abstract type Place extending HasCoffins {
  required name: str {
    delegated constraint exclusive;
  };
  modern_name: str;
  important_places: array&lt;str&gt;;
}

type Ship extending HasCoffins {
  name: str;
  multi sailors: Sailor;
  multi crew: Crewman;
}

function can_enter(person_name: str, place: HasCoffins) -&gt; optional str
  using (
    with vampire := (select Person filter .name = person_name),
    has_coffins := place.coffins &gt; 0,
      select vampire.name ++ ' can enter.' if has_coffins else vampire.name ++ ' cannot enter.'
    );
</code></pre>
<p>Now let's give London some coffins. According to the book, our heroes destroyed 29 coffins at Carfax that night, which leaves 21 in London.</p>
<pre><code class="language-edgeql">update City filter .name = 'London'
set {
  coffins := 21
};
</code></pre>
<p>Now we can finally call up our function and see if it works:</p>
<pre><code class="language-edgeql">select can_enter('Count Dracula', (select City filter .name = 'London'));
</code></pre>
<p>We get <code>{'Count Dracula can enter.'}</code>.</p>
<p>Some other possible ideas for improvement later on for <code>can_enter()</code> are:</p>
<ul>
<li>Move the property <code>name</code> from <code>Place</code> and <code>Ship</code> over to <code>HasCoffins</code>. Then the user could just enter a string. The function would then use it to <code>select</code> the type and then display its name, giving a result like &quot;Count Dracula can enter London.&quot;</li>
<li>Require a date in the function so that we can check if the vampire is dead or not first. For example, if we entered a date after Lucy died, it would just display something like the following:</li>
</ul>
<pre><code>vampire.name ++ ' is already dead on ' ++ &lt;str&gt;.date
++ ' and cannot enter ' ++ city.name`
</code></pre>
<h2 id="more-constraints"><a class="header" href="#more-constraints">More constraints</a></h2>
<p>Let's look at some more constraints. We've seen <code>exclusive</code> and <code>max_value</code> already, but there are {ref}<code>some others &lt;docs:ref_std_constraints&gt;</code> that we can use as well.</p>
<p>There is one called <code>max_len_value</code> that makes sure that a string doesn't go over a certain length. That could be good for our <code>PC</code> type. <code>NPC</code>s won't need this constraint because their names are already decided by us the creators of the game, but <code>max_len_value()</code> is good for <code>PC</code>s to make sure that players don't choose names that are too long to display. This constraint doesn't exist on the original <code>Person</code> type, so we'll also need to add the <code>overloaded</code> keyword here. The <code>PC</code> type with the new constraint now looks like this:</p>
<pre><code class="language-sdl">type PC extending Person {
  required class: Class;
  required created_at: datetime {
    default := datetime_of_statement()
  }
  required number: PCNumber {
    default := sequence_next(introspect PCNumber);
  }
  overloaded required name: str {
    constraint max_len_value(30);
  }
}
</code></pre>
<p>And now <code>PC</code> objects like this one with names that are too long won't be able to be inserted anymore:</p>
<pre><code class="language-edgeql">insert PC {
 class := Class.Rogue,
 name := &quot;Oh man, let me tell you about this PC and his name. It all began one day when..&quot;
};
</code></pre>
<p>The error is pretty nice and tells us everything we need to know:</p>
<pre><code>edgedb error: ConstraintViolationError: name must be no longer 
than 30 characters.
  Detail: `value of property 'name' of object type 'default`::`PC'` 
  must be no longer than 30 characters.
</code></pre>
<p>Another convenient constraint is called <code>one_of</code>, and is sort of like a quick enum. One place in our schema where we could use it is <code>title: str;</code> in our <code>Person</code> type. You'll remember that we added that in case we wanted to generate names from various parts (first name, last name, title, degree...). This constraint could work to make sure that people don't just make up their own titles:</p>
<pre><code class="language-sdl">title: str {
  constraint one_of('Mr.', 'Mrs.', 'Ms.', 'Lord');
}
</code></pre>
<p>For us it's probably not worth it to add a <code>one_of</code> constraint though, as there are probably too many titles throughout the book (Count, the German <em>Herr</em>, Lady, Dr., Ph.D., etc.).</p>
<p>Another place you could imagine using a <code>one_of</code> is in the months, because the book only goes from May to October of the same year. If we had an object type generating a date then you could have this sort of constraint inside it:</p>
<pre><code class="language-sdl">month: int64 {
  constraint one_of(5, 6, 7, 8, 9, 10);
}
</code></pre>
<p>But that will depend on how the game works.</p>
<p>Now let's learn about perhaps the most interesting constraint in EdgeDB: an expression that we create ourselves!</p>
<h2 id="expression-on-the-most-flexible-constraint"><a class="header" href="#expression-on-the-most-flexible-constraint"><code>expression on</code>: the most flexible constraint</a></h2>
<p>One particularly flexible constraint is called {eql:constraint}<code> ``expression on`` &lt;docs:std::expression&gt;</code>, which lets us add any expression we want. After <code>expression on</code> you add the expression (in brackets) that must return <code>true</code> to create an object. In other words: &quot;Create this object <em>as long as</em> (insert expression here)&quot;.</p>
<p>Let's say we need a type <code>Lord</code> for some reason later on, and all <code>Lord</code> types must have the word 'Lord' in their name. We can constrain the type to make sure that this is always the case. For this, we will use a function called {eql:func}<code>docs:std::contains</code> that looks like this:</p>
<pre><code class="language-sdl">std::contains(haystack: str, needle: str) -&gt; bool
</code></pre>
<p>This function returns <code>{true}</code> if the <code>haystack</code> (a string) contains the <code>needle</code> (usually a shorter string).</p>
<p>We can write the constraint with <code>expression on</code> and <code>contains()</code> like this:</p>
<pre><code class="language-sdl">type Lord extending Person {
  constraint expression on (
    contains(__subject__.name, 'Lord')
  );
}
</code></pre>
<p><code>__subject__</code> there refers to the object itself.</p>
<p>Let's do a migration here because a <code>Lord</code> type could be useful later.</p>
<p>Now when we try to insert a <code>Lord</code> without it, it won't work:</p>
<pre><code class="language-edgeql">insert Lord {
  name := 'Billy'
  # Other stuff..
};
</code></pre>
<p>But if the <code>name</code> is 'Lord Billy' (or 'Lord William', or 'Lord' anything), it will work.</p>
<p>While we're at it, let's practice doing a <code>select</code> and <code>insert</code> at the same time so we see the output of our <code>insert</code> right away. We'll change <code>Billy</code> to <code>Lord Billy</code> and say that Lord Billy (considering his great wealth) has visited every place in our database.</p>
<pre><code class="language-edgeql">select (
  insert Lord {
    name := 'Lord Billy',
    places_visited := (select Place),
  }
) {
  name,
  places_visited: {
    name
  }
};
</code></pre>
<p>Now that <code>.name</code> contains the substring <code>Lord</code>, it works like a charm:</p>
<pre><code>{
  default::Lord {
    name: 'Lord Billy',
    places_visited: {
      default::Country {name: 'Hungary'},
      default::Country {name: 'Romania'},
      default::Country {name: 'France'},
      default::Country {name: 'Slovakia'},
      default::Castle {name: 'Castle Dracula'},
      default::City {name: 'Whitby'},
      default::City {name: 'Munich'},
      default::City {name: 'Buda-Pesth'},
      default::City {name: 'Bistritz'},
      default::City {name: 'Exeter'},
      default::City {name: 'London'},
    },
  },
}
</code></pre>
<h2 id="setting-your-own-error-messages"><a class="header" href="#setting-your-own-error-messages">Setting your own error messages</a></h2>
<p>Since <code>expression on</code> is so flexible, you can use it in almost any way you can imagine. But that flexibility also means that there is no built-in way to let the user know how any <code>expression on</code> is supposed to work when a constraint is violated. Meanwhile, the automatically generated error message we have right now is not helping the user at all. Here's the message we got when we tried to insert a <code>Lord</code> named <code>Billy</code>:</p>
<pre><code>edgedb error: ConstraintViolationError: invalid Lord
  Detail: invalid value of object type 'default::Lord'
</code></pre>
<p>So there's no way to tell that the problem is that <code>name</code> needs <code>'Lord'</code> inside it. Fortunately, all constraints allow you to set your own error message just by opening up a block with <code>{}</code> and specifying an <code>errmessage</code>, like this: <code>errmessage := &quot;All lords need 'Lord' in their name.&quot;</code></p>
<p>Let's do that with our <code>Lord</code> type now:</p>
<pre><code class="language-sdl">type Lord extending Person {
  constraint expression on (contains(__subject__.name, 'Lord')) {
    errmessage := &quot;All lords need \'Lord\' in their name&quot;;
  }
}
</code></pre>
<p>If you do a migration now and try to insert a <code>Lord</code> that is just called <code>Billy</code>, the error now tells us what to do:</p>
<pre><code>`edgedb error: ConstraintViolationError: All lords need 'Lord' in their name
  Detail: All lords need 'Lord' in their name`
</code></pre>
<p>Much better! </p>
<h2 id="putting-backlinks-into-the-schema"><a class="header" href="#putting-backlinks-into-the-schema">Putting backlinks into the schema</a></h2>
<p>Back in Chapter 6 we removed <code>master</code> link from <code>MinorVampire</code>, because <code>Vampire</code> already has the <code>multi slaves</code> link to the <code>MinorVampire</code> type. One reason was complexity, and the other was because deleting without a deletion policy becomes impossible because they both depend on each other. But now that we know how to use backlinks, we can put <code>master</code> back in <code>MinorVampire</code> if we want. Let's follow the thought process that often leads to choosing to use a backlink.</p>
<p>First, here is the <code>MinorVampire</code> type at present:</p>
<pre><code class="language-sdl">type MinorVampire extending Person {
  former_self: Person;
}
</code></pre>
<p>To add the master link again, one way to start would be with a property called <code>master_name</code> that is just a string:</p>
<pre><code class="language-sdl">type MinorVampire extending Person {
  former_self: Person;
  required master_name: str;
};
</code></pre>
<p>Then we can use it to filter out the corresponding <code>Vampire</code> and assign it to a computed link named <code>master</code> as follows:</p>
<pre><code class="language-sdl">type MinorVampire extending Person {
  former_self: Person;
  required master_name: str;
  link master := (
    with master_name := .master_name
    assert_single(select Vampire filter .name = master_name));
};
</code></pre>
<p>Note: it's a single link, so we needed to add <code>assert_single()</code>. However, it looks a bit verbose, and we have to trust ourselves to input <code>master_name</code> correctly ‚Äî definitely not ideal. In this case there is a simpler and more robust way to add <code>master</code>: using a backlink. The syntax is the same as the syntax we used last chapter except that we don't need to specify that the link is to a <code>MinorVampire</code>, because we are already inside the <code>MinorVampire</code> type.</p>
<pre><code class="language-sdl">type MinorVampire extending Person {
  former_self: Person;
  single link master := assert_single(.&lt;slaves[is Vampire]);
};
</code></pre>
<p>Here we have written <code>single link</code> to ensure that the backlink is not a <code>multi link</code>, which requires <code>assert_single()</code>. This might not be needed if our game allows vampires to share <code>MinorVampire</code> objects. However, in this case we are sure that there will only be one Vampire master (Count Dracula is the only master vampire in the book) so we can declare it a <code>single link</code>.</p>
<p>And if we still want to have a shortcut for <code>master_name</code>, we can just add <code>property master_name := .master.name;</code> in the above <code>{}</code> as follows:</p>
<pre><code class="language-sdl">type MinorVampire extending Person {
  former_self: Person;
  single link master := assert_single(.&lt;slaves[is Vampire]);
  property master_name := .master.name;
};
</code></pre>
<p>Now let's do a migration and test it out. We'll make a vampire named Kain, who has two <code>MinorVampire</code> slaves named Billy and Bob.</p>
<pre><code class="language-edgeql">insert Vampire {
  name := 'Kain',
  slaves := {
    (insert MinorVampire {
      name := 'Billy',
    }),
    (insert MinorVampire {
      name := 'Bob',
    })
  }
};
</code></pre>
<p>Now if the <code>MinorVampire</code> type works as it should, we should be able to see Kain via the <code>master</code> link inside <code>MinorVampire</code> and we won't have to use a backlink. Let's check:</p>
<pre><code class="language-edgeql">select MinorVampire {
  name,
  master_name,
  master: {
    name
  }
} filter .name in {'Billy', 'Bob'};
</code></pre>
<p>And the result:</p>
<pre><code>{
  default::MinorVampire {
    name: 'Billy',
    master_name: 'Kain',
    master: default::Vampire {name: 'Kain'},
  },
  default::MinorVampire {
    name: 'Bob',
    master_name: 'Kain',
    master: default::Vampire {name: 'Kain'},
  },
}
</code></pre>
<p>Beautiful! All the information is right there.</p>
<p>We won't see Kain and his slaves anymore so let's get rid of them with a quick delete query. The <code>on source delete delete target</code> deletion policy on the <code>Vampire</code> policy makes this easy: just delete Kain.</p>
<pre><code class="language-edgeql">delete Vampire filter .name = 'Kain';
</code></pre>
<p>Of course, you don't have to depend on a deletion policy to delete objects. We could have deleted all three using this query for example:</p>
<pre><code>delete Person filter .name in {'Kain', 'Billy', 'Bob'};
</code></pre>
<p>And the advantage to this deletion is that it will return all three deleted objects and their types (and even their properties and links if we wanted to show them) instead of just a single deleted <code>Vampire</code> object with the other two deletions happening unseen to us.</p>
<pre><code>{
  default::MinorVampire {id: d01726cc-ff45-11ed-8310-7f94ffdd6f3b},
  default::MinorVampire {id: d01768da-ff45-11ed-8310-171ca2c022eb},
  default::Vampire {id: d0170a16-ff45-11ed-8310-7b730ce4d4f2},
}
</code></pre>
<p>Finally, let's add a backlink to the Party type that we created in Chapter 13. That's easy! The <code>PC</code> type links to <code>Party</code> via a link called <code>party</code> so all we have to do is turn that around.</p>
<pre><code class="language-sdl">type Party {
  name: str;
  link members := .&lt;party[is PC];
}
</code></pre>
<p>As you can see, once you understand how to write backlinks you start to wonder how you ever got anything done without them. They're one of the best reasons to use EdgeDB.</p>
<p><a href="chapter15/code.html">Here is all our code so far up to Chapter 15.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice-14"><a class="header" href="#time-to-practice-14">Time to practice</a></h2>
<ol>
<li>
<p>How would you create a type called Horse with a <code>required name: str</code> that can only be 'Horse'?</p>
</li>
<li>
<p>How would you let the user know that it needs to be called 'Horse'?</p>
</li>
<li>
<p>How would you make sure that <code>name</code> for type <code>NPC</code> is always between 5 and 30 characters in length?</p>
<p>Try it first with <code>expression on</code>.</p>
</li>
<li>
<p>How would you make a function called <code>display_coffins</code> that pulls up all the <code>HasCoffins</code> objects with more than 0 coffins?</p>
</li>
<li>
<p>How would you give the <code>Place</code> type a backlink to every <code>Person</code> type that visited it?</p>
</li>
</ol>
<p><a href="chapter15/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>Could Renfield be of help?</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="tags-indexing-string-functions"><a class="header" href="#tags-indexing-string-functions">tags: Indexing, String Functions</a></h2>
<h1 id="chapter-16---is-renfield-telling-the-truth"><a class="header" href="#chapter-16---is-renfield-telling-the-truth">Chapter 16 - Is Renfield telling the truth?</a></h1>
<blockquote>
<p>Arthur Holmwood's father has died and now Arthur is the head of the house. His new title is Lord Godalming, and he has a lot of money. With this money he helps the team to find the houses where Dracula has hidden his boxes.</p>
<p>Meanwhile, Van Helsing has become curious about Renfield and asks John Seward if he can meet him. They meet, and Van Helsing is surprised to see that Renfield is very educated and well-spoken. Renfield talks about Van Helsing's research, politics, history, and so on - he doesn't seem crazy at all! But the next time Van Helsing sees him Renfield doesn't want to talk and just calls him an idiot. Very confusing. Why does Renfield's mood keep changing?</p>
<p>One night, Renfield becomes very serious and asks the men to let him leave. Renfield says: ‚ÄúDon‚Äôt you know that I am sane and earnest...a sane man fighting for his soul? Oh, hear me! hear me! Let me go! let me go! let me go!‚Äù The men want to believe Renfield, but can't trust him. Finally Renfield stops and calmly says: ‚ÄúRemember, later on, that I did what I could to convince you tonight.‚Äù</p>
</blockquote>
<h2 id="index-on-for-quicker-lookups"><a class="header" href="#index-on-for-quicker-lookups"><code>index on</code> for quicker lookups</a></h2>
<p>We're getting closer to the end of the book and there is a lot of data that we haven't entered yet. There is also a lot of data from the original book that might be useful. Fortunately, the original text of Dracula is organized into letters, diary entries, newspaper reports, etc. that begin with the date and sometimes the time. They tend to start out like this:</p>
<pre><code>Dr. Seward‚Äôs Diary.
1 October, 4 a. m.‚ÄîJust as we were about to leave the house...

Letter, Van Helsing to Mrs. Harker.
‚Äú24 September.
‚ÄúDear Madam...

Mina Murray‚Äôs Journal.
8 August. ‚Äî Lucy was very restless all night, and I, too, could not sleep...
</code></pre>
<p>Having so many dates in the book is convenient for us. With this we can make a type that holds a date and a string from the book for us to search through later. Let's call it <code>BookExcerpt</code> (an &quot;excerpt&quot; meaning one small part of a larger text). This type has a keyword that we haven't seen before. Can you see where it is?</p>
<pre><code class="language-sdl">type BookExcerpt {
  required date: cal::local_datetime;
  required excerpt: str;
  index on (.date);
  required author: Person;
}
</code></pre>
<p>The {ref}<code> ``index on (.date)`` &lt;docs:ref_datamodel_indexes&gt;</code> part is new, and is a way to make queries that use <code>filter</code>, <code>order by</code>, or <code>group</code> faster. These three operations are faster with <code>index on</code> because now the database doesn't need to scan the whole set of objects in sequence to find objects that match.</p>
<pre><code class="language-{eval-rst}">.. note::
`index` is good in limited quantities, but you don't want to index everything. Here is why:

- It makes the queries faster, but increases the database size.
- This may make `insert`s and `update`s slower if you have too many.

If there were no downside to indexing, EdgeDB would just index everything for you by default. Since there is a downside, indexing only happens when you say so. A good rule of thumb for indexes might be to compare them to an index in a real book:

- Faster search but database size increases: You can find content inside a book yourself, but you could also add an index. An index increases the book size somewhat, but helps you find content faster.
- Inserts take longer: each book you print has that many extra pages to print.
- Updates take longer: If you just update the content in a book, the update itself is the end of the operation. But if you have an index, then you'll have to update that as well to match the changes.
</code></pre>
<p>Indexing on <code>date</code> on the <code>BookExcerpt</code> type seems like a good idea because the <code>BookExcerpt</code> data all comes from a single book, is inserted once, and doesn't need to be updated. For comparison, an index on a property inside <code>PC</code> might make less sense, because <code>PC</code> objects are going to be inserted and updated all the time.</p>
<p>EdgeDB will automatically index in a few cases. You don't need to think about adding <code>index</code> on:</p>
<ul>
<li>links,</li>
<li>exclusive constraints for a property.</li>
</ul>
<p>The automatically generated <code>id</code> property on every item is also always indexed.</p>
<p>So let's do a migration and insert two book excerpts. The strings in these entries are very long (pages long, sometimes) so we will only show the beginning and the end here:</p>
<pre><code class="language-edgeql">insert BookExcerpt {
  date := cal::to_local_datetime(1893, 10, 1, 4, 0, 0),
  author := assert_single((select Person filter .name = 'John Seward')),
  excerpt := 'Dr. Seward\'s Diary.\n 1 October, 4 a.m. -- Just as we were about to leave the house, an urgent message was brought to me from Renfield to know if I would see him at once...&quot;You will, I trust, Dr. Seward, do me the justice to bear in mind, later on, that I did what I could to convince you to-night.&quot;',
};
</code></pre>
<pre><code class="language-edgeql">insert BookExcerpt {
  date := cal::to_local_datetime(1893, 10, 1, 5, 0, 0),
  author := assert_single((select Person filter .name = 'Jonathan Harker')),
  excerpt := '1 October, 5 a.m. -- I went with the party to the search with an easy mind, for I think I never saw Mina so absolutely strong and well...I rest on the sofa, so as not to disturb her.',
};
</code></pre>
<p>Then later on we could do this sort of query to get all the entries in order and displayed as JSON. Perhaps the players in the game can visit a library where they can search for game details, and this requires sending a message in JSON format to the software that displays it on the screen. In any case, here is what such a query would look like:</p>
<pre><code class="language-edgeql">select &lt;json&gt;(
  select BookExcerpt {
    date,
    author: {
      name
    },
    excerpt
  } order by .date
);
</code></pre>
<p>Here's the JSON output (remember to make the output pretty with <code>\set output-format json-pretty</code>) which looks pretty nice:</p>
<pre><code>{
  &quot;date&quot;: &quot;1893-10-01T04:00:00&quot;,
  &quot;author&quot;: {&quot;name&quot;: &quot;John Seward&quot;},
  &quot;excerpt&quot;: &quot;Dr. Seward's Diary.\n 1 October, 4 a.m. -- Just as we were about to leave the house, an urgent message was brought to me from Renfield to know if I would see him at once...\&quot;You will, I trust, Dr. Seward, do me the justice to bear in mind, later on, that I did what I could to convince you to-night.\&quot;&quot;
}
{
  &quot;date&quot;: &quot;1893-10-01T05:00:00&quot;,
  &quot;author&quot;: {&quot;name&quot;: &quot;Jonathan Harker&quot;},
  &quot;excerpt&quot;: &quot;1 October, 5 a.m. -- I went with the party to the search with an easy mind, for I think I never saw Mina so absolutely strong and well...I rest on the sofa, so as not to disturb her.&quot;
}
</code></pre>
<p>After this, we can add a link to our <code>Event</code> type to join it to our new <code>BookExcerpt</code> type. <code>Event</code> now looks like this:</p>
<pre><code class="language-sdl">type Event {
  required description: str;
  required start_time: cal::local_datetime;
  required end_time: cal::local_datetime;
  required multi place: Place;
  required multi people: Person;
  multi excerpt: BookExcerpt; # Only this is new
  location: tuple&lt;float64, float64&gt;;
  east: bool;
  property url := get_url() ++ &lt;str&gt;.location.0 
    ++ '_N_' ++ &lt;str&gt;.location.1 ++ '_' ++ ('E' if .east else 'W');
}
</code></pre>
<p>You can see that <code>description</code> is a short string that we write, while <code>excerpt</code> links to the longer pieces of text that come directly from the book.</p>
<p>With this done, let's get back to the <code>BookExcerpt</code> type and the indexing it uses. We now know that indexing speeds up <code>filter</code>, <code>order</code> and <code>group</code> queries, but by how much? Fortunately EdgeDB has a keyword that can provide some insight into this.</p>
<h2 id="the-analyze-keyword"><a class="header" href="#the-analyze-keyword">The 'analyze' keyword</a></h2>
<p>One particularly nice addition to EdgeDB 3.0 which released in 2023 is the <code>analyze</code> keyword, which just might be EdgeDB's easiest keyword to use. To analyze a query...just put the word <code>analyze</code> in front of it and you're done!</p>
<p>Let's give it a try with perhaps the smallest and simplest query possible: <code>analyze select true;</code>. Here is the output:</p>
<pre><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Coarse-grained Query Plan ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
     ‚îÇ Time Cost Loops Rows Width ‚îÇ Relations
root ‚îÇ  0.0 0.01   1.0  1.0     1 ‚îÇ
</code></pre>
<p>That's quite a bit of output even for a query as small as this one. Let's look at one part of the output at a time to make sure we understand it.</p>
<p>Width: This refers to the average size in bytes per row. This is pretty easy to play around with by changing the query: <code>analyze select 9;</code> shows a width of 8 bytes, <code>analyze select &lt;int16&gt;9;</code> a width of 2 bytes. In Chapter 8 we learned that &quot;The <code>__type__</code> link and <code>id</code> property together always make up 32 bytes&quot;, and this can be seen in an <code>analyze</code> query too. Try <code>analyze select Person;</code> and you'll see a width of 32.</p>
<p>Rows: This refers to the number of items returned. Let's take a look at the output of <code>analyze select {8, 9};</code> to show this:</p>
<pre><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Coarse-grained Query Plan ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
     ‚îÇ Time Cost Loops Rows Width ‚îÇ Relations
root ‚îÇ  0.0 0.03   1.0  2.0     8 ‚îÇ
</code></pre>
<p>As you can see, there are two items inside this set so the number of rows is 2.</p>
<p>Now let's change this query to a tuple instead and see what happens:</p>
<pre><code class="language-edgeql">analyze select (8, 9);
</code></pre>
<p>This tuple holds two values, but the tuple is a single object so the <code>analyze</code> output shows a single row with a different width.</p>
<pre><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Coarse-grained Query Plan ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
     ‚îÇ Time Cost Loops Rows Width ‚îÇ Relations
root ‚îÇ  0.0 0.01   1.0  1.0    32 ‚îÇ
</code></pre>
<p>And if you try an <code>analyze select Person;</code> you should see about 25 rows at this point in the book.</p>
<p>Time: This is the actual time in milliseconds of a query. This is pretty easy to show by giving EdgeDB a massive query that takes more than a few seconds so that we can count along. Remember the chapter on Cartesian multiplication and how an operation on multiple sets with multiple items will return a number of items equal to their product? In other words, <code>select {1, 2} + {1, 2};</code> will return four items instead of two.</p>
<p>So let's do that with a query that returns about 21 million items:</p>
<pre><code class="language-edgeql">analyze select {8, 8, 1} + {8, 1, 8} + {8, 1, 8} + {8, 1, 8} + {9, 0, 10} + {8, 9, 10} + {9, 0, 0} + {0, 0, 0} + {9, 9, 0} + {9, 9, 0} + {9, 9, 0} + {9, 9, 0} + {8, 8, 8, 8} + {8, 8, 8, 8, 8} + {9, 9};
</code></pre>
<p>You can count to four as you watch this query happen. Once it is done, you should see an output like this showing that the query took about four seconds.</p>
<pre><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Coarse-grained Query Plan ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
     ‚îÇ   Time       Cost Loops       Rows Width ‚îÇ Relations
root ‚îÇ 4113.0 1009921.25   1.0 21257640.0     8
</code></pre>
<p>Cost: This is an arbitrary number used for comparison, so it doesn't mean dollars or cents or anything of the sort.</p>
<p>Loops: Loops refers to the number of &quot;executions of the node&quot;, which is information that comes from EdgeDB's Postgres backend. You could think of loops as a number representing the complexity of a query.</p>
<p>Relations: This refers to the links involved in a query. So while <code>analyze select NPC {*};</code> will not show any relations except to the type itself:</p>
<pre><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Coarse-grained Query Plan ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       ‚îÇ Time    Cost Loops Rows Width ‚îÇ Relations
‚ë† root ‚îÇ  0.3 1577.23   1.0  9.0    32 ‚îÇ NPC
</code></pre>
<p>Changing the single-splat operator to the double-splat operator will:</p>
<pre><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Coarse-grained Query Plan ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                      ‚îÇ Time       Cost  Loops Rows Width ‚îÇ Relations
‚ë† root                ‚îÇ  0.6  313151.13    1.0  9.0    32 ‚îÇ NPC
‚îú‚îÄ‚îÄ.lovers            ‚îÇ  0.3      493.9    9.0  1.0    32 ‚îÇ NPC.lovers, PC, Vampire, Lord,
‚îÇ                     ‚îÇ                                   ‚îÇ Sailor, NPC, Crewman,
‚îÇ                     ‚îÇ                                   ‚îÇ MinorVampire
‚ï∞‚îÄ‚îÄ.places_visited    ‚îÇ  0.1      93.98    9.0  1.0    32 ‚îÇ Country, OtherPlace, Castle,
                      ‚îÇ                                   ‚îÇ NPC.places_visited, City
</code></pre>
<p>The <code>analyze</code> keyword shows us that the splat operators, as fun and educational as they might be to use, have a performance impact. So be sure to use them only when experimenting with your code but not during production when you are paying the cost of every query.</p>
<p>Take this query for example:</p>
<pre><code class="language-edgeql">analyze select Place {*};
</code></pre>
<p>The output is as follows:</p>
<pre><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Coarse-grained Query Plan ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       ‚îÇ Time  Cost Loops Rows Width ‚îÇ Relations
‚ë† root ‚îÇ  0.2 135.9   1.0 12.0    32 ‚îÇ City, Country, Castle, OtherPlace
</code></pre>
<p>But if you didn't need to include <code>modern_name</code> on <code>Place</code> (for example), just removing that from the query improves performance a bit:</p>
<pre><code>db&gt; analyze select Place {name, coffins, id};

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Coarse-grained Query Plan ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       ‚îÇ Time  Cost Loops Rows Width ‚îÇ Relations
‚ë† root ‚îÇ  0.1 108.5   1.0 12.0    32 ‚îÇ City, Country, Castle, OtherPlace
</code></pre>
<p>So now that we know the basics of how to use <code>analyze</code>, let's learn a bit more about indexes and see what effect another index will have on our cost.</p>
<h2 id="indexes-again"><a class="header" href="#indexes-again">Indexes again</a></h2>
<p>Our <code>Event</code> type has a property called <code>location</code> that might be nice to filter or order by. Let's see how much it costs to use. And while we're at it, let's check the cost for the related <code>url</code> property too:</p>
<pre><code>db&gt; analyze select Event order by .location;

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Coarse-grained Query Plan ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       ‚îÇ Time  Cost Loops Rows Width ‚îÇ Relations
‚ë† root ‚îÇ  0.0 48.49   1.0  2.0    64 ‚îÇ Event

db&gt; analyze select Event order by .url;

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Coarse-grained Query Plan ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       ‚îÇ Time   Cost Loops Rows Width ‚îÇ Relations
‚ë† root ‚îÇ  0.0 145.99   1.0  2.0    64 ‚îÇ Event
</code></pre>
<p>Okay, so these two operations cost 48.49 and 145.99 units. (Remember, this doesn't represent dollars and cents or anything like that)</p>
<p>Next we'll a line to the <code>Event</code> type to index the <code>location</code> property:</p>
<pre><code class="language-sdl">type Event {
  required description: str;
  required start_time: cal::local_datetime;
  required end_time: cal::local_datetime;
  required multi place: Place;
  required multi people: Person;
  location: tuple&lt;float64, float64&gt;;
  index on (.location); # &lt;-------- Right here
  property ns_suffix := '_N_' if .location.0 &gt; 0.0 else '_S_';
  property ew_suffix := '_E' if .location.1 &gt; 0.0 else '_W';
  property url := get_url() 
    ++ &lt;str&gt;(math::abs(.location.0)) ++ .ns_suffix 
    ++ &lt;str&gt;(math::abs(.location.1)) ++ .ew_suffix;
}
</code></pre>
<p>And then do a migration. Let's see what the cost is now! We'll try the same two queries with <code>order</code> that we just did. Here is the result:</p>
<pre><code>db&gt; analyze select Event order by .location;

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Coarse-grained Query Plan ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       ‚îÇ Time Cost Loops Rows Width ‚îÇ Relations
‚ë† root ‚îÇ  0.0 1.03   1.0  2.0    64 ‚îÇ Event

db&gt; analyze select Event order by .url;

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Coarse-grained Query Plan ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       ‚îÇ Time Cost Loops Rows Width ‚îÇ Relations
‚ë† root ‚îÇ  0.0 1.33   1.0  2.0    64 ‚îÇ Event
</code></pre>
<p>That's a big difference! The cost for both operations is barely over 1 of these imaginary units, compared to before where we saw 48.49 and 145.99.</p>
<h2 id="two-more-notes-on-index-on"><a class="header" href="#two-more-notes-on-index-on">Two more notes on <code>index on</code></a></h2>
<p>Another nice thing about <code>index on</code> is that it can also be used on expressions that you we make ourselves. For example, if we always need to query a <code>City</code>'s name along with its population, we could index in this way:</p>
<pre><code class="language-sdl">type City extending Place {
  annotation description := 'A place with 50 or more buildings. Anything else is an OtherPlace';
  population: int64;
  index on (.name ++ ': ' ++ &lt;str&gt;.population);
}
</code></pre>
<p>Also don't forget that you can add add an annotation to this as well. <code>(.name ++ ': ' + &lt;str&gt;.population)</code> might be a good case for an annotation if you think readers of the code might not know what it's for:</p>
<pre><code>type City extending Place {
    annotation description := 'A place with 50 or more buildings. Anything else is an OtherPlace';
    population: int64;
    index on (.name ++ ': ' ++ &lt;str&gt;.population) {
      annotation title := 'Lists city name and population for display in Long Library stage';
    }
}
</code></pre>
<p>If you are a Postgres user, you might be familiar with the multiple ways that you can index values. These indexes are available in EdgeDB as of version 3.0 inside a module called <code>pg</code>. Using them is pretty simple: just put the name of the index in between <code>index</code> and <code>on</code>. For example: <code>index pg::gin on (.name)</code> instead of <code>index on (.name)</code>. The Postgres indexes are known as <code>hash</code>, <code>btree</code>, <code>gin</code>, <code>gist</code>, <code>spgist</code>, and <code>brin</code>. You can read more about these indexes <a href="https://www.edgedb.com/docs/datamodel/indexes">here</a>.</p>
<h2 id="more-functions-for-strings"><a class="header" href="#more-functions-for-strings">More functions for strings</a></h2>
<p>The {ref}<code>functions for strings &lt;docs:ref_std_string&gt;</code> can be particularly useful when doing queries on our <code>BookExcerpt</code> type (or <code>BookExcerpt</code> via <code>Event</code>). They are pretty easy to use, so a quick example for each of them should be enough to understand how they work.</p>
<p>One is called {eql:func}<code>docs:std::str_lower</code> and makes strings lowercase:</p>
<pre><code>db&gt; select str_lower('RENFIELD WAS HERE');
{'renfield was here'}
</code></pre>
<p>Here it is in a longer query:</p>
<pre><code class="language-edgeql">select BookExcerpt {
  excerpt,
  length := (&lt;str&gt;(select len(.excerpt)) ++ ' characters'),
  the_date := (select (&lt;str&gt;.date)[0:10]),
} filter contains(str_lower(.excerpt), 'mina');
</code></pre>
<p>It uses <code>len()</code> which is then cast to a string, and <code>str_lower()</code> to compare against <code>.excerpt()</code> by making it lowercase first. It also slices the <code>cal::local_datetime</code> into a string so it can just print indexes 0 to 10. Here is the output:</p>
<pre><code>{
  default::BookExcerpt {
    excerpt: '1 October, 5 a.m. -- I went with the party to the search with an easy mind, for I think I never saw Mina so absolutely strong and well...I rest on the sofa, so as not to disturb her.',
    length: '182 characters',
    the_date: '1893-10-01',
  },
}
</code></pre>
<p>Another way to make this <code>the_date</code> parameter is with the {eql:func}<code>docs:std::to_str</code> method, which (as you can probably guess) will turn it into a <code>str</code>. This function also allows us to change the format of a date depending on how readable we want to make it:</p>
<pre><code class="language-edgeql">select BookExcerpt {
  excerpt,
  length := (&lt;str&gt;(select len(.excerpt)) ++ ' characters'),
  the_date := (select to_str(.date)),
  the_date_pretty := (select to_str(.date, 'YYYY-MM-DD')),
  the_date_time_pretty := (select to_str(.date, 'YYYY-MM-DD HH:MM:SS')),
  the_date_verbose := (select to_str(.date, 'The DD of MM, YYYY'))
} filter contains(str_lower(.excerpt), 'mina');
</code></pre>
<p>Here's the output for that long query:</p>
<pre><code>{
  default::BookExcerpt {
    excerpt: '1 October, 5 a.m. -- I went with the party to the search with an easy mind, for I think I never saw Mina so absolutely strong and well...I rest on the sofa, so as not to disturb her.',
    length: '182 characters',
    the_date: '1893-10-01T05:00:00',
    the_date_pretty: '1893-10-01',
    the_date_time_pretty: '1893-10-01 05:10:00',
    the_date_verbose: 'The 01 of 10, 1893',
  },
}
</code></pre>
<p>Some other functions for strings are:</p>
<ul>
<li><code>find()</code> This gives the index of the first match it finds, and returns <code>-1</code> if it can't find anything. A <code>-1</code> is returned because that's the last character in a string, meaning that the function has reached the end but has found nothing. One example:</li>
</ul>
<pre><code class="language-edgeql">select find(BookExcerpt.excerpt, 'sofa');
</code></pre>
<p>This will return <code>{-1, 151}</code>. That's because first <code>BookExcerpt.excerpt</code> doesn't have the word <code>sofa</code>, while the second has it at index 151.</p>
<ul>
<li><code>str_split()</code> lets you make an array from a string, split however you like. It is most commonly used by using <code>' '</code> to separate words:</li>
</ul>
<pre><code>db&gt; select str_split('Oh, hear me! hear me! Let me go! let me go! let me go!', ' ');
{
  [
    'Oh,',
    'hear',
    'me!',
    'hear',
    'me!',
    'Let',
    'me',
    'go!',
    'let',
    'me',
    'go!',
    'let',
    'me',
    'go!',
  ],
}
</code></pre>
<p>But we can choose a letter to split at too:</p>
<pre><code class="language-edgeql">select MinorVampire {
  names := (select str_split(.name, 'ampire'))
};
</code></pre>
<p>Now the names have been split into arrays at each instance of <code>ampire</code>. Note that <code>Lucy</code> remains unchanged.</p>
<pre><code>{
  default::MinorVampire {names: ['V', ' Woman 1']},
  default::MinorVampire {names: ['V', ' Woman 2']},
  default::MinorVampire {names: ['V', ' Woman 3']},
  default::MinorVampire {names: ['Lucy']},
}
</code></pre>
<p>You can also split by <code>\n</code> to split by new line. You can‚Äôt see it as a human but from the point of view of the computer every line has an <code>\n</code> at the end if it is followed by another line. Take this for example:</p>
<pre><code class="language-edgeql">select str_split('Oh, hear me!
hear me!
Let me go!
let me go!
let me go!', '\n');
</code></pre>
<p>The output is an array of the text split by line:</p>
<pre><code>{['Oh, hear me!', 'hear me!', 'Let me go!', 'let me go!', 'let me go!']}
</code></pre>
<ul>
<li>Two functions called <code>re_match()</code> (for the first match) and <code>re_match_all()</code> (for all matches) if you know how to use <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a> (regexes) and want to use those. This could be especially useful for us because the book Dracula was written over 100 years ago and has different spelling sometimes. The word <code>tonight</code> for example is always written with the older <code>to-night</code> spelling in Dracula. We can use these functions to take care of that:</li>
</ul>
<pre><code class="language-edgeql">with text := 'Dracula is an old book,
so the word tonight is written to-night.
Tonight we know how to write both tonight and to-night.',
select re_match_all('[Tt]o-?night', text);
</code></pre>
<p>Here is the output:</p>
<pre><code>{['tonight'], ['to-night'], ['Tonight'], ['tonight'], ['to-night']}
</code></pre>
<p>The function signature is <code>std::re_match_all(pattern: str, string: str) -&gt; set of array&lt;str&gt;</code>, and as you can see the pattern comes first, then the string to match against. The pattern <code>[Tt]o-?night</code> means words that:</p>
<ul>
<li>start with a <code>T</code> or a <code>t</code>,</li>
<li>then have an <code>o</code>,</li>
<li>maybe have an <code>-</code> in between,</li>
<li>and end in <code>night</code>.</li>
</ul>
<p>And to match anything, you can use the wildcard character: <code>.</code></p>
<pre><code>db&gt; select re_match_all('.oo.', 'Noo, Lord Dracula, why did you lock the door?');
{['Noo,'], ['door']}
</code></pre>
<p>The <code>.</code> wildcard operator still determines the length of the slice of the string to match on, so you can use more of them to lengthen the part of the string in which we are looking for a match:</p>
<pre><code>db&gt; select re_match_all('.h...oo..', 'Noo, Lord Dracula, why did you lock the door?');
{['the door?']}
</code></pre>
<h2 id="changing-a-property-to-a-link"><a class="header" href="#changing-a-property-to-a-link">Changing a property to a link</a></h2>
<p>Our <code>Place</code> type has had a property called <code>important_places</code> for quite some time now: almost since the beginning of the book! This property is just an <code>&lt;array&lt;str&gt;&gt;</code>, which is better than nothing but not as good as a link. Let's remind ourselves what <code>important_places</code> are in the database at the moment:</p>
<pre><code class="language-edgeql">select Place {
  name, important_places
  } filter exists .important_places;
</code></pre>
<p>It turns out that we have a total of four <code>important_places</code>, all of which are located inside <code>City</code> objects:</p>
<pre><code>{
  default::City {name: 'Whitby', important_places: ['Whitby Abbey']},
  default::City {name: 'Bistritz', important_places: ['Golden Krone Hotel']},
  default::City {
    name: 'Buda-Pesth',
    important_places: ['Hospital of St. Joseph and Ste. Mary', 'Buda-Pesth University'],
  },
}
</code></pre>
<p>So let's think of a type we could make for these places. Our types that extend <code>Place</code> are all related to whether they have coffins or not, which is important in our game because places with coffins have a higher chance of being terrorized by vampires. These types so far are <code>City</code>, <code>Country</code>, <code>OtherPlace</code>, and <code>Castle</code> (which includes castle towns): all fairly large places that can be explored. But <code>important_places</code> seems more like a list of locations that are so tiny that keeping track of the number of coffins doesn't make any sense. In other words, it doesn't matter if the Golden Krone Hotel has coffins or not: it only matters if Bistritz has coffins in it or not.</p>
<p>So let's create a new type that is independent of the abstract type <code>Place</code>, and just call it <code>Landmark</code>:</p>
<pre><code class="language-sdl">type Landmark {
  required name: str;
  multi context: str;
}
</code></pre>
<p>Inside the <code>context</code> property we can just add parts of the book that reference the <code>Landmark</code>. We could have chosen <code>&lt;array&lt;str&gt;&gt;</code> but we haven't used <code>multi</code> properties much yet, so let's give that a try.</p>
<p>Eventually we will change our <code>Place</code> type so that <code>important places</code> changes from an <code>&lt;array&lt;str&gt;&gt;</code> to a <code>multi</code> link to <code>Landmark</code> that looks like the type below. The code below shows the final form for <code>Place</code>, but don't change it to this yet!</p>
<pre><code class="language-sdl">abstract type Place extending HasCoffins {
  required name: str {
    delegated constraint exclusive;
  }
  modern_name: str;
  multi important_places: Landmark;
}
</code></pre>
<p>We don't want to make this change yet because we will lose our data if we just change the type of <code>important_ places</code> to something else. Instead, we can first change our schema to add the <code>Landmark</code> type as a new <code>multi</code> link on <code>Place</code> we'll call <code>linked_important_places</code>. Let's make those changes and migrate the schema now:</p>
<pre><code class="language-sdl">type Landmark {
  required name: str;
  multi context: str;
}

abstract type Place extending HasCoffins {
  required name: str {
    delegated constraint exclusive;
  }
  modern_name: str;
  important_places: array&lt;str&gt;;
  multi linked_important_places: Landmark;
}
</code></pre>
<p>After doing a migration we now have the type <code>Landmark</code> in the schema, <code>Place</code> has a link to them, our <code>important_places</code> data is untouched, and we can now create some <code>Landmark</code> objects.</p>
<p>We can use the <code>array_unpack()</code> method to grab each <code>str</code> from all the <code>important_places</code> in all the <code>Place</code> objects we have so far, and use that to do the inserts:</p>
<pre><code class="language-edgeql">for place_name in select (array_unpack(Place.important_places))
union (insert Landmark {
  name := place_name
});
</code></pre>
<p>And now we can update our <code>Place</code> objects to have the link called <code>linked_important_places</code> to the <code>Landmark</code> objects that we have just inserted.</p>
<pre><code class="language-edgeql">update Place filter exists .important_places set {
  linked_important_places := (
    select Landmark filter .name in array_unpack(Place.important_places))
  };
</code></pre>
<p>This has returned three objects, so looks like it worked! Let's do a query to make sure:</p>
<pre><code class="language-edgeql">select Place {
  name,
  important_places,
  linked_important_places: { name }
  } filter exists .linked_important_places;
</code></pre>
<p>The output shows us that it worked! We can compare the existing data inside <code>important_places</code> and see that we now have <code>Landmark</code> objects with the same name as before.</p>
<pre><code>{
  default::City {
    name: 'Whitby',
    important_places: ['Whitby Abbey'],
    linked_important_places: {default::Landmark {name: 'Whitby Abbey'}},
  },
  default::City {
    name: 'Bistritz',
    important_places: ['Golden Krone Hotel'],
    linked_important_places: {default::Landmark {name: 'Golden Krone Hotel'}},
  },
  default::City {
    name: 'Buda-Pesth',
    important_places: ['Hospital of St. Joseph and Ste. Mary', 'Buda-Pesth University'],
    linked_important_places: {
      default::Landmark {name: 'Hospital of St. Joseph and Ste. Mary'},
      default::Landmark {name: 'Buda-Pesth University'},
    },
  },
}
</code></pre>
<p>And now that our data is safe, we can now do two more migrations. First we will remove <code>important_places</code> and migrate.</p>
<pre><code class="language-sdl">abstract type Place extending HasCoffins {
  required name: str {
    delegated constraint exclusive;
  }
  modern_name: str;
  multi linked_important_places: Landmark;
}
</code></pre>
<p>The CLI will ask us if we wanted to <code>drop property 'important_places' of object type 'default::Place'?</code>, to which the answer is yes.</p>
<p>And then we change the link name from <code>linked_important_places</code> to <code>important_places</code>, and do a migration again.</p>
<pre><code class="language-sdl">abstract type Place extending HasCoffins {
  required name: str {
    delegated constraint exclusive;
  }
  modern_name: str;
  multi important_places: Landmark;
}
</code></pre>
<p>This time the CLI asks us if we renamed <code>link 'linked_important_places' of object type 'default::Place' to 'important_places'?</code>, to which the answer once again is yes.</p>
<p>Let's do a final check to make sure that the data is there:</p>
<pre><code class="language-edgeql">select Place {
  name,
  important_places: { name }
} filter exists .important_places;
</code></pre>
<p>And the data is all there! Beautiful.</p>
<pre><code>{
  default::City {name: 'Whitby', important_places: {default::Landmark {name: 'Whitby Abbey'}}},
  default::City {
    name: 'Bistritz',
    important_places: {default::Landmark {name: 'Golden Krone Hotel'}},
  },
  default::City {
    name: 'Buda-Pesth',
    important_places: {
      default::Landmark {name: 'Hospital of St. Joseph and Ste. Mary'},
      default::Landmark {name: 'Buda-Pesth University'},
    },
  },
}
</code></pre>
<p>As always, the code at the end of the chapter will feature the inserts we would have made if we had had the current schema to begin with. So the insert for Buda-Pesth for example will now look like this, with the <code>Landmark</code> inserts at the same time.</p>
<pre><code class="language-edgeql">insert City {
  name := 'Buda-Pesth',
  modern_name := 'Budapest',
  important_places := {
    (insert Landmark {name := 'Hospital of St. Joseph and Ste. Mary'}),
    (insert Landmark {name := 'Buda-Pesth University'})
  }
};
</code></pre>
<p><a href="chapter16/code.html">Here is all our code so far up to Chapter 16.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice-15"><a class="header" href="#time-to-practice-15">Time to practice</a></h2>
<ol>
<li>
<p>How would you write a query to show all the <code>Person</code> names split into an array of two strings if they have two names and ignored if they don't have exactly two names?</p>
</li>
<li>
<p>How would you display all the <code>Person</code> names and where the string 'ma' is in their name?</p>
<p>Hint: this uses the function <code>find()</code>.</p>
</li>
<li>
<p>How would you index on the <code>pen_name</code> property for type Person?</p>
<p>Hint: try using <code>describe type Person as SDL</code> to take a look at it the <code>pen_name</code> property again.</p>
</li>
<li>
<p>How would you display the name of every <code>Person</code> in uppercase followed by a space and then the same name in lowercase?</p>
<p>Hint: the {eql:func}<code>docs:std::str_upper</code> function could help (though you will also need another function)</p>
</li>
<li>
<p>How would you use <code>re_match_all()</code> to display all the <code>Person.name</code>s with <code>Crewman</code> in the name? e.g. Crewman 1, Crewman 2, etc.</p>
<p>Hint: <a href="https://en.wikipedia.org/w/index.php?title=Regular_expression&amp;oldid=988356211#Basic_concepts">Here are some basic concepts</a> if you want a quick read on regular expressions.</p>
</li>
</ol>
<p><a href="chapter16/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>The truth about Renfield.</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="tags-aliases-named-tuples-mutation-rewrites"><a class="header" href="#tags-aliases-named-tuples-mutation-rewrites">tags: Aliases, Named Tuples, Mutation Rewrites</a></h2>
<h1 id="chapter-17---poor-renfield-poor-mina"><a class="header" href="#chapter-17---poor-renfield-poor-mina">Chapter 17 - Poor Renfield. Poor Mina.</a></h1>
<blockquote>
<p>Last chapter Dr. Seward and Dr. Van Helsing wanted to let Renfield out, but couldn't trust him. But it turns out that Renfield was telling the truth! Dracula had found out that night that the heroes were destroying his coffins and decided to attack Mina. Dracula succeeded, and now Mina is slowly turning into a vampire. She is still human, but has a connection with Dracula now.</p>
<p>The group finds Renfield in a pool of blood, dying. Renfield is sorry and tells them the truth. Renfield had been in communication with Dracula because he wanted to become a vampire too, so he let Dracula into the house. But once inside Dracula ignored Renfield, and headed for Mina's room. Renfield attacked Dracula to try to stop him from hurting Mina, but Dracula was much stronger and won.</p>
<p>Mina has not given up though, and has an idea. If she is now connected to Dracula, what happens if Van Helsing uses hypnotism on her? Could that work? Could they use the connection to Dracula to their advantage? Van Helsing takes out his pocket watch and tells her: &quot;Please concentrate on this watch. You are beginning to feel sleepy...what do you feel? Think about the man who attacked you, try to feel where he is...&quot;</p>
</blockquote>
<p>Renfield is no longer alive, so to start the chapter we need to use <code>update</code> to give him a <code>last_appearance</code>. Let's do a fancy one where we grab the output from <code>update</code> to display some interesting properties, including one where we use <code>last_appearance</code> minus <code>first_appearance</code> to show how long the character Renfield appears in the book:</p>
<pre><code class="language-edgeql">with updated := (update NPC filter .name = 'Renfield' set { last_appearance := &lt;cal::local_date&gt;'1893-10-03' })
  select updated {
    name,
   first_appearance,
   last_appearance,
   days_in_book := .last_appearance - .first_appearance
};
</code></pre>
<p>This gives us:</p>
<pre><code>{
  default::NPC {
    name: 'Renfield',
    first_appearance: &lt;cal::local_date&gt;'1893-05-26',
    last_appearance: &lt;cal::local_date&gt;'1893-10-03',
    days_in_book: &lt;cal::date_duration&gt;'P130D',
  },
}
</code></pre>
<h2 id="building-up-abstract-types"><a class="header" href="#building-up-abstract-types">Building up abstract types</a></h2>
<p>Wherever there are vampires, there are vampire hunters. Sometimes they will destroy a vampire's coffins, and other times vampires will build more. It would be nice to have a generic way to update this information. But the problem right now is this:</p>
<ul>
<li>the <code>HasCoffins</code> type is an abstract type, with one property: <code>coffins</code></li>
<li>places that can have coffins are <code>Place</code> and all the types from it, plus <code>Ship</code>,</li>
<li>the best way to filter is by <code>.name</code>, but <code>HasCoffins</code> doesn't have this property.</li>
</ul>
<p>So maybe it's time to turn this abstract type into a larger one called <code>HasNameAndCoffins</code>, and put the <code>name</code> and <code>coffins</code> properties inside there. This won't be a problem because every place needs a name and a number of coffins in our game. Remember, 0 coffins means that vampires can't stay in a place for long: just quick trips in at night before the sun rises. It's essentially a &quot;Has name and can vampires terrorize it&quot; property. And that will let us do queries on <code>HasNameAndCoffins</code> which is guaranteed to have these two properties.</p>
<p>Here is the type with its new property. We'll give it two constraints: <code>exclusive</code> and <code>max_len_value</code> to keep names from being too long.</p>
<pre><code class="language-sdl">abstract type HasNameAndCoffins {
  required coffins: int16 {
    default := 0;
  }
  required name: str {
    delegated constraint exclusive;
    constraint max_len_value(30);
  }
}
</code></pre>
<p>So now we can change our <code>Ship</code> type (notice that we removed <code>name</code>):</p>
<pre><code class="language-sdl">type Ship extending HasNameAndCoffins {
  multi sailors: Sailor;
  multi crew: Crewman;
}
</code></pre>
<p>And the <code>Place</code> type. It's much simpler now.</p>
<pre><code class="language-sdl">abstract type Place extending HasNameAndCoffins {
  modern_name: str;
  multi important_places: Landmark;
}
</code></pre>
<p>Finally, we can change our <code>can_enter()</code> function. This one needed a <code>HasCoffins</code> type before:</p>
<pre><code class="language-sdl">function can_enter(person_name: str, place: HasCoffins) -&gt; optional str
  using (
    with vampire := (select Person filter .name = person_name),
    has_coffins := place.coffins &gt; 0,
      select vampire.name ++ ' can enter.'
        if has_coffins else vampire.name ++ ' cannot enter.'
    );
</code></pre>
<p>But now that <code>HasNameAndCoffins</code> holds <code>name</code>, the user can now just enter a string. We'll change it to this:</p>
<pre><code class="language-sdl">function can_enter(person_name: str, place: str) -&gt; optional str
  using (
    with
      vampire := assert_single(
        (select Person filter .name = person_name)
      ),
      enter_place := assert_single(
        (select HasNameAndCoffins filter .name = place)
      )
    select vampire.name ++ ' can enter.' if enter_place.coffins &gt; 0 
      else vampire.name ++ ' cannot enter.'
  );
</code></pre>
<p>And now let's do a migration. The migration questions this time have some interesting ones, which are:</p>
<pre><code>did you drop function 'default::can_enter'? [y,n,l,c,b,s,q,?]
&gt; y
did you create function 'default::can_enter'? [y,n,l,c,b,s,q,?]
&gt; y
did you alter object type 'default::Place'? [y,n,l,c,b,s,q,?]
&gt; y
did you alter object type 'default::Ship'? [y,n,l,c,b,s,q,?]
&gt; y
The following extra DDL statements will be applied:
    ALTER TYPE default::Ship {
        ALTER PROPERTY name {
            RESET OPTIONALITY;
            DROP OWNED;
            RESET TYPE;
        };
    };
</code></pre>
<p>The CLI first asks us if we dropped the function <code>default::can_enter</code>, which we might be tempted to say no to - because from our point of view we changed, not dropped, this function. But remember that from the compiler's point of view a function with a different signature is a different function, so we are effectively dropping it and creating another one. And that means that the fact that they both have the same <code>can_enter</code> name is irrelevant!</p>
<p>The next few questions show that EdgeDB understands that we are using an abstract type to hold the <code>name</code> property that <code>Place</code> and <code>Ship</code> have held themselves all this time. It does this with a few extra DDL commands that alter the <code>name</code> property from one owned by <code>Ship</code> to one that is still inside the <code>Ship</code> type, just not owned anymore. The migration file holds the rest of the DDL commands, some of which are:</p>
<pre><code class="language-ddl">  ALTER TYPE default::Place {
      DROP EXTENDING default::HasCoffins;
      EXTENDING default::HasNameAndCoffins LAST;
      ALTER PROPERTY name {
          ALTER CONSTRAINT std::exclusive {
              RESET DELEGATED;
              DROP OWNED;
          };
          RESET OPTIONALITY;
          DROP OWNED;
          RESET TYPE;
      };
  };
  ALTER TYPE default::Ship {
      DROP EXTENDING default::HasCoffins;
      EXTENDING default::HasNameAndCoffins LAST;
  };
  ALTER TYPE default::Ship {
      ALTER PROPERTY name {
          RESET OPTIONALITY;
          DROP OWNED;
          RESET TYPE;
      };
  };
</code></pre>
<p>How nice that we don't have to type all of that ourselves! And if we do a query on the <code>Ship</code> and <code>Place</code> names we can see that all the data is still there.</p>
<pre><code>db&gt; select {Ship.name, Place.name};
{
  'The Demeter',
  'Castle Dracula',
  'Rumeli Feneri',
  'Whitby',
  'Buda-Pesth',
  'Bistritz',
  'Munich',
  'Exeter',
  'London',
  'Hungary',
  'Romania',
  'France',
  'Slovakia',
}
</code></pre>
<p>Meanwhile, with the new function in our schema we can just enter <code>can_enter('Count Dracula', 'Munich')</code> to get <code>'Count Dracula cannot enter.'</code>. That makes sense: Dracula didn't bring any coffins there.</p>
<p>Finally, thanks to this larger abstract type we can now put together a query that takes arguments to change the number of coffins in a number of places. It's easy:</p>
<pre><code class="language-edgeql">update HasNameAndCoffins filter .name = &lt;str&gt;$place_name
set {
  coffins := .coffins + &lt;int16&gt;$number
};
</code></pre>
<p>Now let's give the ship <code>The Demeter</code> some coffins.</p>
<pre><code>db&gt; update HasNameAndCoffins filter .name = &lt;str&gt;$place_name
  set {
    coffins := .coffins + &lt;int16&gt;$number
  };
Parameter &lt;str&gt;$place_name: The Demeter
Parameter &lt;int16&gt;$number: 10
</code></pre>
<p>Castle Dracula naturally should have some coffins too. 50 feels about right.</p>
<pre><code>db&gt; update HasNameAndCoffins filter .name = &lt;str&gt;$place_name
  set {
    coffins := .coffins + &lt;int16&gt;$number
  };
Parameter &lt;str&gt;$place_name: Castle Dracula
Parameter &lt;int16&gt;$number: 50
</code></pre>
<p>Then we'll make sure that these places got them:</p>
<pre><code class="language-edgeql">select HasNameAndCoffins { 
  name, 
  coffins } 
filter .coffins &gt; 0;
</code></pre>
<p>And the result:</p>
<pre><code>{
  default::Castle {name: 'Castle Dracula', coffins: 50},
  default::Ship {name: 'The Demeter', coffins: 20},
  default::City {name: 'London', coffins: 21},
}
</code></pre>
<p>Looks like the Demeter and Castle Dracula got their coffins!</p>
<h2 id="object-type-aliases-creating-subtypes-when-you-need-them"><a class="header" href="#object-type-aliases-creating-subtypes-when-you-need-them">Object type aliases: creating subtypes when you need them</a></h2>
<p>We've used abstract types a lot in this book. You'll notice that abstract types by themselves are generally made from very general concepts, such as <code>Person</code> and <code>HasNameAndCoffins</code>. In databases in real life you'll probably see them in the forms <code>HasEmail</code>, <code>HasID</code> and so on, which get extended to make subtypes.</p>
<p>Aliases will first look similar to extending an abstract type. Let's first compare the syntax between <code>extending</code> and using an alias so that you will be able to spot the difference:</p>
<pre><code class="language-sdl">type Vampire extending Person {
    # Properties and links
}

alias AliasPerson := Person {
    # Computables, etc.
};
</code></pre>
<p>The first difference is that an alias uses <code>:=</code> instead of <code>extending</code>. In other words, an alias is a computed expression. Also note that <code>alias Vampire</code> ends in a semicolon - again, because it is an expression. And since aliases are expressions and not standalone types, they can't be inserted into a database. Instead, they point to data ‚Äî often a type that exists in the database ‚Äî and can give it an extra shape on top of the original. So you can query an alias, but you can't insert one.</p>
<p>Let's make an alias for fun for our schema too. Looking at the Demeter again, we see that the ship left from Varna in Bulgaria and reached London. We'll imagine in our game that we have built Varna up into a big port for the characters to explore, and are changing the schema to reflect this. Right now our <code>Crewman</code> type just looks like this:</p>
<pre><code class="language-sdl">type Crewman extending HasNumber, Person {
  overloaded name: str {
    default := 'Crewman ' ++ &lt;str&gt;.number;
  }
}
</code></pre>
<p>Imagine that we would like a <code>CrewmanInBulgaria</code> type as well, because Bulgarians use the term 'Gospodin' to be polite (Bulgarian for &quot;Mister&quot;) and our game would like to reflect that. A Crewman will be called &quot;Gospodin (name)&quot; whenever they are in Bulgaria. In addition, the fresh Bulgarian air gives sailors extra strength in our game so our <code>CrewmanInBulgaria</code> objects will also be a bit stronger. You can see that an alias is much better than an entirely separate type here, because all we want to do is have a different shape to work with when making queries. Here's how to do that:</p>
<pre><code class="language-sdl">alias CrewmanInBulgaria := Crewman {
  name := 'Gospodin ' ++ .name,
  strength := .strength + &lt;int16&gt;1,
  # Just in case we want to filter on the original name
  original_name := .name,
};
</code></pre>
<p>You'll notice right away that <code>name</code> and <code>strength</code> inside the alias are separated by commas, not semicolons. That's a clue that this isn't creating a new type: it's just creating a <em>shape</em> on top of the existing <code>Crewman</code> type.</p>
<p>Let's do a schema migration and then take a look at the error we get if we try to insert a <code>CrewmanInBulgaria</code>. Remember, it won't work because an alias is just an expression, not a type that can be inserted:</p>
<pre><code class="language-edgeql">insert CrewmanInBulgaria {name := &quot;New Crewman&quot;, number := 6};
</code></pre>
<p>Here is the error:</p>
<pre><code>error: cannot insert into expression alias 'default::CrewmanInBulgaria'
</code></pre>
<p>So all inserts are still done through the <code>Crewman</code> type. But because an alias is a subtype and a shape, we can select it in the same way as anything else. Let's now compare a <code>select</code> on the <code>Crewman</code> objects to a <code>select</code> with the <code>CrewmanInBulgaria</code> alias:</p>
<pre><code>db&gt; select Crewman { name, strength };
{
  default::Crewman {name: 'Crewman 1', strength: 1},
  default::Crewman {name: 'Crewman 2', strength: 2},
  default::Crewman {name: 'Crewman 3', strength: 1},
  default::Crewman {name: 'Crewman 4', strength: 2},
  default::Crewman {name: 'Crewman 5', strength: 5},
}
db&gt; select CrewmanInBulgaria { original_name, name, strength };
{
  default::Crewman {original_name: 'Crewman 1', name: 'Gospodin Crewman 1', strength: 2},
  default::Crewman {original_name: 'Crewman 2', name: 'Gospodin Crewman 2', strength: 3},
  default::Crewman {original_name: 'Crewman 3', name: 'Gospodin Crewman 3', strength: 2},
  default::Crewman {original_name: 'Crewman 4', name: 'Gospodin Crewman 4', strength: 3},
  default::Crewman {original_name: 'Crewman 5', name: 'Gospodin Crewman 5', strength: 6},
}
</code></pre>
<p>The expression works well, giving names that start with Gospodin and strength values a bit higher than outside of Bulgaria. But note that the expression still returns a <code>default::Crewman</code>, as the alias is just an expression on top of the original type.</p>
<h2 id="local-expression-aliases-creating-new-names-for-types-in-a-query"><a class="header" href="#local-expression-aliases-creating-new-names-for-types-in-a-query">Local expression aliases: creating new names for types in a query</a></h2>
<p>It's somewhat interesting that our alias is just declared using a <code>:=</code> when we wrote <code>alias CrewmanInBulgaria := Crewman</code>. Would it be possible to do something similar inside a query? The answer is yes: we can use <code>with</code> and then give a new name for an existing type. (In fact, the keyword <code>with</code> that we have been using the whole time is defined as a &quot;{ref}<code>block used to define aliases &lt;docs:ref_eql_with&gt;</code>&quot;).</p>
<p>Let's say that we want to compare the strengths of all our <code>MinorVampire</code> objects. This first query won't work the way we want it to, and you can probably guess why:</p>
<pre><code class="language-edgeql">select MinorVampire.name ++ ' is stronger than ' ++ MinorVampire.name ++ '? ' 
++ &lt;str&gt;(MinorVampire.name &gt; MinorVampire.name);
</code></pre>
<p>It doesn't work because we are simply comparing one object against itself every time.</p>
<pre><code>{
  'Vampire Woman 1 is stronger than Vampire Woman 1? false',
  'Vampire Woman 2 is stronger than Vampire Woman 2? false',
  'Vampire Woman 3 is stronger than Vampire Woman 3? false',
  'Lucy is stronger than Lucy? false',
}
</code></pre>
<p>We know that the <code>detached</code> keyword can help by pulling up a separate set of objects for a type. It won't help us here though unfortunately as we have to use it twice: once to concatenate the names, and again to compare strengths:</p>
<pre><code class="language-edgeql">select MinorVampire.name ++ ' is stronger than ' ++ detached MinorVampire.name ++ '? '
++ &lt;str&gt;(MinorVampire.name &gt; detached MinorVampire.name);
</code></pre>
<p>Just a small portion of the output shows what the problem is here: using <code>detached</code> pulls up a separate set of <code>MinorVampire</code> objects each time. Every time <code>detached</code> is used, the number of objects doubles!</p>
<pre><code>{
  'Vampire Woman 1 is stronger than Vampire Woman 1? false',
  'Vampire Woman 1 is stronger than Vampire Woman 1? false',
  'Vampire Woman 1 is stronger than Vampire Woman 1? false',
  'Vampire Woman 1 is stronger than Vampire Woman 1? true',
  'Vampire Woman 1 is stronger than Vampire Woman 2? false',
  'Vampire Woman 1 is stronger than Vampire Woman 2? false',
  'Vampire Woman 1 is stronger than Vampire Woman 2? false',
}
</code></pre>
<p>Instead, we can use an alias for a set of <code>MinorVampire</code> objects and use that to compare:</p>
<pre><code class="language-edgeql">with M := MinorVampire,
select M.name ++ ' is stronger than ' ++ MinorVampire.name ++ '? ' ++ 
&lt;str&gt;(M.strength &gt; MinorVampire.strength);
</code></pre>
<p>The output is now closer to what we want, except that some objects with the same values are still being compared with each other. Here is part of the output (it's still pretty long):</p>
<pre><code>{
  'Vampire Woman 1 is stronger than Vampire Woman 1? false',
  'Vampire Woman 1 is stronger than Vampire Woman 2? false',
  'Vampire Woman 1 is stronger than Vampire Woman 3? false',
  'Vampire Woman 1 is stronger than Lucy? false',
  'Vampire Woman 2 is stronger than Vampire Woman 1? true',
  'Vampire Woman 2 is stronger than Vampire Woman 2? false',
  'Vampire Woman 2 is stronger than Vampire Woman 3? false',
  'Vampire Woman 2 is stronger than Lucy? false',
}
</code></pre>
<p>And since we are using <code>M</code> as an expression alias, we can use it to filter. Let's filter out the objects that share the same id.</p>
<pre><code class="language-edgeql">with M := MinorVampire,
select M.name ++ ' is stronger than ' ++ MinorVampire.name ++ '? ' ++ 
&lt;str&gt;(M.strength &gt; MinorVampire.strength) filter M.id != MinorVampire.id;
</code></pre>
<p>And now we no longer have any duplicate names.</p>
<pre><code>{
  'Vampire Woman 1 is stronger than Vampire Woman 2? false',
  'Vampire Woman 1 is stronger than Vampire Woman 3? false',
  'Vampire Woman 1 is stronger than Lucy? false',
  'Vampire Woman 2 is stronger than Vampire Woman 1? true',
  'Vampire Woman 2 is stronger than Vampire Woman 3? false',
  'Vampire Woman 2 is stronger than Lucy? false',
  'Vampire Woman 3 is stronger than Vampire Woman 1? true',
  'Vampire Woman 3 is stronger than Vampire Woman 2? true',
  'Vampire Woman 3 is stronger than Lucy? false',
  'Lucy is stronger than Vampire Woman 1? true',
  'Lucy is stronger than Vampire Woman 2? true',
  'Lucy is stronger than Vampire Woman 3? false',
}
</code></pre>
<p>But we aren't limited to just writing <code>:= MinorVampire</code> either. Because an alias is simply an expression, we can make some modifications to the set of objects we have been calling <code>M</code>. Let's make a set of <code>MinorVampire</code> objects (an &quot;expression alias&quot; of <code>MinorVampire</code>) that have a bit more strength than the regular set and compare them to the regular set of <code>MinorVampire</code> objects. While we're at it, let's change their names a bit too. This is starting to feel a lot like the alias we have in our schema, don't you think? The query now looks like this:</p>
<pre><code class="language-edgeql">with PumpedUp := MinorVampire {
name := 'Pumped up ' ++ .name,
strength := .strength + &lt;int16&gt;2
 },
select PumpedUp.name ++ ' is stronger than ' ++ MinorVampire.name ++
'? ' ++ 
&lt;str&gt;(PumpedUp.strength &gt; MinorVampire.strength) filter PumpedUp.id != MinorVampire.id;
</code></pre>
<p>Now the expression returns a lot more <code>true</code>, because the chance of having greater strength than the other object is that much greater.</p>
<pre><code>{
  'Pumped up Vampire Woman 1 is stronger than Vampire Woman 2? true',
  'Pumped up Vampire Woman 1 is stronger than Vampire Woman 3? false',
  'Pumped up Vampire Woman 1 is stronger than Lucy? false',
  'Pumped up Vampire Woman 2 is stronger than Vampire Woman 1? true',
  'Pumped up Vampire Woman 2 is stronger than Vampire Woman 3? true',
  'Pumped up Vampire Woman 2 is stronger than Lucy? true',
  'Pumped up Vampire Woman 3 is stronger than Vampire Woman 1? true',
  'Pumped up Vampire Woman 3 is stronger than Vampire Woman 2? true',
  'Pumped up Vampire Woman 3 is stronger than Lucy? true',
  'Pumped up Lucy is stronger than Vampire Woman 1? true',
  'Pumped up Lucy is stronger than Vampire Woman 2? true',
  'Pumped up Lucy is stronger than Vampire Woman 3? true',
}
</code></pre>
<p>So how about adding links and properties in the same way that we did to our <code>CrewmanInBulgaria</code> alias? We can do that too by using <code>select</code> and then adding any new links and properties you want inside <code>{}</code>. Here's a simple example:</p>
<pre><code class="language-edgeql">with NPCExtraInfo := NPC {
    would_win_against_dracula := .strength &gt; Vampire.strength
  }
  select NPCExtraInfo {
    name,
    would_win_against_dracula
  };
</code></pre>
<p>And here's the result. Looks like nobody wins:</p>
<pre><code>{
  default::NPC {name: 'Jonathan Harker', would_win_against_dracula: {false}},
  default::NPC {name: 'The innkeeper', would_win_against_dracula: {false}},
  default::NPC {name: 'Mina Murray', would_win_against_dracula: {false}},
  default::NPC {name: 'John Seward', would_win_against_dracula: {false}},
  default::NPC {name: 'Quincey Morris', would_win_against_dracula: {false}},
  default::NPC {name: 'Arthur Holmwood', would_win_against_dracula: {false}},
  default::NPC {name: 'Abraham Van Helsing', would_win_against_dracula: {false}},
  default::NPC {name: 'Lucy Westenra', would_win_against_dracula: {false}},
  default::NPC {name: 'Renfield', would_win_against_dracula: {false}},
}
</code></pre>
<p>Finally, let's create a quick type alias where Dracula has achieved all his goals and now rules London. We can give it the alias <code>DraculaKingOfLondon</code>, and a link to <code>subjects</code> (people who live under a king) that will be every <code>Person</code> that has been to London. Then we'll select this type, and also count how many subjects there are. It looks like this:</p>
<pre><code class="language-edgeql">with DraculaKingOfLondon := Vampire {
      name := .name ++ ', King of London',
      subjects := (select Person filter 'London' in .places_visited.name),
    } 
select DraculaKingOfLondon {
  name,
  subjects: {name},
  number_of_subjects := count(.subjects)
} filter .name = 'Count Dracula';
</code></pre>
<p>Here's the output:</p>
<pre><code>{
  default::Vampire {
    name: 'Count Dracula, King of London',
    subjects: {
      default::NPC {name: 'Jonathan Harker'},
      default::NPC {name: 'Mina Murray'},
      default::NPC {name: 'John Seward'},
      default::NPC {name: 'Quincey Morris'},
      default::NPC {name: 'Arthur Holmwood'},
      default::NPC {name: 'Abraham Van Helsing'},
      default::NPC {name: 'Lucy Westenra'},
      default::NPC {name: 'Renfield'},
      default::NPC {name: 'Lord Billy'},
    },
    number_of_subjects: 9,
  },
}
</code></pre>
<p>Note that this expression works because Count Dracula is our only <code>Vampire</code> object: he's almost like a unique global object. If we had more <code>Vampire</code> objects in the database we would need to filter by <code>name</code>.</p>
<h2 id="other-types-of-aliases"><a class="header" href="#other-types-of-aliases">Other types of aliases</a></h2>
<p>Aliases can be used in a number of other ways too. So far we have used object type aliases, but an alias is just an expression which makes them really quite open-ended. An alias can be a single scalar, a set of scalars, a tuple or set of tuples, a query, and so on. In this case an alias can feel a bit like a global value because it gives us quick access to some data that otherwise would be stored in a format like JSON somewhere.</p>
<p>For example, we could take an expression that helps us keep track of all the names we have in our database and turn it into an alias for convenience. At the moment, we have names for every <code>HasNameAndCoffins</code> object, plus every <code>modern_name</code> inside <code>Place</code>, <code>name</code> inside <code>Landmark</code> and of course the <code>name</code> property for the <code>Person</code> type:</p>
<pre><code>alias AllNames := (
  distinct (HasNameAndCoffins.name union
  Place.modern_name union
  Landmark.name union 
  Person.name)
);
</code></pre>
<p>Another alias we could put together is a tuple that holds all of the metadata for our game. This has a sort of JSON-like feel but is baked into our schema as an EdgeDB tuple. You could imagine this alias used for the player menu which displays differently depending on the language of the user:</p>
<pre><code class="language-sdl">alias GameInfo := (
  title := ( 
    en := &quot;Dracula the Immortal&quot;,
    fr := &quot;Dracula l'immortel&quot;,
    no := &quot;Dracula den ud√∏delige&quot;,
    ro := &quot;Dracula, nemuritorul&quot;
  ),
  country := &quot;Norway&quot;,
  date_published := 2023,
  website := &quot;www.draculatheimmortal.com&quot;
);
</code></pre>
<p>After doing a migration you can see how easy and readable these queries become:</p>
<pre><code>db&gt; select GameInfo.title.ro;
{'Dracula, nemuritorul'}
db&gt; select 'Max Demian' in AllNames;
{true}
db&gt; select 'Canada' in AllNames;
{false}
</code></pre>
<p>The {ref}<code>documentation on aliases &lt;docs:ref_cheatsheet_aliases&gt;</code> has a number of other interesting examples of how you might want to use an alias in your project.</p>
<h2 id="mutation-rewrites"><a class="header" href="#mutation-rewrites">Mutation rewrites</a></h2>
<p>Since version 3.0, EdgeDB allows us to automatically rewrite properties of an object whenever an insert or update happens. The syntax for a mutation rewrite is really simple: just choose <code>insert</code> and/or <code>update</code>, and then add the expression.</p>
<pre><code>rewrite {insert | update} [, ...]
  using expr
</code></pre>
<p>A mutation rewrite makes it really easy to keep track of when an object was last updated. To do this, just add a property to the object and a mutation rewrite that calls <code>datetime_of_statement()</code> whenever the object is inserted or updated. Let's give this a try on our <code>PC</code> type:</p>
<pre><code class="language-sdl">type PC extending Person {
  required class: Class;
  required created_at: datetime {
    default := datetime_of_statement()
  }
  required number: PCNumber {
    default := sequence_next(introspect PCNumber);
  }
  last_updated: datetime {
    rewrite insert, update using (datetime_of_statement());
  }
}
</code></pre>
<p>But while we are at it, let's stretch our imagination a bit and make another mutation rewrite for fun for the <code>PC</code> type. Imagine that every time a <code>PC</code> is created or gets to a save point (which updates it) we will give it a chance to win a bonus item at the same time. Let's call it a <code>LotteryTicket</code> and add some items that are useful to vampire hunters.</p>
<pre><code class="language-sdl">scalar type LotteryTicket extending enum &lt;Nothing, WallChicken, 
ChainWhip, Crucifix, Garlic&gt;;
</code></pre>
<p>Most of the time a lottery ticket will be nothing, but sometimes it will be a bonus item. Let's make a function to represent that:</p>
<pre><code class="language-sdl">  function get_ticket() -&gt; LotteryTicket using (
    with rnd := &lt;int16&gt;(random() * 10),
    select(LotteryTicket.Nothing if rnd &lt;= 6 else
    LotteryTicket.WallChicken    if rnd = 7 else
    LotteryTicket.ChainWhip      if rnd = 8 else
    LotteryTicket.Crucifix       if rnd = 9 else
    LotteryTicket.Garlic)
  );
</code></pre>
<p>Putting all those together, here are the changes to make to the schema:</p>
<pre><code class="language-sdl">type PC extending Person {
  required class: Class;
  required created_at: datetime {
    default := datetime_of_statement()
  }
  required number: PCNumber {
    default := sequence_next(introspect PCNumber);
  }
  last_updated: datetime {
    rewrite insert, update using (datetime_of_statement());
  }
  bonus_item: LotteryTicket {
    rewrite insert, update using (get_ticket());
  }
}

scalar type LotteryTicket extending enum &lt;Nothing, WallChicken, ChainWhip, Crucifix, Garlic&gt;;

function get_ticket() -&gt; LotteryTicket using (
  with rnd := &lt;int16&gt;(random() * 10),
  select(LotteryTicket.Nothing if rnd &lt;= 6 else
  LotteryTicket.WallChicken if rnd = 7 else
  LotteryTicket.ChainWhip if rnd = 8 else
  LotteryTicket.Crucifix if rnd = 9 else
  LotteryTicket.Garlic)
);
</code></pre>
<p>Once the migration is done, let's insert a new <code>PC</code> and see what she gets! First the insert:</p>
<pre><code class="language-edgeql">insert PC {
 name := 'Sypha',
 class := Class.Mystic
};
</code></pre>
<p>And now a few queries to see what Sypha's bonus item is. This will return something different every time, so let's &quot;update&quot; her by...just giving her the same name as before.</p>
<pre><code class="language-edgeql">update PC filter .name = 'Sypha' set { name := .name };
</code></pre>
<p>This will still count as an update to the object and thus the <code>last_updated</code> property will change, while the <code>bonus_item</code> is <em>likely</em> to change depending on the random number chosen. The output will look something like this:</p>
<pre><code>db&gt; select PC { name, class, bonus_item, last_updated } filter .name = 'Sypha';
{
  default::PC {
    name: 'Sypha',
    class: Mystic,
    bonus_item: Nothing,
    last_updated: &lt;datetime&gt;'2023-06-18T07:50:56.181567Z',
  },
}
db&gt; update PC filter .name = 'Sypha' set { name := .name };
{default::PC {id: 803d4486-0dac-11ee-9250-4746f54d7008}}
db&gt; select PC { name, class, bonus_item, last_updated } filter .name = 'Sypha';
{
  default::PC {
    name: 'Sypha',
    class: Mystic,
    bonus_item: Crucifix,
    last_updated: &lt;datetime&gt;'2023-06-18T07:51:03.998048Z',
  },
}
</code></pre>
<p><a href="chapter17/code.html">Here is all our code so far up to Chapter 17.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice-16"><a class="header" href="#time-to-practice-16">Time to practice</a></h2>
<ol>
<li>
<p>How would you display every NPC's name, strength, name and population of cities visited, and age (displaying 0 if age = <code>{}</code>)? Try it on a single line.</p>
</li>
<li>
<p>The query in 1. showed a lot of numbers without any context. What should we do?</p>
</li>
<li>
<p>How would you create an alias that contains all the months of the year?</p>
</li>
<li>
<p>How do you make sure that no data is lost when changing a type's properties from owned properties to properties extended from abstract types?</p>
</li>
</ol>
<p><a href="chapter17/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>Jonathan the detective.</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="tags-complex-inserts-schema-cleanup-triggers"><a class="header" href="#tags-complex-inserts-schema-cleanup-triggers">tags: Complex Inserts, Schema Cleanup, Triggers</a></h2>
<h1 id="chapter-18---using-draculas-own-weapon-against-him"><a class="header" href="#chapter-18---using-draculas-own-weapon-against-him">Chapter 18 - Using Dracula's own weapon against him</a></h1>
<blockquote>
<p>Van Helsing was correct: Mina is connected to Dracula. Van Helsing continues to use hypnotism to find out more about where Dracula is and what he is doing. </p>
<p>Meanwhile, Jonathan does a lot of investigation into Dracula's activities in London. He visits all the companies that were involved in selling Dracula's house, and some moving companies who moved his coffins around. Jonathan is becoming more and more confident, and only has one thought in his mind: find Dracula, destroy him, and save Mina.</p>
<p>Our heroes eventually find Dracula's other house in London with all of his money. Knowing that Dracula will come to get it, they wait for him to arrive.</p>
<p>Suddenly, Dracula runs into the house and attacks. Jonathan hits out with his knife, and cuts Dracula's bag with all his money. Dracula grabs some of the money that fell and jumps out the window. He yells at them: &quot;You shall be sorry yet, each one of you! You think you have left me without a place to rest; but I have more. My revenge is just begun!&quot; Then he disappears.</p>
</blockquote>
<p>This is a good reminder that we should probably think about money in our game. Money in a regular fantasy game is generally pretty easy: you can use a parameter called <code>gold</code> or something, call that the currency and give everyone a <code>gold</code> property. But our game is based on the real world. The characters have been to countries like England, Romania, and Germany, each of which have their own money.</p>
<p>On top of this is an extra difficulty: in the 1800s, monetary systems were more complicated than they are today. For example, the United Kingdom at the time didn't use a simple 100 pence to 1 pound conversion. Instead, it was as follows:</p>
<ul>
<li>12 pence (the smallest coin) made one shilling,</li>
<li>20 shillings made one pound, thus</li>
<li>240 pence per pound.</li>
</ul>
<p>(There was also a <em>halfpenny</em> that was half of one pence, but let's not get into that much detail in our game.)</p>
<p>Fortunately, even in this case we can default to the smallest unit of money when it comes to things like buying and selling.  By using the smallest unit of currency possible, we can do all calculations with integers instead of floats. For example, if a <code>Person</code> object with 5 pounds, 3 shillings and 5 pence wants to buy something that costs 1 shilling and 15 pence, we can calculate how much money the buyer has in pence:</p>
<ul>
<li>5 pounds, which equals 5 * 240 = 1200 pence,</li>
<li>3 shillings, which equals 3 * 20 = 60 pence,</li>
<li>5 pence.</li>
</ul>
<p>Which makes a total of 1265 pence for the buyer minus the item that costs 75 pence (3 shillings * 20, plus 15 pence). And since shopkeepers like to have small currencies (so they can give people change) and people like to have large currencies (so they aren't weighed down with too many coins), you can always subtract pence first, then shillings, and finally pounds when making a purchase.</p>
<p>There are many ways to represent money in a game. Let's think about them a bit:</p>
<ul>
<li>Simply adding properties like <code>pence</code>, <code>shilling</code> and <code>cent</code> to the <code>Person</code> type. This could work, but the <code>Person</code> type is already quite large. Plus there might be other objects that have money, such as <code>City</code> objects (if we wanted to keep track of a city's money supply). Even things like dead bodies could hold treasure and money.</li>
<li>Creating an object type for types of currency with a link to an <code>owner</code>. This could make sense, considering that in life there are always heaps of money that are linked to us. For example, $1000.50 USD in a bank that belongs to you can be thought of as a <code>USD</code> type that holds 1000 <code>dollars</code> and 50 <code>cents</code> and has a link to you, the owner. The <code>USD</code> type could extend an abstract <code>Currency</code> type, and then you, a <code>Person</code> object, would have a backlink for all the piles of money that link to you. This might be too complicated for our game, however, which is centered on <code>PC</code>s and which doesn't have too many currencies to think about.</li>
<li>Creating an abstract <code>HasMoney</code> type that can be extended by <code>Person</code> and anything else that holds money later on. This abstract type can hold each of the currencies as a property.</li>
</ul>
<p>This last option seems easiest, so let's try that. We'll start with a scalar type called <code>Money</code> that we can use for every type of currency in the game, and give it a minimum value of 0:</p>
<pre><code class="language-edgeql">  scalar type Money extending int64 {
    constraint min_value(0);
  }
</code></pre>
<p>With the <code>Money</code> type created, we can now move on to the abstract <code>HasMoney</code> type. Here it is to start:</p>
<pre><code class="language-edgeql">  abstract type HasMoney {
    pounds: Money;
    shillings: Money;
    pence: Money;
    dollars: Money;
    cents: Money;
  }
</code></pre>
<p>Next, we can make all of these properties <code>required</code> and give them a default value of 0. This will make calculations easier since we will be guaranteed to always have a value instead of an empty set:</p>
<pre><code class="language-edgeql">  abstract type HasMoney {
    required pounds: Money {
      default := 0;
    }
    required shillings: Money {
      default := 0;
    }
    required pence: Money {
      default := 0;
    }
    required cents: Money {
      default := 0;
    }
    required dollars: Money {
      default := 0;
    }
  }
</code></pre>
<p>And finally, to top it off let's add three computed properties called <code>total_pence</code>, <code>total_cents</code>, and <code>approx_wealth_in_pounds</code>. The first two represent the smallest units of currency in their respective countries, and so will represent a person's total wealth.</p>
<p>The last <code>approx_wealth_in_pounds</code> property shows the character's total wealth in pounds, which we will use as a general benchmark to compare all wealth. The calculation to make this property returns a float, but we are just using this for general comparisons and won't be using it to buy or sell anything. So we will cast it to an <code>int64</code> for readability.</p>
<p>At the time of the book, the exchange rate was about 8 US dollars to one pound (so 800 cents to one pound). Putting all that together, the final <code>HasMoney</code> type looks like this:</p>
<pre><code class="language-edgeql">  abstract type HasMoney {
    required pounds: Money {
      default := 0;
    }
    required shillings: Money {
      default := 0;
    }
    required pence: Money {
      default := 0;
    }    
    required cents: Money {
      default := 0;
    }
    required dollars: Money {
      default := 0;
    }
    property total_pence := .pounds * 240 + .shillings * 20 + .pence;
    property total_cents := .dollars * 100 + .cents;
    property approx_wealth_in_pounds := &lt;int64&gt;.total_pence / 240 + .total_cents / 800;
  }
</code></pre>
<p>With all the above done, just add <code>extending HasMoney</code> to the <code>Person</code> type, and do a migration. Now it's time to give our characters some money!</p>
<p>An average laborer in the United Kingdom in 1893 made 30 pounds per year. Both Arthur Holmwood and Count Dracula are lords with almost unimaginable amounts of money, so we'll <code>update</code> them with random numbers that should be well beyond anything a laborer can earn in a lifetime:</p>
<pre><code class="language-edgeql">update Person filter .name in { 'Arthur Holmwood', 'Count Dracula' }
 set {
   pounds := 3000 + &lt;int64&gt;(random() * 3000),
   shillings := 3000 + &lt;int64&gt;(random() * 3000),
   pence := 3000 + &lt;int64&gt;(random() * 3000)
};
</code></pre>
<p>And then a query to check how much money they have:</p>
<pre><code class="language-edgeql">select Person {
  name,
  pounds,
  shillings,
  pence,
  total_pence } filter .name in { 'Arthur Holmwood', 'Count Dracula' };
</code></pre>
<p>The output should show each of these two characters with some pretty incredible amounts of money.</p>
<pre><code>{
  default::NPC {
    name: 'Arthur Holmwood',
    pounds: 4249,
    shillings: 4219,
    pence: 3296,
    total_pence: 1107436,
  },
  default::Vampire {
    name: 'Count Dracula',
    pounds: 5967,
    shillings: 3539,
    pence: 3109,
    total_pence: 1505969,
  },
}
</code></pre>
<p>You can see that the <code>total_pence</code> property lets us quickly see who of the two is richer.</p>
<p>The other characters will get an <code>update</code> with more reasonable random amounts of money:</p>
<pre><code class="language-edgeql">update Person filter .name not in { 'Arthur Holmwood', 'Count Dracula' }
 set {
   pence := 100 + &lt;int64&gt;(random() * 100),
   shillings := 20 + &lt;int64&gt;(random() * 100),
   pounds := 10 + &lt;int64&gt;(random() * 100)
 };
</code></pre>
<p>Then we have Quincy Morris, who should have some USD because he is an American. Back in 1890 an average American worker earned about $500 a year. He is pretty wealthy too so we'll <code>update</code> him with a few times that amount.</p>
<pre><code class="language-edgeql">update Person filter .name = 'Quincey Morris'
 set { 
  dollars := 500 + &lt;int64&gt;(random() * 2000),
  cents := 500 + &lt;int64&gt;(random() * 2000)
};
</code></pre>
<p>And now let's try this query on all our <code>Person</code> objects.</p>
<pre><code>select Person {
  name,
  total_pence,
  total_cents,
  approx_wealth_in_pounds
 } order by .approx_wealth_in_pounds desc;
</code></pre>
<p>The output should be similar to the output below, with Count Dracula and Arthur Holmwood on top, Quincey Morris in third place, and other <code>Person</code> objects in random order. Looks like the Crewmen and Innkeeper have been doing pretty well for themselves!</p>
<pre><code>{
  default::Vampire {
    name: 'Count Dracula',
    total_pence: 1505969,
    total_cents: 0,
    approx_wealth_in_pounds: 6275,
  },
  default::NPC {
    name: 'Arthur Holmwood',
    total_pence: 1107436,
    total_cents: 0,
    approx_wealth_in_pounds: 4614,
  },
  default::NPC {
    name: 'Quincey Morris',
    total_pence: 27395,
    total_cents: 197076,
    approx_wealth_in_pounds: 360,
  },
  default::NPC {
    name: 'Mina Murray',
    total_pence: 27722,
    total_cents: 0,
    approx_wealth_in_pounds: 116,
  },
  default::Crewman {
    name: 'Crewman 2',
    total_pence: 25928,
    total_cents: 0,
    approx_wealth_in_pounds: 108,
  },
  default::Crewman {
    name: 'Crewman 4',
    total_pence: 25554,
    total_cents: 0,
    approx_wealth_in_pounds: 106,
  },
  default::NPC {
    name: 'The innkeeper',
    total_pence: 24409,
    total_cents: 0,
    approx_wealth_in_pounds: 102,
  },
  # And so on...
}
</code></pre>
<h2 id="triggers"><a class="header" href="#triggers">Triggers</a></h2>
<p>Let's give some thought to the actual users of our game - the people who will be signing up to make player characters to try to save the world from (or to help??) Count Dracula.</p>
<p>However the game takes shape, it will require some sort of account type to hold the information for the people using our game in real life. A simplified example of what we might need is as follows:</p>
<pre><code class="language-sdl">type Account {
  required name: str;
  required address: str;
  required username: str;
  required credit_card: CreditCardInfo {
    on source delete delete target;
  }
  multi pcs: PC;
}

type CreditCardInfo {
  required name: str;
  required number: str;

  link card_holder := .&lt;credit_card[is Account]
}
</code></pre>
<p>Every single property in these types is required, which makes sense - it's all personal information required to create accounts and pay for them.</p>
<p>Now let's think about what happens when an <code>Account</code> gets deleted. In almost every country, a company is legally bound to remove a user's personal information when they ask for an account to be deleted. With the <code>on source delete delete target</code> deletion policy, we have the <code>credit_card</code> link set up to delete any linked <code>CreditCardInfo</code> when an <code>Account</code> object is deleted. (A reminder: <code>on source delete delete target</code> means that when the source of the link is deleted, the target of the link gets deleted as well.) Deleting an <code>Account</code> object will delete absolutely everything to do with the user of our game.</p>
<p>However, users tend to be fickle. They might delete their accounts and regret doing so, they might delete an account by mistake, and so on. In that case they will get into contact with us asking if an account can be restored. Legally, however, we can't just keep the <code>Account</code> and <code>CreditCardInfo</code> objects around just in case! We are obligated to delete all of a user's information when they ask. How to solve this issue?</p>
<p>An easy way to solve this problem is by using <em>triggers</em>, which were added in EdgeDB 3.0. A trigger represents some sort of action that we want to take place every time an object is inserted, updated, or deleted. Let's first take a look at the official syntax for triggers to get an idea of how to use them:</p>
<pre><code>type type-name &quot;{&quot;
  trigger name
  after
    {insert | update | delete} [, ...]
    for {each | all}
    do expr
&quot;}&quot;
</code></pre>
<p>In other words:</p>
<ul>
<li>Decide on a name for a trigger (like <code>validate_input</code> or <code>check_length</code>),</li>
<li>Add the keyword <code>after</code>,</li>
<li>Decide for which cases we want a trigger to happen (only after an <code>insert</code>, after either an <code>insert</code> or an <code>update</code>, etc.),</li>
<li>Decide whether a trigger should happen on <code>each</code> object or once per query with <code>all</code>,</li>
<li>And finally the expression of the trigger itself.</li>
</ul>
<p>Inside a trigger we get access to the old object using <code>__old__</code> and the new object using <code>__new__</code>, though this depends on the operation. For example, when you <code>delete</code> there is no <code>__new__</code> object to access, nor is there an <code>__old__</code> object to access when doing an <code>insert</code>.</p>
<p>And now back to our <code>Account</code> type. To keep a minimal amount of information after a user's account is deleted, we can create a new type that holds this information. We can call this type <code>MinimalUserInfo</code>, because it will only hold their username and the <code>PC</code> objects they made. None of this information can be used to track down a person in real life so it is safe to hold, and at the same time it is enough information for us to restore an account. (Perhaps we will hold on to <code>PC</code> objects for 30 days or so in case a user changes their mind)</p>
<p>The <code>MinimalUserInfo</code> type is pretty simple, just a person's <code>username</code>, the <code>PC</code>s that they own, and an <code>int16</code> to hold a random number.</p>
<pre><code class="language-sdl">type MinimalUserInfo {
  username: str;
  multi pcs: PC;
  passcode: int16;
}
</code></pre>
<p>And now let's add the trigger to <code>Account</code> that inserts a <code>MinimalUserInfo</code> object every time an <code>Account</code> object is deleted. With this trigger in place, we can freely delete any <code>Account</code> objects and the user's personal information will be removed: name, address, and credit card info. But a <code>MinimalUserInfo</code> will always be created at the same time which holds the <code>username</code> and the <code>PC</code> objects linked to it. It will also hold a <code>passcode</code> which holds a number in between 100 and 500.</p>
<p>All together, the changes now look as follows:</p>
<pre><code class="language-sdl">type Account {
  required name: str;
  required address: str;
  required username: str;
  required credit_card: CreditCardInfo {
    on source delete delete target;
  }
  multi pcs: PC;

  trigger user_info_insert after delete for each do (
  insert MinimalUserInfo {
    username := __old__.name,
    pcs := __old__.pcs,
    passcode := &lt;int16&gt;(random() * 400) + 100,
  }
);
}

type CreditCardInfo {
  required name: str;
  required number: str;
  link card_holder := .&lt;credit_card[is Account]
}

type MinimalUserInfo {
  username: str;
  multi pcs: PC;
  passcode: int16;
}
</code></pre>
<p>Okay, let's do a migration and then insert an <code>Account</code> object. Look at all the personal information inside!</p>
<pre><code>insert Account {
  name := 'Deborah Brown',
  address := '10 Main Street',
  username := 'deb_deb_999',
  credit_card := (insert CreditCardInfo 
    {  name := 'DEBORAH LAURA BROWN',
       number := '000-000-000' }
  ),
  pcs := (insert PC 
    {  name := 'LordOfSalty',
       class := Class.Rogue
    }
  )
};
</code></pre>
<p>We have only one <code>Account</code> object so far so let's query with <code>select Account {**};</code> to see all of the information available. Here is the output:</p>
<pre><code>{
  default::Account {
    id: 6f67992a-0d90-11ee-b3bb-8f877d23b651,
    name: 'Deborah Brown',
    address: '10 Main Street',
    username: 'deb_deb_999',
    pcs: {
      default::PC {
        last_appearance: {},
        first_appearance: {},
        degrees: {},
        title: {},
        age: {},
        is_single: true,
        strength: {},
        name: 'LordOfSalty',
        pen_name: 'LordOfSalty',
        conversational_name: 'LordOfSalty',
        id: 6f67f154-0d90-11ee-b3bb-37992cdeda59,
        class: Rogue,
        created_at: &lt;datetime&gt;'2023-06-18T04:27:29.059881Z',
        number: 5,
      },
    },
    credit_card: default::CreditCardInfo {
      id: 6f678106-0d90-11ee-b3bb-13592cce3a16,
      name: 'DEBORAH LAURA BROWN',
      number: '000-000-000',
    },
  },
}
</code></pre>
<p>Looks good! That is, until Deborah decides she has been playing too many vampire games recently and would like to delete her account. We are sad to see her go but comply with her request:</p>
<pre><code class="language-edgeql">delete Account filter .user_name = 'deb_deb_999';
</code></pre>
<p>And now Deborah's personal information is all gone, as requested. But thanks to the trigger we added, we now have a <code>MinimalUserInfo</code> object in the database that was added automatically at the moment that we deleted Deborah's account. Let's take a look at it:</p>
<pre><code>select MinimalUserInfo {**};
</code></pre>
<p>Here is the output:</p>
<pre><code>{
  default::MinimalUserInfo {
    id: 5c17b0de-0d91-11ee-946c-6f411083ab25,
    username: 'deb_deb_999',
    passcode: 453,
    pcs: {
      default::PC {
        last_appearance: {},
        first_appearance: {},
        degrees: {},
        title: {},
        age: {},
        is_single: true,
        strength: {},
        name: 'LordOfSalty',
        pen_name: 'LordOfSalty',
        conversational_name: 'LordOfSalty',
        id: 59cbd4b8-0d91-11ee-946c-a3693fe5d218,
        class: Rogue,
        created_at: &lt;datetime&gt;'2023-06-18T04:34:02.301357Z',
        number: 8,
      },
    },
  },
}
</code></pre>
<p>With that we are holding none of Deborah's personal information anymore. All that we know is that some user called <code>deb_deb_999</code> had a <code>PC</code> called <code>LordOfSalty</code> - no personal info anywhere! Our software will check for new <code>MinimalUserInfo</code> objects and send off an email to users that have deleted their accounts to let them know how to restore their account if they wish. It would look something like this:</p>
<pre><code>We're sorry to see you go...

Your personal information has been deleted from our database. Your PCs have been kept on file for the next 30 days should you choose to restore your account. Keep the passcode safe if you think you might want to restore your account! It's the only way to verify your identity now that all of your personal information has been removed.

Account name: deb_deb_999
PC names: LordOfSalty
Passcode: 453
</code></pre>
<p>So if Deborah decides that she wants to get back into the world of vampire gaming she can choose to restore her account - as long as she remembers her username and passcode.</p>
<p><a href="chapter18/code.html">Here is all our code so far up to Chapter 18.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice-17"><a class="header" href="#time-to-practice-17">Time to practice</a></h2>
<ol>
<li>
<p>The Goldmark was used in Germany during the time of Bram Stoker's Dracula. One Goldmark had 100 Pfennig. How would you make this type?</p>
</li>
<li>
<p>Try adding two annotations to this type. One should be called <code>description</code> and mention that <code>One mark = 100 Pfennig</code>. The other should be called <code>note</code> and mention the types of coins there are.</p>
<p><a href="https://en.wikipedia.org/w/index.php?title=German_gold_mark&amp;oldid=972733514#Base_metal_coins">Here are the types of coins</a>: 1, 2, 5, 10, 20, 25 Pfennig coins.</p>
</li>
<li>
<p>A vampire named Godbrand has just attacked a village and turned three villagers into <code>MinorVampire</code>s. How would you insert all four of them at once?</p>
<p>Here is their data (name, date of birth (<code>first_appearance</code>), date turned into a MinorVampire (<code>last_appearance</code>)):</p>
<pre><code>('Fritz Frosch', '1850-01-15', '1893-09-11'),
('Levanta Sinyeva', '1862-02-24', '1893-09-11'),
('ÍπÄÌõà', '1860-09-09', '1893-09-11'),
</code></pre>
</li>
</ol>
<p><a href="chapter18/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>Only Mina can tell them where Dracula has gone.</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="tags-backlinks-schema-cleanup"><a class="header" href="#tags-backlinks-schema-cleanup">tags: Backlinks, Schema Cleanup</a></h2>
<h1 id="chapter-19---dracula-escapes"><a class="header" href="#chapter-19---dracula-escapes">Chapter 19 - Dracula escapes</a></h1>
<blockquote>
<p>Mina can feel Dracula's presence more and more as the days go by, and is slowly becoming a vampire herself. But she is still human, and is holding on. Van Helsing hypnotizes her to ask questions about where Dracula is now. Mina can feel where Dracula is...</p>
<p>Van Helsing: ‚ÄúWhere are you now?‚Äù</p>
<p>Mina: ‚ÄúI do not know. It is all strange to me!‚Äù</p>
<p>Van Helsing: ‚ÄúWhat do you see?‚Äù</p>
<p>Mina: ‚ÄúI can see nothing; it is all dark.‚Äù</p>
<p>Van Helsing: ‚ÄúWhat do you hear?‚Äù</p>
<p>Mina: ‚ÄúThe water... and little waves.‚Äù</p>
<p>Van Helsing: ‚ÄúThen you are on a ship?‚Äù</p>
<p>Mina: ‚ÄúOh, yes!‚Äù</p>
<p>Now our heroes know that Dracula has escaped on a ship with his last box and is going back to Transylvania. Van Helsing and Mina go to Castle Dracula, while the others go to Varna to try to catch the ship when it arrives. Jonathan Harker just sits there and sharpens his knife. He looks like a different person now. Jonathan has lost all of his fear and only wants to kill Dracula and save his wife. But where is the ship? Every day they wait... and then one day, they get a message: Dracula's ship arrived at Galatz up the river, not Varna! Are they too late? They rush off up the river to try to find Dracula.</p>
</blockquote>
<h2 id="adding-some-new-types"><a class="header" href="#adding-some-new-types">Adding some new types</a></h2>
<p>Looks like we have another ship moving around the map in this chapter. Last time, we made a <code>Ship</code> type that looks like this:</p>
<pre><code class="language-sdl">type Ship extending HasNameAndCoffins {
  multi sailors: Sailor;
  multi crew: Crewman;
}
</code></pre>
<p>That's not bad, but we can build on it a bit more in this chapter. Right now, it doesn't have any information about visits made by which ship to where. Let's make a quick type that contains all the information on ship visits. Each visit will have a link to a <code>Ship</code> and a <code>Place</code>, and a <code>cal::local_date</code>. It looks like this:</p>
<pre><code class="language-sdl">type ShipVisit {
  required ship: Ship;
  required place: Place;
  required date: cal::local_date;
}
</code></pre>
<p>This new ship that Dracula is on is called the <code>Czarina Catherine</code> (a Czarina is a Russian queen). Let's do a migration, and then insert a few visits from the ships we know. The other ship that we saw in the book was called The Demeter and left from Varna on its trip to Whitby.</p>
<p>But first we'll insert a new <code>Ship</code> and two new places (<code>City</code> objects) so we can link them. We know the name of the ship and that there is one coffin in it: Dracula's last coffin. But we don't know about the crew, so we'll just insert this information:</p>
<pre><code class="language-edgeql">insert Ship {
  name := 'Czarina Catherine',
  coffins := 1,
};
</code></pre>
<p>After that we have the two cities of Varna and Galatz. We'll put them in at the same time:</p>
<pre><code class="language-edgeql">for city in {'Varna', 'Galatz'}
union (
  insert City {
    name := city
  }
);
</code></pre>
<p>The captain's book from the Demeter has a lot of other places too, so let's look at a few of them. The Demeter also passed through the Bosphorus. That is the strait in Turkey that connects the Black Sea to the Aegean Sea, and divides Europe from Asia, so it's not a city. We can use the <code>OtherPlace</code> type for it, which is also the type we added some annotations to in Chapter 14. Remember how to look at the message inside an annotation? It looks like this:</p>
<pre><code class="language-edgeql">select (introspect OtherPlace) {
  name,
  annotations: {
    @value
  }
};
</code></pre>
<p>Let's look at the output to see what we wrote before to make sure that we should use it:</p>
<pre><code>{
  schema::ObjectType {
    name: 'default::OtherPlace',
    annotations: {
      schema::Annotation {
        @value: 'A place with under 50 buildings - hamlets, small villages, etc.',
      },
      schema::Annotation {
        @value: 'Castles and castle towns do not count! Use the Castle type for that',
      },
    },
  },
}
</code></pre>
<p>Well, the Bosphorus isn't a castle and it isn't actually a place with buildings, so it should work. Soon we will create a <code>Region</code> type so that we can have a <code>Country</code> ‚Üí <code>Region</code> ‚Üí <code>City</code> layout. In that case, <code>OtherPlace</code> might be linked to from <code>Country</code> or <code>Region</code>. But in the meantime we'll add it without being linked to anything:</p>
<pre><code class="language-edgeql">insert OtherPlace {
  name := 'Bosphorus'
};
</code></pre>
<p>That was easy. Now we can put the ship visits in.</p>
<pre><code class="language-edgeql">for visit in {
    ('The Demeter', 'Varna', '1893-07-06'),
    ('The Demeter', 'Bosphorus', '1893-07-11'),
    ('The Demeter', 'Whitby', '1893-08-08'),
    ('Czarina Catherine', 'London', '1893-10-05'),
    ('Czarina Catherine', 'Galatz', '1893-10-28')
  }
union (
  insert ShipVisit {
    ship  := (select Ship filter .name = visit.0),
    place := (select Place filter .name = visit.1),
    date  := &lt;cal::local_date&gt;visit.2
  }
);
</code></pre>
<p>With this data, now our game can have certain ships in cities at certain dates. For example, imagine that a character has entered the city of Galatz. If the date is 28 October 1893, we can see if there are any ships in town:</p>
<pre><code class="language-edgeql">select ShipVisit {
  ship: {
    name
  },
  place: {
    name
  },
  date
} filter .place.name = 'Galatz' and .date = &lt;cal::local_date&gt;'1893-10-28';
</code></pre>
<p>And it looks like there is a ship in town! It's the Czarina Catherine.</p>
<pre><code>{
  default::ShipVisit {
    ship: default::Ship {name: 'Czarina Catherine'},
    place: default::City {name: 'Galatz'},
    date: &lt;cal::local_date&gt;'1893-10-28',
  },
}
</code></pre>
<p>While we're doing this, let's practice computed backlinks again on our visits. Our <code>Ship</code> type doesn't contain any information on the places that it visited:</p>
<pre><code class="language-sdl">type Ship extending HasNameAndCoffins {
  multi sailors: Sailor;
  multi crew: Crewman;
}
</code></pre>
<p>But if we use a backlink we can see all of this information. Let's show all of the <code>Ship</code> objects, their name, sailors and crew, plus the place names and dates of all the visits they made.</p>
<pre><code class="language-edgeql">select Ship {
 name,
 sailors: { name },
 crew: { name },

 # All of the ShipVisit objects with a ship property
 # that link to a Ship object
 visits := .&lt;ship[is ShipVisit] {
   place: {name},
   date
  }
};
</code></pre>
<p>The output is pretty nice! It's basically a report on every ship, who is on them and where and when they visited.</p>
<pre><code>{
  default::Ship {
    name: 'The Demeter',
    sailors: {
      default::Sailor {name: 'The Captain'},
      default::Sailor {name: 'Petrofsky'},
      default::Sailor {name: 'The Second Mate'},
      default::Sailor {name: 'The Cook'},
    },
    crew: {
      default::Crewman {name: 'Crewman 1'},
      default::Crewman {name: 'Crewman 2'},
      default::Crewman {name: 'Crewman 3'},
      default::Crewman {name: 'Crewman 4'},
      default::Crewman {name: 'Crewman 5'},
    },
    visits: {
      default::ShipVisit {
        place: default::City {name: 'Varna'},
        date: &lt;cal::local_date&gt;'1893-07-06',
      },
      default::ShipVisit {
        place: default::OtherPlace {name: 'Bosphorus'},
        date: &lt;cal::local_date&gt;'1893-07-11',
      },
      default::ShipVisit {
        place: default::City {name: 'Whitby'},
        date: &lt;cal::local_date&gt;'1893-08-08',
      },
    },
  },
  default::Ship {
    name: 'Czarina Catherine',
    sailors: {},
    crew: {},
    visits: {
      default::ShipVisit {
        place: default::City {name: 'London'},
        date: &lt;cal::local_date&gt;'1893-10-05',
      },
      default::ShipVisit {
        place: default::City {name: 'Galatz'},
        date: &lt;cal::local_date&gt;'1893-10-28',
      },
    },
  },
}
</code></pre>
<h2 id="some-schema-changes-and-cleanup"><a class="header" href="#some-schema-changes-and-cleanup">Some schema changes and cleanup</a></h2>
<p>The heroes of the story found out about when the Czarina Catherine arrived thanks to a telegram by a company in the city of Varna that told them. Here's what it said:</p>
<pre><code>28 October.‚ÄîTelegram. Rufus Smith, London, to Lord Godalming, care H. B. M. Vice Consul, Varna.

‚ÄúCzarina Catherine reported entering Galatz at one o‚Äôclock to-day.‚Äù
</code></pre>
<p>Speaking of time, remember our <code>Time</code> type? We originally made it so that we could enter a string and get some helpful information in return. It looks like this:</p>
<pre><code class="language-sdl">type Time { 
  required clock: str; 
  property clock_time := &lt;cal::local_time&gt;.clock; 
  property hour := .clock[0:2]; 
  property vampires_are := 
    SleepState.Asleep if &lt;int16&gt;.hour &gt; 7 and &lt;int16&gt;.hour &lt; 19
    else SleepState.Awake;
}
</code></pre>
<p>We later made the decision to turn this type into a global type, because it didn't make sense to have random <code>Time</code> objects floating around in the database. A single <code>Time</code> object made much more sense. But looking at the <code>Time</code> type again, it looks like some of the properties would be a good fit for the <code>ShipVisit</code> type. Let's steal a few of them to make <code>ShipVisit</code> a little more expressive:</p>
<pre><code class="language-sdl">type ShipVisit {
  required ship: Ship;
  required place: Place;
  required date: cal::local_date;
  clock: str;
  property clock_time := &lt;cal::local_time&gt;.clock;
  property hour := .clock[0:2];
  property vampires_are := SleepState.Asleep if &lt;int16&gt;.hour &gt; 7 and &lt;int16&gt;.hour &lt; 19
        else SleepState.Awake;
}
</code></pre>
<p>Then do a schema migration and update the visit to Galatz to give it a <code>clock</code>:</p>
<pre><code class="language-edgeql">update ShipVisit filter .place.name = 'Galatz'
set {
  clock := '13:00:00'
};
</code></pre>
<p>Then we'll query this <code>ShipVisit</code> to Galatz again. Let's add a computed property for fun, assuming that it took two hours, five minutes and ten seconds for Arthur to get the telegram. We'll cast the string to a <code>cal::local_time</code> and then add a <code>duration</code> to it.</p>
<pre><code class="language-edgeql">with duration := &lt;duration&gt;'2 hours, 5 minutes, 10 seconds',
select ShipVisit {
  place: {name},
  ship: {name},
  date,
  clock,
  when_arthur_got_the_telegram := &lt;cal::local_time&gt;.clock + duration,
  hour,
  vampires_are
} filter .place.name = 'Galatz';
  
</code></pre>
<p>And now we get all the output that the <code>Time</code> type gave us before, plus our extra info about when Arthur got the telegram:</p>
<pre><code>{
  default::ShipVisit {
    place: default::City {name: 'Galatz'},
    ship: default::Ship {name: 'Czarina Catherine'},
    date: &lt;cal::local_date&gt;'1893-10-28',
    clock: '13:00:00',
    hour: '13',
    vampires_are: Asleep,
    when_arthur_got_the_telegram: &lt;cal::local_time&gt;'15:05:10',
  },
}
</code></pre>
<p>Since we are looking at <code>Place</code> again, now we can finish up the chapter by filling out the map with the <code>Region</code> type that we discussed. We'll have the <code>Region</code> type link to cities, castles and other places, and then change our <code>Country</code> type to link to <code>Region</code> objects.</p>
<pre><code class="language-sdl">type Country extending Place {
  multi regions: Region;
}

type Region extending Place {
  multi cities: City;
  multi other_places: OtherPlace;
  multi castles: Castle;
}
</code></pre>
<p>That connects our types based on <code>Place</code> quite well.</p>
<p>Now let's do a medium-sized entry that has <code>Country</code>, <code>Region</code>, and <code>City</code> all at the same time. We'll choose Germany in 1893 because Jonathan went through there first. It will have:</p>
<ul>
<li>One country: Germany,</li>
<li>Three regions: Prussia, Hesse, Saxony</li>
<li>Two cities for each region, for six in total: Berlin and K√∂nigsberg, Darmstadt and Mainz, Dresden and Leipzig.</li>
</ul>
<p>Here is the insert:</p>
<pre><code class="language-edgeql">insert Country {
  name := 'Germany',
  regions := {
    (insert Region {
      name := 'Prussia',
      cities := {
        (insert City {
          name := 'Berlin'
        }),
        (insert City {
          name := 'K√∂nigsberg'
        }),
      }
    }),
    (insert Region {
      name := 'Hesse',
      cities := {
        (insert City {
          name := 'Darmstadt'
        }),
        (insert City {
          name := 'Mainz'
        }),
      }
    }),
    (insert Region {
      name := 'Saxony',
      cities := {
        (insert City {
          name := 'Dresden'
        }),
        (insert City {
          name := 'Leipzig'
        }),
      }
    })
  }
};
</code></pre>
<p>With this nice structure set up, we can do things like select a <code>Region</code> and see the cities inside it, plus the country it belongs to. And to get <code>Country</code> from <code>Region</code> we can just use a computed backlink:</p>
<pre><code class="language-edgeql">select Region {
  name,
  cities: {
    name
  },
  country := .&lt;regions[is Country] {
    name
  }
};
</code></pre>
<p>With the backlink at the end we have another link between <code>Country</code> and its property <code>regions</code>, but now we get the <code>Country</code> as the output instead. Here's the output:</p>
<pre><code>{
  default::Region {
    name: 'Prussia',
    cities: {default::City {name: 'Berlin'}, default::City {name: 'K√∂nigsberg'}},
    country: {default::Country {name: 'Germany'}},
  },
  default::Region {
    name: 'Hesse',
    cities: {default::City {name: 'Darmstadt'}, default::City {name: 'Mainz'}},
    country: {default::Country {name: 'Germany'}},
  },
  default::Region {
    name: 'Saxony',
    cities: {default::City {name: 'Dresden'}, default::City {name: 'Leipzig'}},
    country: {default::Country {name: 'Germany'}},
  },
}
</code></pre>
<p><a href="chapter19/code.html">Here is all our code so far up to Chapter 19.</a></p>
<!-- quiz-start -->
<h2 id="time-to-practice-18"><a class="header" href="#time-to-practice-18">Time to practice</a></h2>
<ol>
<li>
<p>How would you display all the <code>City</code> names and the names of the <code>Region</code> they are in?</p>
</li>
<li>
<p>How about the <code>City</code> names plus the names of the <code>Region</code> and the name of the <code>Country</code> they are in?</p>
</li>
</ol>
<p><a href="chapter19/answers.html">See the answers here.</a></p>
<!-- quiz-end -->
<p><strong>Up next:</strong> <em>The race against time.</em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="tags-ddl-sdl-edgedb-community"><a class="header" href="#tags-ddl-sdl-edgedb-community">tags: Ddl, Sdl, Edgedb Community</a></h2>
<h1 id="chapter-20---the-final-battle"><a class="header" href="#chapter-20---the-final-battle">Chapter 20 - The final battle</a></h1>
<p>You made it to the final chapter, congratulations! Here's the final scene from the last chapter, though we won't spoil the final ending in case you now plan to read the original book:</p>
<blockquote>
<p>Mina is almost a vampire now, and says she can feel Dracula all the time, no matter what hour of the day. Van Helsing arrives at Castle Dracula and Mina waits outside. Van Helsing then goes inside and destroys the vampire women and Dracula's coffin.</p>
<p>At the same time the four other heroes (Jonathan Harker, Quincy Morris, Doctor Seward, Arthur Holmwood) are approaching from the south to try to catch up to Dracula. The sun is still up, so Dracula is inside his box protected from the sunlight on a wagon that his friends are taking to the castle as fast as they can. The sun is almost down, it is snowing, and our heroes need to hurry to catch him. A fight ensues, and the heroes drive back Dracula's friends and finally reach the box. They pull the nails back and open it up, and see Dracula lying inside. Jonathan pulls out his knife. But just then the sun goes down and night begins. Dracula smiles and opens his eyes, and...</p>
</blockquote>
<p>If you're curious about the ending to this scene, just <a href="https://www.gutenberg.org/files/345/345-h/345-h.htm#chap19">check out the book on Gutenberg</a> and search for &quot;the look of hate in them turned to triumph&quot;.</p>
<p>We are sure that the vampire women have been destroyed, however, so we can do one final change by giving them a <code>last_appearance</code>. Van Helsing destroys them on November 5, so we will insert that date. But don't forget to filter Lucy out - she's the only <code>MinorVampire</code> that isn't one of the three women at the castle.</p>
<pre><code class="language-edgeql">update MinorVampire filter .name != 'Lucy'
set {
  last_appearance := &lt;cal::local_date&gt;'1893-11-05'
};
</code></pre>
<p>Depending on what happens in the last battle, we might have to do the same for Dracula or some of the heroes...</p>
<h2 id="reviewing-the-schema"><a class="header" href="#reviewing-the-schema">Reviewing the schema</a></h2>
<p><a href="chapter20/code.html">Here's the schema and inserted data we have up to Chapter 20.</a></p>
<p>Now that you've made it through all 20 chapters, you should have a good understanding of the schema that we put together and how to work with it. Let's take a look at it one more time from top to bottom. We'll make sure that we fully understand it and think about which parts are good, and which need improvement, for an actual game.</p>
<p>First let's start with the schema in general.</p>
<ul>
<li>To migrate a schema, just use the {ref}<code> ``edgedb migration`` &lt;docs:ref_cli_edgedb_migration&gt;</code> tools. A simple <code>edgedb migration create</code> and <code>edgedb migrate</code> is all you need to migrate your schema to a new one.</li>
<li><code>module default {}</code>: We only used one module (namespace) for our schema, but you can make more modules if you like. You can see the module when you use <code>describe type as sdl</code> (or <code>as text</code>).</li>
</ul>
<p>Here's an example with <code>Person</code>, which starts like this and shows us the module it's located in:</p>
<p><code>abstract type default::Person</code></p>
<p>For a real game our schema would probably be a lot larger with various modules. We might see types in different modules like <code>abstract type characters::Person</code> and <code>abstract type places::Place</code>.</p>
<p>Our first type is called <code>HasNameAndCoffins</code>, which is abstract because we don't want any actual objects of this type. Instead, it is extended by types like <code>Place</code> because every place in our game:</p>
<ol>
<li>has a name, and</li>
<li>has a number of coffins (which is important because places without coffins are safer from vampires).</li>
</ol>
<pre><code class="language-sdl">abstract type HasNameAndCoffins {
  required coffins: int16 {
    default := 0;
  }
  required name: str {
    delegated constraint exclusive;
    constraint max_len_value(30);
  }
}
</code></pre>
<p>We could have gone with {eql:type}<code> ``int32`` &lt;docs:std::int32&gt;</code>, {eql:type}<code> ``int64`` &lt;docs:std::int64&gt;</code> or {eql:type}<code> ``bigint`` &lt;docs:std::bigint&gt;</code> for the <code>coffins</code> property but we probably won't see that many coffins so {eql:type}<code> ``int16`` &lt;docs:std::int16&gt;</code> is fine.</p>
<p>Next is <code>abstract type Person</code>. This type is by far the largest, and does most of the work for all of our characters. Fortunately, all vampires used to be people and can have things like <code>name</code> and <code>age</code>, so they can extend from it too.</p>
<pre><code class="language-sdl">abstract type Person extending HasMoney {
  required name: str {
    delegated constraint exclusive;
  }
  multi places_visited: Place;
  multi lovers: Person;
  property is_single := not exists .lovers;
  strength: int16;
  first_appearance: cal::local_date;
  last_appearance: cal::local_date;
  age: int16;
  title: str;
  degrees: array&lt;str&gt;;
  property conversational_name := .title ++ ' ' 
    ++ .name if exists .title else .name;
  property pen_name := .name ++ ', ' 
    ++ array_join(.degrees, ', ') if exists .degrees else .name;
}
</code></pre>
<p><code>exclusive</code> is probably the most common {ref}<code>constraint &lt;docs:ref_datamodel_constraints&gt;</code>, which we use to make sure that each character has a unique name. This works because we already know all the names of all the <code>NPC</code> types. But if there is a chance of more than one &quot;Jonathan Harker&quot; or other character, we could use the built-in <code>id</code> property instead. This built-in <code>id</code> is generated automatically and is already exclusive.</p>
<p>Properties like <code>conversational_name</code> are {ref}<code>computed properties &lt;docs:ref_datamodel_computed&gt;</code>. In our case, we added properties like <code>first</code> and <code>last</code> later on. It is tempting to remove <code>name</code> and only use <code>first</code> and <code>last</code> for every character, but the book has too many characters with names that wouldn't fit this like <code>Woman 2</code> and <code>The innkeeper</code>. In a standard database used to record the data for users of an app, we would certainly only use <code>first</code> and <code>last</code> and a field like <code>email</code> with <code>constraint exclusive</code> to make sure that all users are unique.</p>
<p>Every property has a type (like <code>str</code>, <code>bigint</code>, etc.). Computed properties have them too but we don't need to tell EdgeDB the type because the computed expression itself tells the type. For example, <code>pen_name</code> takes <code>.name</code> which is a <code>str</code> and adds more strings, which will of course produce a <code>str</code>. The <code>++</code> used to join them together is called {eql:op}<code>concatenation &lt;docs:strplus&gt;</code>. On the other hand, with a computed property you do have to tell EdgeDB whether it is a <code>property</code> or a <code>link</code>.</p>
<p>The two links on the <code>Person</code> type are <code>multi</code> links. Without the keyword <code>multi</code> it will be a single link and can only link to a single other object. This means that you may need to add <code>assert_single()</code> when creating a link or it will give this error:</p>
<pre><code>error: possibly more than one element returned by an expression
for a computed link 'former_self' declared as 'single'
</code></pre>
<p>On the other hand, backlinks have the opposite behavior: a backlink is a <code>multi</code> link by default, meaning that you have to write <code>single</code> otherwise.</p>
<p>For <code>first_appearance</code> and <code>last_appearance</code> we use {eql:type}<code>docs:cal::local_date</code> because our game is only based in one part of Europe inside a certain period. For a modern user database we would prefer {eql:type}<code>docs:std::datetime</code> because it is timezone aware and ISO8601 compliant.</p>
<p>So for databases with users around the world, <code>datetime</code> is usually the best choice. Then you can use a function like {eql:func}<code>docs:std::to_datetime</code> to turn five <code>int64</code>s, one <code>float64</code> (for the seconds) and one <code>str</code> (for <a href="https://en.wikipedia.org/wiki/List_of_time_zone_abbreviations">the timezone</a>) into a <code>datetime</code> that is always returned as UTC:</p>
<pre><code>db&gt; select std::to_datetime(2020, 10, 12, 15, 35, 5.5, 'KST');
....... # October 12 2020, 3:35 pm and 5.5 seconds in Korea (KST = Korean Standard Time)
{&lt;datetime&gt;'2020-10-12T06:35:05.500Z'} # The return value is UTC, 6:35 (plus 5.5 seconds) in the morning
</code></pre>
<p>A similar abstract type to <code>HasNameAndCoffins</code> is this one:</p>
<pre><code class="language-sdl">abstract type HasNumber {
  required number: int16;
}
</code></pre>
<p>We only used this for the <code>Crewman</code> type, which only extends two abstract types and nothing else:</p>
<pre><code class="language-sdl">type Crewman extending HasNumber, Person {
  overloaded name: str {
    default := 'Crewman ' ++ &lt;str&gt;.number;
  }
}
</code></pre>
<p>This <code>HasNumber</code> type was used for the five <code>Crewman</code> objects, who don't have names. Because their <code>name</code> property inherited from <code>Person</code> is required, we used their <code>number</code> property to give them each a name: Crewman 1, Crewman 2, and so on.</p>
<pre><code class="language-edgeql">for n in {1, 2, 3, 4, 5}
  union (
    insert Crewman {
      number := n,
      first_appearance := cal::to_local_date(1893, 7, 6),
      last_appearance := cal::to_local_date(1893, 7, 16),
    }
  );
</code></pre>
<p>So even though <code>HasNumber</code> was rarely used, it could become useful later on. For types later in the game you could imagine this being used for townspeople or random NPCs: 'Shopkeeper 2', 'Carriage Driver 12', etc.</p>
<p>Our vampire types extend <code>Person</code>, while <code>MinorVampire</code> also has a single and non-required link to <code>Person</code>. This is because some characters begin as humans and are &quot;reborn&quot; as vampires. With this format, we can use the properties <code>first_appearance</code> and <code>last_appearance</code> from <code>Person</code> to have them appear in the game. And if one is turned into a <code>MinorVampire</code>, we can link the two.</p>
<pre><code class="language-sdl">type Vampire extending Person {
  multi slaves: MinorVampire {
    on source delete delete target;
    property combined_strength := (Vampire.strength + .strength) / 2;
  }
  property army_strength := sum(.slaves@combined_strength);
}

type MinorVampire extending Person {
  former_self: Person;
  single link master := assert_single(.&lt;slaves[is Vampire]);
  property master_name := .master.name;
};
</code></pre>
<p>With this format we can do a query like this one that pulls up all people who have turned into <code>MinorVampire</code>s.</p>
<pre><code class="language-edgeql">select Person {
  name,
  vampire_name := .&lt;former_self[is MinorVampire].name
} filter exists .vampire_name;
</code></pre>
<p>In our case, that's just Lucy: <code>{default::NPC {name: 'Lucy Westenra', vampire_name: {'Lucy'}}}</code> But if we wanted, we could extend the game back before the events of the book and link the vampire women to an <code>NPC</code> type. That would become their <code>former_self</code>.</p>
<p>The <code>PC</code> and <code>Sailor</code> types show two enums and one sequence that we used:</p>
<pre><code class="language-sdl">scalar type Rank extending enum&lt;Captain, FirstMate, SecondMate, Cook&gt;;

type Sailor extending Person {
  rank: Rank;
}

scalar type Class extending enum&lt;Rogue, Mystic, Merchant&gt;;

scalar type PCNumber extending sequence;

type PC extending Person {
  required class: Class;
  required created_at: datetime {
    default := datetime_of_statement();
  }
  required number: PCNumber {
    default := sequence_next(introspect PCNumber);
  }
  multi party: Party {
    on source delete delete target if orphan;
    on target delete allow;
  }
  overloaded required name: str {
    constraint max_len_value(30);
  }
  last_updated: datetime {
    rewrite insert, update using (datetime_of_statement());
  }
  bonus_item: LotteryTicket {
    rewrite insert, update using (get_ticket());
  }
}
</code></pre>
<p>The <code>PCNumber</code> type has been quite useful, allowing us to keep track of how many <code>PC</code> objects have been created even if some of them get deleted later. If you end up adding and deleting a lot of <code>PC</code> objects then the following query will show pretty different numbers between the latest sequence number and the total number of <code>PC</code> objects:</p>
<pre><code class="language-edgeql">with latest := (select &lt;str&gt;max(PC.number)),
select {'Total PCs created: ' ++ latest ++ ' Current PCs: ' ++ &lt;str&gt;count(PC) };
</code></pre>
<p><code>ShipVisit</code> is one of our two &quot;hackiest&quot; (but most fun) types. We stole some of it from the <code>Time</code> type that we created earlier and later decided to turn into a single global object. Inside the <code>ShipVisit</code> type we have a <code>clock</code> property that is just a string, but gets used in this way:</p>
<ul>
<li>by casting it into a {eql:type}<code>docs:cal::local_time</code> to make the <code>clock_time</code> property,</li>
<li>by slicing its first two characters to get the <code>hour</code> property, which is just a string. This is only possible because we know that even single digit numbers like <code>1</code> need to be written with two digits: <code>01</code></li>
<li>by another computed property called <code>vampires_are</code> that is either <code>Asleep</code> or <code>Awake</code> depending on the <code>hour</code> property we just made, cast into an <code>int16</code>.</li>
</ul>
<pre><code class="language-sdl">type ShipVisit {
  required ship: Ship;
  required place: Place;
  required date: cal::local_date;
  clock: str;
  property clock_time := &lt;cal::local_time&gt;.clock;
  property hour := .clock[0:2];
  property vampires_are := SleepState.Asleep if &lt;int16&gt;.hour &gt; 7 and &lt;int16&gt;.hour &lt; 19
        else SleepState.Awake;
}
</code></pre>
<p>The NPC type is where we first saw the {ref}<code> ``overloaded`` &lt;docs:ref_eql_sdl_links_overloading&gt;</code> keyword, which lets us use properties, links, functions etc. in different ways than in the type's parent type. Here we wanted to constrain <code>age</code> to 120 years, and to use the <code>places_visited</code> link in a different way than in <code>Person</code> by giving it London as the default.</p>
<pre><code class="language-sdl">type NPC extending Person {
  overloaded age: int16 {
    constraint max_value(120)
  }
}
</code></pre>
<p>Our <code>Place</code> type shows that you can extend as many times as you want. It's an <code>abstract type</code> that extends another <code>abstract type</code>, and then gets extended for other types like <code>City</code>.</p>
<pre><code class="language-sdl">abstract type Place extending HasNameAndCoffins {
  modern_name: str;
  multi important_places: Landmark;
}
</code></pre>
<p>The <code>important_places</code> property used to be an <code>&lt;array&lt;str&gt;&gt;</code>, but in Chapter 16 we decided to create a <code>Landmark</code> type that would represent the smallest type of location that would appear in the game such as hotels, parks, universities, and so on. These locations are so small that they don't need to track the number of coffins, because the number of coffins is relevant for larger spaces of land to help determine if the location can be easily terrorized by vampires or not.</p>
<p>Annotations: we used <code>abstract annotation</code> to add a new annotation:</p>
<pre><code class="language-sdl">abstract annotation warning;
</code></pre>
<p>This was necessary because by default a type {ref}<code>can only have annotations &lt;docs:ref_datamodel_annotations&gt;</code> called <code>title</code>, <code>description</code>, or <code>deprecated</code>. We only used annotations for fun for this one type, because nobody else is working on our database yet. But if we made a real database for a game with many people working on it, we would put annotations everywhere to make sure that they know how to use each type.</p>
<p>Our <code>Lord</code> type was only created to show how to use <code>constraint expression on</code>, which lets us make our own constraints:</p>
<pre><code class="language-sdl">type Lord extending Person {
  constraint expression on (contains(__subject__.name, 'Lord')) {
    errmessage := &quot;All lords need \'Lord\' in their name&quot;;
  }
}
</code></pre>
<p>We might remove this in a real game, or maybe it would become <code>type Lord extending PC</code> so player characters could choose to be a lord, thief, detective, etc.</p>
<p>The <code>Lord</code> type uses the function {eql:func}<code>docs:std::contains</code> which returns <code>true</code> if the item we are searching for is inside the string, array, etc. It also uses <code>__subject__</code> which refers to the type itself: <code>__subject__.name</code> means <code>Person.name</code> in this case. {eql:constraint}<code>Here are some more examples &lt;docs:std::expression&gt;</code> from the documentation of using <code>constraint expression on</code>.</p>
<p>Another possible way to create a <code>Lord</code> is to do it this way, since <code>Person</code> has a property called <code>title</code>:</p>
<pre><code class="language-sdl">type Lord extending Person {
  constraint expression on (__subject__.title = 'Lord') {
    errmessage := &quot;All lords need \'Lord\' in their title&quot;;
  }
}
</code></pre>
<p>This will depend on if we want to create <code>Lord</code> types with names just as a single string in <code>.name</code>, or by using <code>.first</code>, <code>.last</code>, <code>.title</code> etc. with a computed property to form the full name.</p>
<p>Our next types extending <code>Place</code> including <code>Country</code> and <code>Region</code> were looked at just last chapter, so we won't review them here. But <code>Castle</code> is a bit unique:</p>
<pre><code class="language-sdl">type Castle extending Place {
  doors: array&lt;int16&gt;;
}
</code></pre>
<p>Back in Chapter 7, we used this in a query to see if Jonathan could break any of the doors and escape the castle. The idea was simple: Jonathan would try to open every door, and if he had more strength then any one of them then he could escape the castle.</p>
<pre><code class="language-edgeql">with
  jonathan_strength := (select Person filter .name = 'Jonathan Harker').strength,
  doors := (select Castle filter .name = 'Castle Dracula').doors,
select jonathan_strength &gt; min(array_unpack(doors));
</code></pre>
<p>However, later on we learned the <code>any()</code> function so let's see how we could use it here. With <code>any()</code>, we could change the query to this:</p>
<pre><code class="language-edgeql">with
  jonathan_strength := (select Person filter .name = 'Jonathan Harker').strength,
  doors := (select Castle filter .name = 'Castle Dracula').doors,
select any(array_unpack(doors) &lt; jonathan_strength); # Only this part is different
</code></pre>
<p>And of course, we could also create a function to do the same now that we know how to write functions and how to use <code>any()</code>. Since we are filtering by name ('Jonathan Harker' and 'Castle Dracula'), the function would also just take two strings and do the same query.</p>
<p>Also don't forget that we needed {eql:func}<code>docs:std::array_unpack</code> because the function {eql:func}<code>docs:std::any</code> works on sets:</p>
<pre><code class="language-sdl">std::any(values: set of bool) -&gt; bool
</code></pre>
<p>So this (a set) will work: <code>select any({5, 6, 7} = 7);</code></p>
<p>But this (an array) will not: <code>select any([5, 6, 7] = 7);</code></p>
<p>Our next type is <code>BookExcerpt</code>, which we imagined being useful for the developers creating the database. It would need a lot of inserts from each part of the book, with the text exactly as written. We chose to use {ref}<code> ``index on`` &lt;docs:ref_eql_sdl_indexes&gt;</code> for the <code>date</code> property, which will then be faster when we need to order by date. Remember to use indexes only where needed: they speed up queries that filter, order, and group, but make the database larger overall and slow down inserts and updates.</p>
<pre><code class="language-sdl">type BookExcerpt {
  required date: cal::local_datetime;
  required excerpt: str;
  index on (.date);
  required author: Person;
}
</code></pre>
<p>Next is our other fun and hacky type, <code>Event</code>.</p>
<pre><code class="language-sdl">type Event {
  required description: str;
  required start_time: cal::local_datetime;
  required end_time: cal::local_datetime;
  required multi place: Place;
  required multi people: Person;
  location: tuple&lt;float64, float64&gt;;
  index on (.location);
  property ns_suffix := '_N_' if .location.0 &gt; 0.0 else '_S_';
  property ew_suffix := '_E' if .location.1 &gt; 0.0 else '_W';
  property url := get_url() 
    ++ &lt;str&gt;(math::abs(.location.0)) ++ .ns_suffix 
    ++ &lt;str&gt;(math::abs(.location.1)) ++ .ew_suffix;
}
</code></pre>
<p>This one is probably closest to an actual usable type for a real game. With <code>start_time</code> and <code>end_time</code>, <code>place</code> and <code>people</code> (plus <code>url</code>) we can properly arrange which characters are at which locations, and when. The <code>description</code> property makes it easy for users of the database to find events. It might contain something like <code>'The Demeter arrives at Whitby, crashing on the beach'</code>.</p>
<p>And the output for the <code>Event</code> type is especially nice as JSON. You can imagine how useful this might be for our game setting:</p>
<pre><code>{
  &quot;id&quot;: &quot;d80dde9c-fec9-11ed-9c27-bffd94675ea1&quot;,
  &quot;description&quot;: &quot;Dr. Seward gives Lucy garlic flowers to help her sleep. She falls asleep and the others leave the room.&quot;,
  &quot;east&quot;: false,
  &quot;location&quot;: [54.4858, 0.6206],
  &quot;url&quot;: &quot;https://geohack.toolforge.org/geohack.php?params=54.4858_N_0.6206_W54.4858_N_0.6206_W&quot;,
  &quot;end_time&quot;: &quot;1893-09-11T23:00:00&quot;,
  &quot;start_time&quot;: &quot;1893-09-11T18:00:00&quot;,
  &quot;people&quot;: [
    {
      &quot;strength&quot;: 4,
      &quot;id&quot;: &quot;f22b1910-fd08-11ed-ab09-9b95a39d5d69&quot;,
      &quot;first_appearance&quot;: null,
      &quot;last_appearance&quot;: &quot;1893-09-20&quot;,
      &quot;name&quot;: &quot;Lucy Westenra&quot;,
      &quot;age&quot;: null,
      &quot;title&quot;: null,
      &quot;conversational_name&quot;: &quot;Lucy Westenra&quot;,
      &quot;degrees&quot;: null,
      &quot;pen_name&quot;: &quot;Lucy Westenra&quot;
    },
    {
      &quot;strength&quot;: 2,
      &quot;id&quot;: &quot;dea9080a-fe8b-11ed-9759-f3313536553b&quot;,
      &quot;first_appearance&quot;: null,
      &quot;last_appearance&quot;: null,
      &quot;name&quot;: &quot;John Seward&quot;,
      &quot;age&quot;: null,
      &quot;title&quot;: null,
      &quot;conversational_name&quot;: &quot;John Seward&quot;,
      &quot;degrees&quot;: null,
      &quot;pen_name&quot;: &quot;John Seward&quot;
    },
    {
      &quot;strength&quot;: 4,
      &quot;id&quot;: &quot;70bad6e0-fea2-11ed-97e2-ef3281250140&quot;,
      &quot;first_appearance&quot;: null,
      &quot;last_appearance&quot;: null,
      &quot;name&quot;: &quot;Abraham Van Helsing&quot;,
      &quot;age&quot;: null,
      &quot;title&quot;: &quot;Dr.&quot;,
      &quot;conversational_name&quot;: &quot;Dr. Abraham Van Helsing&quot;,
      &quot;degrees&quot;: &quot;M.D., Ph. D. Lit., etc.&quot;,
      &quot;pen_name&quot;: &quot;Abraham Van Helsing, M.D., Ph. D. Lit., etc.&quot;
    }
  ],
  &quot;place&quot;: [
    {
      &quot;id&quot;: &quot;d64af6d0-fec9-11ed-9c27-a3cf8be8d973&quot;,
      &quot;important_places&quot;: null,
      &quot;modern_name&quot;: null,
      &quot;name&quot;: &quot;Whitby&quot;,
      &quot;coffins&quot;: 0
    }
  ],
  &quot;excerpt&quot;: []
}
</code></pre>
<p>The last two types in our schema, <code>Currency</code> and <code>Pound</code>, were created just two chapters ago so they are still fresh in our mind. We won't need to review them here.</p>
<h2 id="navigating-edgedb-documentation"><a class="header" href="#navigating-edgedb-documentation">Navigating EdgeDB documentation</a></h2>
<p>Now that you have reached the end of the book, you'll be referencing our documentation to refresh what you know and to learn more. We'll close the book out with some tips to do so, so that it feels familiar and easy to look through.</p>
<h3 id="syntax"><a class="header" href="#syntax">Syntax</a></h3>
<p>This book included a lot of links to EdgeDB documentation, such as types, functions, and so on. If you are trying to create one of these items and are having trouble, a good idea is to start with the section on syntax. This section always shows the order you need to follow, and all the options you have. We looked at the syntax of a few items during this book, but there is a lot more of this to reference in the documentation.</p>
<p>For a simple example, {ref}<code>here is the syntax on creating a module &lt;docs:ref_eql_sdl_modules&gt;</code>:</p>
<pre><code class="language-sdl-synopsis">module ModuleName &quot;{&quot;
  [ schema-declarations ]
  ...
&quot;}&quot;
</code></pre>
<p>Looking at that you can see that a module is just a module name, <code>{}</code>, and everything inside (the schema declarations). The <code>[]</code> square brackets in documentation are used to show optional input. In other words, a module can contain schema declarations or not. Easy enough.</p>
<p>How about object types? {ref}<code>They look like this &lt;docs:ref_eql_sdl_object_types&gt;</code>:</p>
<pre><code class="language-sdl-synopsis">[abstract] type TypeName [extending supertype [, ...] ]
[ &quot;{&quot;
    [ annotation-declarations ]
    [ property-declarations ]
    [ link-declarations ]
    [ constraint-declarations ]
    [ index-declarations ]
    ...
  &quot;}&quot; ]
</code></pre>
<p>This should be familiar to you: you need <code>type TypeName</code> to start. You can optionally add <code>abstract</code> on the left and <code>extending</code> for other types, and then everything else goes inside <code>{}</code>.</p>
<p>Meanwhile, the {ref}<code>properties are more complex &lt;docs:ref_eql_sdl_props&gt;</code> and include three types: concrete, computed, and abstract. We're most familiar with concrete so let's take a look at that:</p>
<pre><code class="language-sdl-synopsis">[ overloaded ] [{required | optional}] [{single | multi}]
  [ property ] name : type
  [ &quot;{&quot;
      [ extending base [, ...] ; ]
      [ default := expression ; ]
      [ readonly := {true | false} ; ]
      [ annotation-declarations ]
      [ constraint-declarations ]
      ...
    &quot;}&quot; ]
</code></pre>
<p>The <code>{ | }</code> in documentation is used to show the possible options available to you. So <code>[{required | optional}]</code> means that you don't need to write either required or optional (because both are inside <code>[]</code> square brackets), but if you choose to use it, you must choose either <code>required</code> or <code>optional</code>, not both.</p>
<p>You can think of the syntax as a helpful guide to keep your declarations in the right order, and to give you ideas of the full range of possibilities.</p>
<h3 id="dipping-into-ddl"><a class="header" href="#dipping-into-ddl">Dipping into DDL</a></h3>
<p>We have only seen DDL in our <code>.edgeql</code> files that are automatically generated every time a migration takes place. DDL used to be used sometimes in the past, and was even mentioned in the first edition of this book. But with better and better migration tools, there is little need for it. And in fact, EdgeDB is set by default to disallow DDL. Take this attempt to use DDL for example and the error output it generates:</p>
<pre><code>db&gt; create function hi() -&gt; str using (&quot;Hi&quot;);
error: QueryError: bare DDL statements are not allowed in this database
  ‚îå‚îÄ &lt;query&gt;:1:1
  ‚îÇ
1 ‚îÇ create function hi() -&gt; str using (&quot;Hi&quot;);
  ‚îÇ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Use the migration commands instead.
  ‚îÇ
  = The `allow_bare_ddl` configuration variable is set to 'NeverAllow'.  The `edgedb migrate` command normally sets this to avoid accidental schema changes outside of the migration flow.
</code></pre>
<p>If you absolutely do want to use DDL, the configuration <a href="https://www.edgedb.com/docs/reference/configuration#query-behavior">can be temporarily changed</a> until a migration is run. Otherwise, the most recommended way to interact with DDL is by gaining a passive knowledge of it in case you want to double check a migration script before applying it.</p>
<h2 id="edgedb-lexical-structure"><a class="header" href="#edgedb-lexical-structure">EdgeDB lexical structure</a></h2>
<p>You might want to take a look at or bookmark {ref}<code>this page &lt;docs:ref_eql_lexical&gt;</code> for reference during your projects. It contains the whole lexical structure of EdgeDB including items that are maybe too dry for a textbook like this one. This includes things like order of precedence for operators, all reserved keywords, which characters can be used in identifiers, and so on.</p>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting help</a></h2>
<p>Help is always just a message away. The most active place to discuss EdgeDB and get help is <a href="https://discord.gg/edgedb">our Discord server</a>, while the <a href="https://github.com/edgedb/edgedb/discussions">discussion board</a> on GitHub is another good place to start a conversation. You can also <a href="https://github.com/edgedb/edgedb/issues/new/choose">start an issue here</a> on EdgeDB, or do the same for the Easy EdgeDB book on <a href="https://github.com/edgedb/easy-edgedb/">its dedicated GitHub repo</a>.</p>
<h2 id="and-now-its-time-to-say-goodbye"><a class="header" href="#and-now-its-time-to-say-goodbye">And now it's time to say goodbye</a></h2>
<p>We hope you enjoyed learning EdgeDB through a story and are now familiar enough with it to implement it for your own projects. Ironically, if we wrote the book with enough detail to answer all your questions then we might never see you on our Discord! If that's the case, then we wish you the best of luck with your projects. Let's finish the book up with a poem from another book, the Lord of the Rings, on the endless possibilities of life.</p>
<blockquote>
<p>The Road goes ever on and on
Down from the door where it began.
Now far ahead the Road has gone,
And I must follow, if I can,
Pursuing it with eager feet,
Until it joins some larger way
Where many paths and errands meet.
And whither then? I cannot say.</p>
</blockquote>
<p>See you, or not see you, however things turn out! Thanks again for reading.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
